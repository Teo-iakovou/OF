"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msgpackr";
exports.ids = ["vendor-chunks/msgpackr"];
exports.modules = {

/***/ "(rsc)/./node_modules/msgpackr/dist/node.cjs":
/*!*********************************************!*\
  !*** ./node_modules/msgpackr/dist/node.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar module$1 = __webpack_require__(/*! module */ \"module\");\nvar decoder;\ntry {\n    decoder = new TextDecoder();\n} catch (error) {}\nvar src;\nvar srcEnd;\nvar position$1 = 0;\nconst EMPTY_ARRAY = [];\nvar strings = EMPTY_ARRAY;\nvar stringPosition = 0;\nvar currentUnpackr = {};\nvar currentStructures;\nvar srcString;\nvar srcStringStart = 0;\nvar srcStringEnd = 0;\nvar bundledStrings$1;\nvar referenceMap;\nvar currentExtensions = [];\nvar dataView;\nvar defaultOptions = {\n    useRecords: false,\n    mapsAsObjects: true\n};\nclass C1Type {\n}\nconst C1 = new C1Type();\nC1.name = \"MessagePack 0xC1\";\nvar sequentialMode = false;\nvar inlineObjectReadThreshold = 2;\nvar readStruct$1, onLoadedStructures$1, onSaveState;\n// no-eval build\ntry {\n    new Function(\"\");\n} catch (error) {\n    // if eval variants are not supported, do not create inline object readers ever\n    inlineObjectReadThreshold = Infinity;\n}\nclass Unpackr {\n    constructor(options){\n        if (options) {\n            if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;\n            if (options.sequential && options.trusted !== false) {\n                options.trusted = true;\n                if (!options.structures && options.useRecords != false) {\n                    options.structures = [];\n                    if (!options.maxSharedStructures) options.maxSharedStructures = 0;\n                }\n            }\n            if (options.structures) options.structures.sharedLength = options.structures.length;\n            else if (options.getStructures) {\n                (options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures\n                options.structures.sharedLength = 0;\n            }\n            if (options.int64AsNumber) {\n                options.int64AsType = \"number\";\n            }\n        }\n        Object.assign(this, options);\n    }\n    unpack(source, options) {\n        if (src) {\n            // re-entrant execution, save the state and restore it after we do this unpack\n            return saveState$1(()=>{\n                clearSource();\n                return this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options);\n            });\n        }\n        if (!source.buffer && source.constructor === ArrayBuffer) source = typeof Buffer !== \"undefined\" ? Buffer.from(source) : new Uint8Array(source);\n        if (typeof options === \"object\") {\n            srcEnd = options.end || source.length;\n            position$1 = options.start || 0;\n        } else {\n            position$1 = 0;\n            srcEnd = options > -1 ? options : source.length;\n        }\n        stringPosition = 0;\n        srcStringEnd = 0;\n        srcString = null;\n        strings = EMPTY_ARRAY;\n        bundledStrings$1 = null;\n        src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        } catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            src = null;\n            if (source instanceof Uint8Array) throw error;\n            throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source == \"object\" ? source.constructor.name : typeof source));\n        }\n        if (this instanceof Unpackr) {\n            currentUnpackr = this;\n            if (this.structures) {\n                currentStructures = this.structures;\n                return checkedRead(options);\n            } else if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n        } else {\n            currentUnpackr = defaultOptions;\n            if (!currentStructures || currentStructures.length > 0) currentStructures = [];\n        }\n        return checkedRead(options);\n    }\n    unpackMultiple(source, forEach) {\n        let values, lastPosition = 0;\n        try {\n            sequentialMode = true;\n            let size = source.length;\n            let value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);\n            if (forEach) {\n                if (forEach(value, lastPosition, position$1) === false) return;\n                while(position$1 < size){\n                    lastPosition = position$1;\n                    if (forEach(checkedRead(), lastPosition, position$1) === false) {\n                        return;\n                    }\n                }\n            } else {\n                values = [\n                    value\n                ];\n                while(position$1 < size){\n                    lastPosition = position$1;\n                    values.push(checkedRead());\n                }\n                return values;\n            }\n        } catch (error) {\n            error.lastPosition = lastPosition;\n            error.values = values;\n            throw error;\n        } finally{\n            sequentialMode = false;\n            clearSource();\n        }\n    }\n    _mergeStructures(loadedStructures, existingStructures) {\n        if (onLoadedStructures$1) loadedStructures = onLoadedStructures$1.call(this, loadedStructures);\n        loadedStructures = loadedStructures || [];\n        if (Object.isFrozen(loadedStructures)) loadedStructures = loadedStructures.map((structure)=>structure.slice(0));\n        for(let i = 0, l = loadedStructures.length; i < l; i++){\n            let structure = loadedStructures[i];\n            if (structure) {\n                structure.isShared = true;\n                if (i >= 32) structure.highByte = i - 32 >> 5;\n            }\n        }\n        loadedStructures.sharedLength = loadedStructures.length;\n        for(let id in existingStructures || []){\n            if (id >= 0) {\n                let structure = loadedStructures[id];\n                let existing = existingStructures[id];\n                if (existing) {\n                    if (structure) (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;\n                    loadedStructures[id] = existing;\n                }\n            }\n        }\n        return this.structures = loadedStructures;\n    }\n    decode(source, options) {\n        return this.unpack(source, options);\n    }\n}\nfunction checkedRead(options) {\n    try {\n        if (!currentUnpackr.trusted && !sequentialMode) {\n            let sharedLength = currentStructures.sharedLength || 0;\n            if (sharedLength < currentStructures.length) currentStructures.length = sharedLength;\n        }\n        let result;\n        if (currentUnpackr.randomAccessStructure && src[position$1] < 0x40 && src[position$1] >= 0x20 && readStruct$1) {\n            result = readStruct$1(src, position$1, srcEnd, currentUnpackr);\n            src = null; // dispose of this so that recursive unpack calls don't save state\n            if (!(options && options.lazy) && result) result = result.toJSON();\n            position$1 = srcEnd;\n        } else result = read();\n        if (bundledStrings$1) {\n            position$1 = bundledStrings$1.postBundlePosition;\n            bundledStrings$1 = null;\n        }\n        if (sequentialMode) // we only need to restore the structures if there was an error, but if we completed a read,\n        // we can clear this out and keep the structures we read\n        currentStructures.restoreStructures = null;\n        if (position$1 == srcEnd) {\n            // finished reading this source, cleanup references\n            if (currentStructures && currentStructures.restoreStructures) restoreStructures();\n            currentStructures = null;\n            src = null;\n            if (referenceMap) referenceMap = null;\n        } else if (position$1 > srcEnd) {\n            // over read\n            throw new Error(\"Unexpected end of MessagePack data\");\n        } else if (!sequentialMode) {\n            let jsonView;\n            try {\n                jsonView = JSON.stringify(result, (_, value)=>typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100);\n            } catch (error) {\n                jsonView = \"(JSON view not available \" + error + \")\";\n            }\n            throw new Error(\"Data read, but end of buffer not reached \" + jsonView);\n        }\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    } catch (error) {\n        if (currentStructures && currentStructures.restoreStructures) restoreStructures();\n        clearSource();\n        if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\") || position$1 > srcEnd) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n}\nfunction restoreStructures() {\n    for(let id in currentStructures.restoreStructures){\n        currentStructures[id] = currentStructures.restoreStructures[id];\n    }\n    currentStructures.restoreStructures = null;\n}\nfunction read() {\n    let token = src[position$1++];\n    if (token < 0xa0) {\n        if (token < 0x80) {\n            if (token < 0x40) return token;\n            else {\n                let structure = currentStructures[token & 0x3f] || currentUnpackr.getStructures && loadStructures()[token & 0x3f];\n                if (structure) {\n                    if (!structure.read) {\n                        structure.read = createStructureReader(structure, token & 0x3f);\n                    }\n                    return structure.read();\n                } else return token;\n            }\n        } else if (token < 0x90) {\n            // map\n            token -= 0x80;\n            if (currentUnpackr.mapsAsObjects) {\n                let object = {};\n                for(let i = 0; i < token; i++){\n                    let key = readKey();\n                    if (key === \"__proto__\") key = \"__proto_\";\n                    object[key] = read();\n                }\n                return object;\n            } else {\n                let map = new Map();\n                for(let i = 0; i < token; i++){\n                    map.set(read(), read());\n                }\n                return map;\n            }\n        } else {\n            token -= 0x90;\n            let array = new Array(token);\n            for(let i = 0; i < token; i++){\n                array[i] = read();\n            }\n            if (currentUnpackr.freezeData) return Object.freeze(array);\n            return array;\n        }\n    } else if (token < 0xc0) {\n        // fixstr\n        let length = token - 0xa0;\n        if (srcStringEnd >= position$1) {\n            return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);\n        }\n        if (srcStringEnd == 0 && srcEnd < 140) {\n            // for small blocks, avoiding the overhead of the extract call is helpful\n            let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n            if (string != null) return string;\n        }\n        return readFixedString(length);\n    } else {\n        let value;\n        switch(token){\n            case 0xc0:\n                return null;\n            case 0xc1:\n                if (bundledStrings$1) {\n                    value = read(); // followed by the length of the string in characters (not bytes!)\n                    if (value > 0) return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value);\n                    else return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 -= value);\n                }\n                return C1; // \"never-used\", return special object to denote that\n            case 0xc2:\n                return false;\n            case 0xc3:\n                return true;\n            case 0xc4:\n                // bin 8\n                value = src[position$1++];\n                if (value === undefined) throw new Error(\"Unexpected end of buffer\");\n                return readBin(value);\n            case 0xc5:\n                // bin 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readBin(value);\n            case 0xc6:\n                // bin 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readBin(value);\n            case 0xc7:\n                // ext 8\n                return readExt(src[position$1++]);\n            case 0xc8:\n                // ext 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readExt(value);\n            case 0xc9:\n                // ext 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readExt(value);\n            case 0xca:\n                value = dataView.getFloat32(position$1);\n                if (currentUnpackr.useFloat32 > 2) {\n                    // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                    let multiplier = mult10[(src[position$1] & 0x7f) << 1 | src[position$1 + 1] >> 7];\n                    position$1 += 4;\n                    return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n                }\n                position$1 += 4;\n                return value;\n            case 0xcb:\n                value = dataView.getFloat64(position$1);\n                position$1 += 8;\n                return value;\n            // uint handlers\n            case 0xcc:\n                return src[position$1++];\n            case 0xcd:\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return value;\n            case 0xce:\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return value;\n            case 0xcf:\n                if (currentUnpackr.int64AsType === \"number\") {\n                    value = dataView.getUint32(position$1) * 0x100000000;\n                    value += dataView.getUint32(position$1 + 4);\n                } else if (currentUnpackr.int64AsType === \"string\") {\n                    value = dataView.getBigUint64(position$1).toString();\n                } else if (currentUnpackr.int64AsType === \"auto\") {\n                    value = dataView.getBigUint64(position$1);\n                    if (value <= BigInt(2) << BigInt(52)) value = Number(value);\n                } else value = dataView.getBigUint64(position$1);\n                position$1 += 8;\n                return value;\n            // int handlers\n            case 0xd0:\n                return dataView.getInt8(position$1++);\n            case 0xd1:\n                value = dataView.getInt16(position$1);\n                position$1 += 2;\n                return value;\n            case 0xd2:\n                value = dataView.getInt32(position$1);\n                position$1 += 4;\n                return value;\n            case 0xd3:\n                if (currentUnpackr.int64AsType === \"number\") {\n                    value = dataView.getInt32(position$1) * 0x100000000;\n                    value += dataView.getUint32(position$1 + 4);\n                } else if (currentUnpackr.int64AsType === \"string\") {\n                    value = dataView.getBigInt64(position$1).toString();\n                } else if (currentUnpackr.int64AsType === \"auto\") {\n                    value = dataView.getBigInt64(position$1);\n                    if (value >= BigInt(-2) << BigInt(52) && value <= BigInt(2) << BigInt(52)) value = Number(value);\n                } else value = dataView.getBigInt64(position$1);\n                position$1 += 8;\n                return value;\n            case 0xd4:\n                // fixext 1\n                value = src[position$1++];\n                if (value == 0x72) {\n                    return recordDefinition(src[position$1++] & 0x3f);\n                } else {\n                    let extension = currentExtensions[value];\n                    if (extension) {\n                        if (extension.read) {\n                            position$1++; // skip filler byte\n                            return extension.read(read());\n                        } else if (extension.noBuffer) {\n                            position$1++; // skip filler byte\n                            return extension();\n                        } else return extension(src.subarray(position$1, ++position$1));\n                    } else throw new Error(\"Unknown extension \" + value);\n                }\n            case 0xd5:\n                // fixext 2\n                value = src[position$1];\n                if (value == 0x72) {\n                    position$1++;\n                    return recordDefinition(src[position$1++] & 0x3f, src[position$1++]);\n                } else return readExt(2);\n            case 0xd6:\n                // fixext 4\n                return readExt(4);\n            case 0xd7:\n                // fixext 8\n                return readExt(8);\n            case 0xd8:\n                // fixext 16\n                return readExt(16);\n            case 0xd9:\n                // str 8\n                value = src[position$1++];\n                if (srcStringEnd >= position$1) {\n                    return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);\n                }\n                return readString8(value);\n            case 0xda:\n                // str 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                if (srcStringEnd >= position$1) {\n                    return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);\n                }\n                return readString16(value);\n            case 0xdb:\n                // str 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                if (srcStringEnd >= position$1) {\n                    return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);\n                }\n                return readString32(value);\n            case 0xdc:\n                // array 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readArray(value);\n            case 0xdd:\n                // array 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readArray(value);\n            case 0xde:\n                // map 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readMap(value);\n            case 0xdf:\n                // map 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readMap(value);\n            default:\n                if (token >= 0xe0) return token - 0x100;\n                if (token === undefined) {\n                    let error = new Error(\"Unexpected end of MessagePack data\");\n                    error.incomplete = true;\n                    throw error;\n                }\n                throw new Error(\"Unknown MessagePack token \" + token);\n        }\n    }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure, firstId) {\n    function readObject() {\n        // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n        if (readObject.count++ > inlineObjectReadThreshold) {\n            let readObject = structure.read = new Function(\"r\", \"return function(){return \" + (currentUnpackr.freezeData ? \"Object.freeze\" : \"\") + \"({\" + structure.map((key)=>key === \"__proto__\" ? \"__proto_:r()\" : validName.test(key) ? key + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"})}\")(read);\n            if (structure.highByte === 0) structure.read = createSecondByteReader(firstId, structure.read);\n            return readObject() // second byte is already read, if there is one so immediately read object\n            ;\n        }\n        let object = {};\n        for(let i = 0, l = structure.length; i < l; i++){\n            let key = structure[i];\n            if (key === \"__proto__\") key = \"__proto_\";\n            object[key] = read();\n        }\n        if (currentUnpackr.freezeData) return Object.freeze(object);\n        return object;\n    }\n    readObject.count = 0;\n    if (structure.highByte === 0) {\n        return createSecondByteReader(firstId, readObject);\n    }\n    return readObject;\n}\nconst createSecondByteReader = (firstId, read0)=>{\n    return function() {\n        let highByte = src[position$1++];\n        if (highByte === 0) return read0();\n        let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);\n        let structure = currentStructures[id] || loadStructures()[id];\n        if (!structure) {\n            throw new Error(\"Record id is not defined for \" + id);\n        }\n        if (!structure.read) structure.read = createStructureReader(structure, firstId);\n        return structure.read();\n    };\n};\nfunction loadStructures() {\n    let loadedStructures = saveState$1(()=>{\n        // save the state in case getStructures modifies our buffer\n        src = null;\n        return currentUnpackr.getStructures();\n    });\n    return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);\n}\nvar readFixedString = readStringJS;\nvar readString8 = readStringJS;\nvar readString16 = readStringJS;\nvar readString32 = readStringJS;\nexports.isNativeAccelerationEnabled = false;\nfunction setExtractor(extractStrings) {\n    exports.isNativeAccelerationEnabled = true;\n    readFixedString = readString(1);\n    readString8 = readString(2);\n    readString16 = readString(3);\n    readString32 = readString(5);\n    function readString(headerLength) {\n        return function readString(length) {\n            let string = strings[stringPosition++];\n            if (string == null) {\n                if (bundledStrings$1) return readStringJS(length);\n                let byteOffset = src.byteOffset;\n                let extraction = extractStrings(position$1 - headerLength + byteOffset, srcEnd + byteOffset, src.buffer);\n                if (typeof extraction == \"string\") {\n                    string = extraction;\n                    strings = EMPTY_ARRAY;\n                } else {\n                    strings = extraction;\n                    stringPosition = 1;\n                    srcStringEnd = 1; // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n                    string = strings[0];\n                    if (string === undefined) throw new Error(\"Unexpected end of buffer\");\n                }\n            }\n            let srcStringLength = string.length;\n            if (srcStringLength <= length) {\n                position$1 += length;\n                return string;\n            }\n            srcString = string;\n            srcStringStart = position$1;\n            srcStringEnd = position$1 + srcStringLength;\n            position$1 += length;\n            return string.slice(0, length) // we know we just want the beginning\n            ;\n        };\n    }\n}\nfunction readStringJS(length) {\n    let result;\n    if (length < 16) {\n        if (result = shortStringInJS(length)) return result;\n    }\n    if (length > 64 && decoder) return decoder.decode(src.subarray(position$1, position$1 += length));\n    const end = position$1 + length;\n    const units = [];\n    result = \"\";\n    while(position$1 < end){\n        const byte1 = src[position$1++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        } else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = src[position$1++] & 0x3f;\n            units.push((byte1 & 0x1f) << 6 | byte2);\n        } else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = src[position$1++] & 0x3f;\n            const byte3 = src[position$1++] & 0x3f;\n            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n        } else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = src[position$1++] & 0x3f;\n            const byte3 = src[position$1++] & 0x3f;\n            const byte4 = src[position$1++] & 0x3f;\n            let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(unit >>> 10 & 0x3ff | 0xd800);\n                unit = 0xdc00 | unit & 0x3ff;\n            }\n            units.push(unit);\n        } else {\n            units.push(byte1);\n        }\n        if (units.length >= 0x1000) {\n            result += fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += fromCharCode.apply(String, units);\n    }\n    return result;\n}\nfunction readString(source, start, length) {\n    let existingSrc = src;\n    src = source;\n    position$1 = start;\n    try {\n        return readStringJS(length);\n    } finally{\n        src = existingSrc;\n    }\n}\nfunction readArray(length) {\n    let array = new Array(length);\n    for(let i = 0; i < length; i++){\n        array[i] = read();\n    }\n    if (currentUnpackr.freezeData) return Object.freeze(array);\n    return array;\n}\nfunction readMap(length) {\n    if (currentUnpackr.mapsAsObjects) {\n        let object = {};\n        for(let i = 0; i < length; i++){\n            let key = readKey();\n            if (key === \"__proto__\") key = \"__proto_\";\n            object[key] = read();\n        }\n        return object;\n    } else {\n        let map = new Map();\n        for(let i = 0; i < length; i++){\n            map.set(read(), read());\n        }\n        return map;\n    }\n}\nvar fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n    let start = position$1;\n    let bytes = new Array(length);\n    for(let i = 0; i < length; i++){\n        const byte = src[position$1++];\n        if ((byte & 0x80) > 0) {\n            position$1 = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) return \"\";\n            else {\n                let a = src[position$1++];\n                if ((a & 0x80) > 1) {\n                    position$1 -= 1;\n                    return;\n                }\n                return fromCharCode(a);\n            }\n        } else {\n            let a = src[position$1++];\n            let b = src[position$1++];\n            if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n                position$1 -= 2;\n                return;\n            }\n            if (length < 3) return fromCharCode(a, b);\n            let c = src[position$1++];\n            if ((c & 0x80) > 0) {\n                position$1 -= 3;\n                return;\n            }\n            return fromCharCode(a, b, c);\n        }\n    } else {\n        let a = src[position$1++];\n        let b = src[position$1++];\n        let c = src[position$1++];\n        let d = src[position$1++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n            position$1 -= 4;\n            return;\n        }\n        if (length < 6) {\n            if (length === 4) return fromCharCode(a, b, c, d);\n            else {\n                let e = src[position$1++];\n                if ((e & 0x80) > 0) {\n                    position$1 -= 5;\n                    return;\n                }\n                return fromCharCode(a, b, c, d, e);\n            }\n        } else if (length < 8) {\n            let e = src[position$1++];\n            let f = src[position$1++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n                position$1 -= 6;\n                return;\n            }\n            if (length < 7) return fromCharCode(a, b, c, d, e, f);\n            let g = src[position$1++];\n            if ((g & 0x80) > 0) {\n                position$1 -= 7;\n                return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g);\n        } else {\n            let e = src[position$1++];\n            let f = src[position$1++];\n            let g = src[position$1++];\n            let h = src[position$1++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n                position$1 -= 8;\n                return;\n            }\n            if (length < 10) {\n                if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h);\n                else {\n                    let i = src[position$1++];\n                    if ((i & 0x80) > 0) {\n                        position$1 -= 9;\n                        return;\n                    }\n                    return fromCharCode(a, b, c, d, e, f, g, h, i);\n                }\n            } else if (length < 12) {\n                let i = src[position$1++];\n                let j = src[position$1++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n                    position$1 -= 10;\n                    return;\n                }\n                if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n                let k = src[position$1++];\n                if ((k & 0x80) > 0) {\n                    position$1 -= 11;\n                    return;\n                }\n                return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n            } else {\n                let i = src[position$1++];\n                let j = src[position$1++];\n                let k = src[position$1++];\n                let l = src[position$1++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n                    position$1 -= 12;\n                    return;\n                }\n                if (length < 14) {\n                    if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n                    else {\n                        let m = src[position$1++];\n                        if ((m & 0x80) > 0) {\n                            position$1 -= 13;\n                            return;\n                        }\n                        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n                    }\n                } else {\n                    let m = src[position$1++];\n                    let n = src[position$1++];\n                    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n                        position$1 -= 14;\n                        return;\n                    }\n                    if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n                    let o = src[position$1++];\n                    if ((o & 0x80) > 0) {\n                        position$1 -= 15;\n                        return;\n                    }\n                    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n                }\n            }\n        }\n    }\n}\nfunction readOnlyJSString() {\n    let token = src[position$1++];\n    let length;\n    if (token < 0xc0) {\n        // fixstr\n        length = token - 0xa0;\n    } else {\n        switch(token){\n            case 0xd9:\n                // str 8\n                length = src[position$1++];\n                break;\n            case 0xda:\n                // str 16\n                length = dataView.getUint16(position$1);\n                position$1 += 2;\n                break;\n            case 0xdb:\n                // str 32\n                length = dataView.getUint32(position$1);\n                position$1 += 4;\n                break;\n            default:\n                throw new Error(\"Expected string\");\n        }\n    }\n    return readStringJS(length);\n}\nfunction readBin(length) {\n    return currentUnpackr.copyBuffers ? // specifically use the copying slice (not the node one)\n    Uint8Array.prototype.slice.call(src, position$1, position$1 += length) : src.subarray(position$1, position$1 += length);\n}\nfunction readExt(length) {\n    let type = src[position$1++];\n    if (currentExtensions[type]) {\n        let end;\n        return currentExtensions[type](src.subarray(position$1, end = position$1 += length), (readPosition)=>{\n            position$1 = readPosition;\n            try {\n                return read();\n            } finally{\n                position$1 = end;\n            }\n        });\n    } else throw new Error(\"Unknown extension type \" + type);\n}\nvar keyCache = new Array(4096);\nfunction readKey() {\n    let length = src[position$1++];\n    if (length >= 0xa0 && length < 0xc0) {\n        // fixstr, potentially use key cache\n        length = length - 0xa0;\n        if (srcStringEnd >= position$1) return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);\n        else if (!(srcStringEnd == 0 && srcEnd < 180)) return readFixedString(length);\n    } else {\n        position$1--;\n        return asSafeString(read());\n    }\n    let key = (length << 5 ^ (length > 1 ? dataView.getUint16(position$1) : length > 0 ? src[position$1] : 0)) & 0xfff;\n    let entry = keyCache[key];\n    let checkPosition = position$1;\n    let end = position$1 + length - 3;\n    let chunk;\n    let i = 0;\n    if (entry && entry.bytes == length) {\n        while(checkPosition < end){\n            chunk = dataView.getUint32(checkPosition);\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n            checkPosition += 4;\n        }\n        end += 3;\n        while(checkPosition < end){\n            chunk = src[checkPosition++];\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n        }\n        if (checkPosition === end) {\n            position$1 = checkPosition;\n            return entry.string;\n        }\n        end -= 3;\n        checkPosition = position$1;\n    }\n    entry = [];\n    keyCache[key] = entry;\n    entry.bytes = length;\n    while(checkPosition < end){\n        chunk = dataView.getUint32(checkPosition);\n        entry.push(chunk);\n        checkPosition += 4;\n    }\n    end += 3;\n    while(checkPosition < end){\n        chunk = src[checkPosition++];\n        entry.push(chunk);\n    }\n    // for small blocks, avoiding the overhead of the extract call is helpful\n    let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n    if (string != null) return entry.string = string;\n    return entry.string = readFixedString(length);\n}\nfunction asSafeString(property) {\n    // protect against expensive (DoS) string conversions\n    if (typeof property === \"string\") return property;\n    if (typeof property === \"number\" || typeof property === \"boolean\" || typeof property === \"bigint\") return property.toString();\n    if (property == null) return property + \"\";\n    if (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every((item)=>[\n            \"string\",\n            \"number\",\n            \"boolean\",\n            \"bigint\"\n        ].includes(typeof item))) {\n        return property.flat().toString();\n    }\n    throw new Error(`Invalid property type for record: ${typeof property}`);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte)=>{\n    let structure = read().map(asSafeString); // ensure that all keys are strings and\n    // that the array is mutable\n    let firstByte = id;\n    if (highByte !== undefined) {\n        id = id < 32 ? -((highByte << 5) + id) : (highByte << 5) + id;\n        structure.highByte = highByte;\n    }\n    let existingStructure = currentStructures[id];\n    // If it is a shared structure, we need to restore any changes after reading.\n    // Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n    // to the state prior to an incomplete read in order to properly resume.\n    if (existingStructure && (existingStructure.isShared || sequentialMode)) {\n        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n    }\n    currentStructures[id] = structure;\n    structure.read = createStructureReader(structure, firstByte);\n    return structure.read();\n};\ncurrentExtensions[0] = ()=>{}; // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true;\ncurrentExtensions[0x42] = (data)=>{\n    let headLength = data.byteLength % 8 || 8;\n    let head = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n    for(let i = 1; i < headLength; i++){\n        head <<= BigInt(8);\n        head += BigInt(data[i]);\n    }\n    if (data.byteLength !== headLength) {\n        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        let decode = (start, end)=>{\n            let length = end - start;\n            if (length <= 40) {\n                let out = view.getBigUint64(start);\n                for(let i = start + 8; i < end; i += 8){\n                    out <<= BigInt(64n);\n                    out |= view.getBigUint64(i);\n                }\n                return out;\n            }\n            // if (length === 8) return view.getBigUint64(start)\n            let middle = start + (length >> 4 << 3);\n            let left = decode(start, middle);\n            let right = decode(middle, end);\n            return left << BigInt((end - middle) * 8) | right;\n        };\n        head = head << BigInt((view.byteLength - headLength) * 8) | decode(headLength, view.byteLength);\n    }\n    return head;\n};\nlet errors = {\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError,\n    AggregateError: typeof AggregateError === \"function\" ? AggregateError : null\n};\ncurrentExtensions[0x65] = ()=>{\n    let data = read();\n    if (!errors[data[0]]) {\n        let error = Error(data[1], {\n            cause: data[2]\n        });\n        error.name = data[0];\n        return error;\n    }\n    return errors[data[0]](data[1], {\n        cause: data[2]\n    });\n};\ncurrentExtensions[0x69] = (data)=>{\n    // id extension (for structured clones)\n    if (currentUnpackr.structuredClone === false) throw new Error(\"Structured clone extension is disabled\");\n    let id = dataView.getUint32(position$1 - 4);\n    if (!referenceMap) referenceMap = new Map();\n    let token = src[position$1];\n    let target;\n    // TODO: handle any other types that can cycle and make the code more robust if there are other extensions\n    if (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd) target = [];\n    else if (token >= 0x80 && token < 0x90 || token == 0xde || token == 0xdf) target = new Map();\n    else if ((token >= 0xc7 && token <= 0xc9 || token >= 0xd4 && token <= 0xd8) && src[position$1 + 1] === 0x73) target = new Set();\n    else target = {};\n    let refEntry = {\n        target\n    }; // a placeholder object\n    referenceMap.set(id, refEntry);\n    let targetProperties = read(); // read the next value as the target object to id\n    if (!refEntry.used) {\n        // no cycle, can just use the returned read object\n        return refEntry.target = targetProperties // replace the placeholder with the real one\n        ;\n    } else {\n        // there is a cycle, so we have to assign properties to original target\n        Object.assign(target, targetProperties);\n    }\n    // copy over map/set entries if we're able to\n    if (target instanceof Map) for (let [k, v] of targetProperties.entries())target.set(k, v);\n    if (target instanceof Set) for (let i of Array.from(targetProperties))target.add(i);\n    return target;\n};\ncurrentExtensions[0x70] = (data)=>{\n    // pointer extension (for structured clones)\n    if (currentUnpackr.structuredClone === false) throw new Error(\"Structured clone extension is disabled\");\n    let id = dataView.getUint32(position$1 - 4);\n    let refEntry = referenceMap.get(id);\n    refEntry.used = true;\n    return refEntry.target;\n};\ncurrentExtensions[0x73] = ()=>new Set(read());\nconst typedArrays = [\n    \"Int8\",\n    \"Uint8\",\n    \"Uint8Clamped\",\n    \"Int16\",\n    \"Uint16\",\n    \"Int32\",\n    \"Uint32\",\n    \"Float32\",\n    \"Float64\",\n    \"BigInt64\",\n    \"BigUint64\"\n].map((type)=>type + \"Array\");\nlet glbl = typeof globalThis === \"object\" ? globalThis : window;\ncurrentExtensions[0x74] = (data)=>{\n    let typeCode = data[0];\n    // we always have to slice to get a new ArrayBuffer that is aligned\n    let buffer = Uint8Array.prototype.slice.call(data, 1).buffer;\n    let typedArrayName = typedArrays[typeCode];\n    if (!typedArrayName) {\n        if (typeCode === 16) return buffer;\n        if (typeCode === 17) return new DataView(buffer);\n        throw new Error(\"Could not find typed array for code \" + typeCode);\n    }\n    return new glbl[typedArrayName](buffer);\n};\ncurrentExtensions[0x78] = ()=>{\n    let data = read();\n    return new RegExp(data[0], data[1]);\n};\nconst TEMP_BUNDLE = [];\ncurrentExtensions[0x62] = (data)=>{\n    let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];\n    let dataPosition = position$1;\n    position$1 += dataSize - data.length;\n    bundledStrings$1 = TEMP_BUNDLE;\n    bundledStrings$1 = [\n        readOnlyJSString(),\n        readOnlyJSString()\n    ];\n    bundledStrings$1.position0 = 0;\n    bundledStrings$1.position1 = 0;\n    bundledStrings$1.postBundlePosition = position$1;\n    position$1 = dataPosition;\n    return read();\n};\ncurrentExtensions[0xff] = (data)=>{\n    // 32-bit date extension\n    if (data.length == 4) return new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000);\n    else if (data.length == 8) return new Date(((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 + ((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000);\n    else if (data.length == 12) return new Date(((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 + ((data[4] & 0x80 ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000);\n    else return new Date(\"invalid\");\n};\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\nfunction saveState$1(callback) {\n    if (onSaveState) onSaveState();\n    let savedSrcEnd = srcEnd;\n    let savedPosition = position$1;\n    let savedStringPosition = stringPosition;\n    let savedSrcStringStart = srcStringStart;\n    let savedSrcStringEnd = srcStringEnd;\n    let savedSrcString = srcString;\n    let savedStrings = strings;\n    let savedReferenceMap = referenceMap;\n    let savedBundledStrings = bundledStrings$1;\n    // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n    let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n    let savedStructures = currentStructures;\n    let savedStructuresContents = currentStructures.slice(0, currentStructures.length);\n    let savedPackr = currentUnpackr;\n    let savedSequentialMode = sequentialMode;\n    let value = callback();\n    srcEnd = savedSrcEnd;\n    position$1 = savedPosition;\n    stringPosition = savedStringPosition;\n    srcStringStart = savedSrcStringStart;\n    srcStringEnd = savedSrcStringEnd;\n    srcString = savedSrcString;\n    strings = savedStrings;\n    referenceMap = savedReferenceMap;\n    bundledStrings$1 = savedBundledStrings;\n    src = savedSrc;\n    sequentialMode = savedSequentialMode;\n    currentStructures = savedStructures;\n    currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);\n    currentUnpackr = savedPackr;\n    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n    return value;\n}\nfunction clearSource() {\n    src = null;\n    referenceMap = null;\n    currentStructures = null;\n}\nfunction addExtension$1(extension) {\n    if (extension.unpack) currentExtensions[extension.type] = extension.unpack;\n    else currentExtensions[extension.type] = extension;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor(let i = 0; i < 256; i++){\n    mult10[i] = +(\"1e\" + Math.floor(45.15 - i * 0.30103));\n}\nconst Decoder = Unpackr;\nvar defaultUnpackr = new Unpackr({\n    useRecords: false\n});\nconst unpack = defaultUnpackr.unpack;\nconst unpackMultiple = defaultUnpackr.unpackMultiple;\nconst decode = defaultUnpackr.unpack;\nconst FLOAT32_OPTIONS = {\n    NEVER: 0,\n    ALWAYS: 1,\n    DECIMAL_ROUND: 3,\n    DECIMAL_FIT: 4\n};\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction roundFloat32(float32Number) {\n    f32Array[0] = float32Number;\n    let multiplier = mult10[(u8Array[3] & 0x7f) << 1 | u8Array[2] >> 7];\n    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n}\nfunction setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n    readStruct$1 = updatedReadStruct;\n    onLoadedStructures$1 = loadedStructs;\n    onSaveState = saveState;\n}\nlet textEncoder$1;\ntry {\n    textEncoder$1 = new TextEncoder();\n} catch (error) {}\nlet extensions, extensionClasses;\nconst hasNodeBuffer$1 = typeof Buffer !== \"undefined\";\nconst ByteArrayAllocate = hasNodeBuffer$1 ? function(length) {\n    return Buffer.allocUnsafeSlow(length);\n} : Uint8Array;\nconst ByteArray = hasNodeBuffer$1 ? Buffer : Uint8Array;\nconst MAX_BUFFER_SIZE = hasNodeBuffer$1 ? 0x100000000 : 0x7fd00000;\nlet target, keysTarget;\nlet targetView;\nlet position = 0;\nlet safeEnd;\nlet bundledStrings = null;\nlet writeStructSlots;\nconst MAX_BUNDLE_SIZE = 0x5500; // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/;\nconst RECORD_SYMBOL = Symbol(\"record-id\");\nclass Packr extends Unpackr {\n    constructor(options){\n        super(options);\n        this.offset = 0;\n        let start;\n        let hasSharedUpdate;\n        let structures;\n        let referenceMap;\n        let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n            return target.utf8Write(string, position, target.byteLength - position);\n        } : textEncoder$1 && textEncoder$1.encodeInto ? function(string, position) {\n            return textEncoder$1.encodeInto(string, target.subarray(position)).written;\n        } : false;\n        let packr = this;\n        if (!options) options = {};\n        let isSequential = options && options.sequential;\n        let hasSharedStructures = options.structures || options.saveStructures;\n        let maxSharedStructures = options.maxSharedStructures;\n        if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 32 : 0;\n        if (maxSharedStructures > 8160) throw new Error(\"Maximum maxSharedStructure is 8160\");\n        if (options.structuredClone && options.moreTypes == undefined) {\n            this.moreTypes = true;\n        }\n        let maxOwnStructures = options.maxOwnStructures;\n        if (maxOwnStructures == null) maxOwnStructures = hasSharedStructures ? 32 : 64;\n        if (!this.structures && options.useRecords != false) this.structures = [];\n        // two byte record ids for shared structures\n        let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;\n        let sharedLimitId = maxSharedStructures + 0x40;\n        let maxStructureId = maxSharedStructures + maxOwnStructures + 0x40;\n        if (maxStructureId > 8256) {\n            throw new Error(\"Maximum maxSharedStructure + maxOwnStructure is 8192\");\n        }\n        let recordIdsToRemove = [];\n        let transitionsCount = 0;\n        let serializationsSinceTransitionRebuild = 0;\n        this.pack = this.encode = function(value, encodeOptions) {\n            if (!target) {\n                target = new ByteArrayAllocate(8192);\n                targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));\n                position = 0;\n            }\n            safeEnd = target.length - 10;\n            if (safeEnd - position < 0x800) {\n                // don't start too close to the end,\n                target = new ByteArrayAllocate(target.length);\n                targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));\n                safeEnd = target.length - 10;\n                position = 0;\n            } else position = position + 7 & 0x7ffffff8; // Word align to make any future copying of this buffer faster\n            start = position;\n            if (encodeOptions & RESERVE_START_SPACE) position += encodeOptions & 0xff;\n            referenceMap = packr.structuredClone ? new Map() : null;\n            if (packr.bundleStrings && typeof value !== \"string\") {\n                bundledStrings = [];\n                bundledStrings.size = Infinity; // force a new bundle start on first string\n            } else bundledStrings = null;\n            structures = packr.structures;\n            if (structures) {\n                if (structures.uninitialized) structures = packr._mergeStructures(packr.getStructures());\n                let sharedLength = structures.sharedLength || 0;\n                if (sharedLength > maxSharedStructures) {\n                    //if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n                    throw new Error(\"Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to \" + structures.sharedLength);\n                }\n                if (!structures.transitions) {\n                    // rebuild our structure transitions\n                    structures.transitions = Object.create(null);\n                    for(let i = 0; i < sharedLength; i++){\n                        let keys = structures[i];\n                        if (!keys) continue;\n                        let nextTransition, transition = structures.transitions;\n                        for(let j = 0, l = keys.length; j < l; j++){\n                            let key = keys[j];\n                            nextTransition = transition[key];\n                            if (!nextTransition) {\n                                nextTransition = transition[key] = Object.create(null);\n                            }\n                            transition = nextTransition;\n                        }\n                        transition[RECORD_SYMBOL] = i + 0x40;\n                    }\n                    this.lastNamedStructuresLength = sharedLength;\n                }\n                if (!isSequential) {\n                    structures.nextId = sharedLength + 0x40;\n                }\n            }\n            if (hasSharedUpdate) hasSharedUpdate = false;\n            let encodingError;\n            try {\n                if (packr.randomAccessStructure && value && value.constructor && value.constructor === Object) writeStruct(value);\n                else pack(value);\n                let lastBundle = bundledStrings;\n                if (bundledStrings) writeBundles(start, pack, 0);\n                if (referenceMap && referenceMap.idsToInsert) {\n                    let idsToInsert = referenceMap.idsToInsert.sort((a, b)=>a.offset > b.offset ? 1 : -1);\n                    let i = idsToInsert.length;\n                    let incrementPosition = -1;\n                    while(lastBundle && i > 0){\n                        let insertionPoint = idsToInsert[--i].offset + start;\n                        if (insertionPoint < lastBundle.stringsPosition + start && incrementPosition === -1) incrementPosition = 0;\n                        if (insertionPoint > lastBundle.position + start) {\n                            if (incrementPosition >= 0) incrementPosition += 6;\n                        } else {\n                            if (incrementPosition >= 0) {\n                                // update the bundle reference now\n                                targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);\n                                incrementPosition = -1; // reset\n                            }\n                            lastBundle = lastBundle.previous;\n                            i++;\n                        }\n                    }\n                    if (incrementPosition >= 0 && lastBundle) {\n                        // update the bundle reference now\n                        targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);\n                    }\n                    position += idsToInsert.length * 6;\n                    if (position > safeEnd) makeRoom(position);\n                    packr.offset = position;\n                    let serialized = insertIds(target.subarray(start, position), idsToInsert);\n                    referenceMap = null;\n                    return serialized;\n                }\n                packr.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n                if (encodeOptions & REUSE_BUFFER_MODE) {\n                    target.start = start;\n                    target.end = position;\n                    return target;\n                }\n                return target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n                ;\n            } catch (error) {\n                encodingError = error;\n                throw error;\n            } finally{\n                if (structures) {\n                    resetStructures();\n                    if (hasSharedUpdate && packr.saveStructures) {\n                        let sharedLength = structures.sharedLength || 0;\n                        // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n                        let returnBuffer = target.subarray(start, position);\n                        let newSharedData = prepareStructures$1(structures, packr);\n                        if (!encodingError) {\n                            if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n                                // get updated structures and try again if the update failed\n                                return packr.pack(value, encodeOptions);\n                            }\n                            packr.lastNamedStructuresLength = sharedLength;\n                            // don't keep large buffers around\n                            if (target.length > 0x40000000) target = null;\n                            return returnBuffer;\n                        }\n                    }\n                }\n                // don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n                if (target.length > 0x40000000) target = null;\n                if (encodeOptions & RESET_BUFFER_MODE) position = start;\n            }\n        };\n        const resetStructures = ()=>{\n            if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;\n            let sharedLength = structures.sharedLength || 0;\n            if (structures.length > sharedLength && !isSequential) structures.length = sharedLength;\n            if (transitionsCount > 10000) {\n                // force a rebuild occasionally after a lot of transitions so it can get cleaned up\n                structures.transitions = null;\n                serializationsSinceTransitionRebuild = 0;\n                transitionsCount = 0;\n                if (recordIdsToRemove.length > 0) recordIdsToRemove = [];\n            } else if (recordIdsToRemove.length > 0 && !isSequential) {\n                for(let i = 0, l = recordIdsToRemove.length; i < l; i++){\n                    recordIdsToRemove[i][RECORD_SYMBOL] = 0;\n                }\n                recordIdsToRemove = [];\n            }\n        };\n        const packArray = (value)=>{\n            var length = value.length;\n            if (length < 0x10) {\n                target[position++] = 0x90 | length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xdc;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xdd;\n                targetView.setUint32(position, length);\n                position += 4;\n            }\n            for(let i = 0; i < length; i++){\n                pack(value[i]);\n            }\n        };\n        const pack = (value)=>{\n            if (position > safeEnd) target = makeRoom(position);\n            var type = typeof value;\n            var length;\n            if (type === \"string\") {\n                let strLength = value.length;\n                if (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n                    if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n                        let extStart;\n                        let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;\n                        if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n                        let lastBundle;\n                        if (bundledStrings.position) {\n                            lastBundle = bundledStrings;\n                            target[position] = 0xc8; // ext 16\n                            position += 3; // reserve for the writing bundle size\n                            target[position++] = 0x62; // 'b'\n                            extStart = position - start;\n                            position += 4; // reserve for writing bundle reference\n                            writeBundles(start, pack, 0); // write the last bundles\n                            targetView.setUint16(extStart + start - 3, position - start - extStart);\n                        } else {\n                            target[position++] = 0xd6; // fixext 4\n                            target[position++] = 0x62; // 'b'\n                            extStart = position - start;\n                            position += 4; // reserve for writing bundle reference\n                        }\n                        bundledStrings = [\n                            \"\",\n                            \"\"\n                        ]; // create new ones\n                        bundledStrings.previous = lastBundle;\n                        bundledStrings.size = 0;\n                        bundledStrings.position = extStart;\n                    }\n                    let twoByte = hasNonLatin.test(value);\n                    bundledStrings[twoByte ? 0 : 1] += value;\n                    target[position++] = 0xc1;\n                    pack(twoByte ? -strLength : strLength);\n                    return;\n                }\n                let headerSize;\n                // first we estimate the header size, so we can write to the correct location\n                if (strLength < 0x20) {\n                    headerSize = 1;\n                } else if (strLength < 0x100) {\n                    headerSize = 2;\n                } else if (strLength < 0x10000) {\n                    headerSize = 3;\n                } else {\n                    headerSize = 5;\n                }\n                let maxBytes = strLength * 3;\n                if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n                if (strLength < 0x40 || !encodeUtf8) {\n                    let i, c1, c2, strPosition = position + headerSize;\n                    for(i = 0; i < strLength; i++){\n                        c1 = value.charCodeAt(i);\n                        if (c1 < 0x80) {\n                            target[strPosition++] = c1;\n                        } else if (c1 < 0x800) {\n                            target[strPosition++] = c1 >> 6 | 0xc0;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n                            i++;\n                            target[strPosition++] = c1 >> 18 | 0xf0;\n                            target[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else {\n                            target[strPosition++] = c1 >> 12 | 0xe0;\n                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        }\n                    }\n                    length = strPosition - position - headerSize;\n                } else {\n                    length = encodeUtf8(value, position + headerSize);\n                }\n                if (length < 0x20) {\n                    target[position++] = 0xa0 | length;\n                } else if (length < 0x100) {\n                    if (headerSize < 2) {\n                        target.copyWithin(position + 2, position + 1, position + 1 + length);\n                    }\n                    target[position++] = 0xd9;\n                    target[position++] = length;\n                } else if (length < 0x10000) {\n                    if (headerSize < 3) {\n                        target.copyWithin(position + 3, position + 2, position + 2 + length);\n                    }\n                    target[position++] = 0xda;\n                    target[position++] = length >> 8;\n                    target[position++] = length & 0xff;\n                } else {\n                    if (headerSize < 5) {\n                        target.copyWithin(position + 5, position + 3, position + 3 + length);\n                    }\n                    target[position++] = 0xdb;\n                    targetView.setUint32(position, length);\n                    position += 4;\n                }\n                position += length;\n            } else if (type === \"number\") {\n                if (value >>> 0 === value) {\n                    // positive uint\n                    if (value < 0x20 || value < 0x80 && this.useRecords === false || value < 0x40 && !this.randomAccessStructure) {\n                        target[position++] = value;\n                    } else if (value < 0x100) {\n                        target[position++] = 0xcc;\n                        target[position++] = value;\n                    } else if (value < 0x10000) {\n                        target[position++] = 0xcd;\n                        target[position++] = value >> 8;\n                        target[position++] = value & 0xff;\n                    } else {\n                        target[position++] = 0xce;\n                        targetView.setUint32(position, value);\n                        position += 4;\n                    }\n                } else if (value >> 0 === value) {\n                    if (value >= -0x20) {\n                        target[position++] = 0x100 + value;\n                    } else if (value >= -0x80) {\n                        target[position++] = 0xd0;\n                        target[position++] = value + 0x100;\n                    } else if (value >= -0x8000) {\n                        target[position++] = 0xd1;\n                        targetView.setInt16(position, value);\n                        position += 2;\n                    } else {\n                        target[position++] = 0xd2;\n                        targetView.setInt32(position, value);\n                        position += 4;\n                    }\n                } else {\n                    let useFloat32;\n                    if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n                        target[position++] = 0xca;\n                        targetView.setFloat32(position, value);\n                        let xShifted;\n                        if (useFloat32 < 4 || (xShifted = value * mult10[(target[position] & 0x7f) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {\n                            position += 4;\n                            return;\n                        } else position--; // move back into position for writing a double\n                    }\n                    target[position++] = 0xcb;\n                    targetView.setFloat64(position, value);\n                    position += 8;\n                }\n            } else if (type === \"object\" || type === \"function\") {\n                if (!value) target[position++] = 0xc0;\n                else {\n                    if (referenceMap) {\n                        let referee = referenceMap.get(value);\n                        if (referee) {\n                            if (!referee.id) {\n                                let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n                                referee.id = idsToInsert.push(referee);\n                            }\n                            target[position++] = 0xd6; // fixext 4\n                            target[position++] = 0x70; // \"p\" for pointer\n                            targetView.setUint32(position, referee.id);\n                            position += 4;\n                            return;\n                        } else referenceMap.set(value, {\n                            offset: position - start\n                        });\n                    }\n                    let constructor = value.constructor;\n                    if (constructor === Object) {\n                        writeObject(value);\n                    } else if (constructor === Array) {\n                        packArray(value);\n                    } else if (constructor === Map) {\n                        if (this.mapAsEmptyObject) target[position++] = 0x80;\n                        else {\n                            length = value.size;\n                            if (length < 0x10) {\n                                target[position++] = 0x80 | length;\n                            } else if (length < 0x10000) {\n                                target[position++] = 0xde;\n                                target[position++] = length >> 8;\n                                target[position++] = length & 0xff;\n                            } else {\n                                target[position++] = 0xdf;\n                                targetView.setUint32(position, length);\n                                position += 4;\n                            }\n                            for (let [key, entryValue] of value){\n                                pack(key);\n                                pack(entryValue);\n                            }\n                        }\n                    } else {\n                        for(let i = 0, l = extensions.length; i < l; i++){\n                            let extensionClass = extensionClasses[i];\n                            if (value instanceof extensionClass) {\n                                let extension = extensions[i];\n                                if (extension.write) {\n                                    if (extension.type) {\n                                        target[position++] = 0xd4; // one byte \"tag\" extension\n                                        target[position++] = extension.type;\n                                        target[position++] = 0;\n                                    }\n                                    let writeResult = extension.write.call(this, value);\n                                    if (writeResult === value) {\n                                        if (Array.isArray(value)) {\n                                            packArray(value);\n                                        } else {\n                                            writeObject(value);\n                                        }\n                                    } else {\n                                        pack(writeResult);\n                                    }\n                                    return;\n                                }\n                                let currentTarget = target;\n                                let currentTargetView = targetView;\n                                let currentPosition = position;\n                                target = null;\n                                let result;\n                                try {\n                                    result = extension.pack.call(this, value, (size)=>{\n                                        // restore target and use it\n                                        target = currentTarget;\n                                        currentTarget = null;\n                                        position += size;\n                                        if (position > safeEnd) makeRoom(position);\n                                        return {\n                                            target,\n                                            targetView,\n                                            position: position - size\n                                        };\n                                    }, pack);\n                                } finally{\n                                    // restore current target information (unless already restored)\n                                    if (currentTarget) {\n                                        target = currentTarget;\n                                        targetView = currentTargetView;\n                                        position = currentPosition;\n                                        safeEnd = target.length - 10;\n                                    }\n                                }\n                                if (result) {\n                                    if (result.length + position > safeEnd) makeRoom(result.length + position);\n                                    position = writeExtensionData(result, target, position, extension.type);\n                                }\n                                return;\n                            }\n                        }\n                        // check isArray after extensions, because extensions can extend Array\n                        if (Array.isArray(value)) {\n                            packArray(value);\n                        } else {\n                            // use this as an alternate mechanism for expressing how to serialize\n                            if (value.toJSON) {\n                                const json = value.toJSON();\n                                // if for some reason value.toJSON returns itself it'll loop forever\n                                if (json !== value) return pack(json);\n                            }\n                            // if there is a writeFunction, use it, otherwise just encode as undefined\n                            if (type === \"function\") return pack(this.writeFunction && this.writeFunction(value));\n                            // no extension found, write as plain object\n                            writeObject(value);\n                        }\n                    }\n                }\n            } else if (type === \"boolean\") {\n                target[position++] = value ? 0xc3 : 0xc2;\n            } else if (type === \"bigint\") {\n                if (value < 0x8000000000000000 && value >= -0x8000000000000000) {\n                    // use a signed int as long as it fits\n                    target[position++] = 0xd3;\n                    targetView.setBigInt64(position, value);\n                } else if (value < 0x10000000000000000 && value > 0) {\n                    // if we can fit an unsigned int, use that\n                    target[position++] = 0xcf;\n                    targetView.setBigUint64(position, value);\n                } else {\n                    // overflow\n                    if (this.largeBigIntToFloat) {\n                        target[position++] = 0xcb;\n                        targetView.setFloat64(position, Number(value));\n                    } else if (this.largeBigIntToString) {\n                        return pack(value.toString());\n                    } else if (this.useBigIntExtension || this.moreTypes) {\n                        let empty = value < 0 ? BigInt(-1) : BigInt(0);\n                        let array;\n                        if (value >> BigInt(0x10000) === empty) {\n                            let mask = BigInt(0x10000000000000000) - BigInt(1); // literal would overflow\n                            let chunks = [];\n                            while(true){\n                                chunks.push(value & mask);\n                                if (value >> BigInt(63) === empty) break;\n                                value >>= BigInt(64);\n                            }\n                            array = new Uint8Array(new BigUint64Array(chunks).buffer);\n                            array.reverse();\n                        } else {\n                            let invert = value < 0;\n                            let string = (invert ? ~value : value).toString(16);\n                            if (string.length % 2) {\n                                string = \"0\" + string;\n                            } else if (parseInt(string.charAt(0), 16) >= 8) {\n                                string = \"00\" + string;\n                            }\n                            if (hasNodeBuffer$1) {\n                                array = Buffer.from(string, \"hex\");\n                            } else {\n                                array = new Uint8Array(string.length / 2);\n                                for(let i = 0; i < array.length; i++){\n                                    array[i] = parseInt(string.slice(i * 2, i * 2 + 2), 16);\n                                }\n                            }\n                            if (invert) {\n                                for(let i = 0; i < array.length; i++)array[i] = ~array[i];\n                            }\n                        }\n                        if (array.length + position > safeEnd) makeRoom(array.length + position);\n                        position = writeExtensionData(array, target, position, 0x42);\n                        return;\n                    } else {\n                        throw new RangeError(value + \" was too large to fit in MessagePack 64-bit integer format, use\" + \" useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set\" + \" largeBigIntToString to convert to string\");\n                    }\n                }\n                position += 8;\n            } else if (type === \"undefined\") {\n                if (this.encodeUndefinedAsNil) target[position++] = 0xc0;\n                else {\n                    target[position++] = 0xd4; // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n                    target[position++] = 0;\n                    target[position++] = 0;\n                }\n            } else {\n                throw new Error(\"Unknown type: \" + type);\n            }\n        };\n        const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object)=>{\n            // this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n            let keys;\n            if (this.skipValues) {\n                keys = [];\n                for(let key in object){\n                    if ((typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) && !this.skipValues.includes(object[key])) keys.push(key);\n                }\n            } else {\n                keys = Object.keys(object);\n            }\n            let length = keys.length;\n            if (length < 0x10) {\n                target[position++] = 0x80 | length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xde;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xdf;\n                targetView.setUint32(position, length);\n                position += 4;\n            }\n            let key;\n            if (this.coercibleKeyAsNumber) {\n                for(let i = 0; i < length; i++){\n                    key = keys[i];\n                    let num = Number(key);\n                    pack(isNaN(num) ? key : num);\n                    pack(object[key]);\n                }\n            } else {\n                for(let i = 0; i < length; i++){\n                    pack(key = keys[i]);\n                    pack(object[key]);\n                }\n            }\n        } : (object)=>{\n            target[position++] = 0xde; // always using map 16, so we can preallocate and set the length afterwards\n            let objectOffset = position - start;\n            position += 2;\n            let size = 0;\n            for(let key in object){\n                if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                    pack(key);\n                    pack(object[key]);\n                    size++;\n                }\n            }\n            if (size > 0xffff) {\n                throw new Error(\"Object is too large to serialize with fast 16-bit map size,\" + ' use the \"variableMapSize\" option to serialize this object');\n            }\n            target[objectOffset++ + start] = size >> 8;\n            target[objectOffset + start] = size & 0xff;\n        };\n        const writeRecord = this.useRecords === false ? writePlainObject : options.progressiveRecords && !useTwoByteRecords ? (object)=>{\n            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n            let objectOffset = position++ - start;\n            let wroteKeys;\n            for(let key in object){\n                if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                    nextTransition = transition[key];\n                    if (nextTransition) transition = nextTransition;\n                    else {\n                        // record doesn't exist, create full new record and insert it\n                        let keys = Object.keys(object);\n                        let lastTransition = transition;\n                        transition = structures.transitions;\n                        let newTransitions = 0;\n                        for(let i = 0, l = keys.length; i < l; i++){\n                            let key = keys[i];\n                            nextTransition = transition[key];\n                            if (!nextTransition) {\n                                nextTransition = transition[key] = Object.create(null);\n                                newTransitions++;\n                            }\n                            transition = nextTransition;\n                        }\n                        if (objectOffset + start + 1 == position) {\n                            // first key, so we don't need to insert, we can just write record directly\n                            position--;\n                            newRecord(transition, keys, newTransitions);\n                        } else insertNewRecord(transition, keys, objectOffset, newTransitions);\n                        wroteKeys = true;\n                        transition = lastTransition[key];\n                    }\n                    pack(object[key]);\n                }\n            }\n            if (!wroteKeys) {\n                let recordId = transition[RECORD_SYMBOL];\n                if (recordId) target[objectOffset + start] = recordId;\n                else insertNewRecord(transition, Object.keys(object), objectOffset, 0);\n            }\n        } : (object)=>{\n            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n            let newTransitions = 0;\n            for(let key in object)if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                nextTransition = transition[key];\n                if (!nextTransition) {\n                    nextTransition = transition[key] = Object.create(null);\n                    newTransitions++;\n                }\n                transition = nextTransition;\n            }\n            let recordId = transition[RECORD_SYMBOL];\n            if (recordId) {\n                if (recordId >= 0x60 && useTwoByteRecords) {\n                    target[position++] = ((recordId -= 0x60) & 0x1f) + 0x60;\n                    target[position++] = recordId >> 5;\n                } else target[position++] = recordId;\n            } else {\n                newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);\n            }\n            // now write the values\n            for(let key in object)if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                pack(object[key]);\n            }\n        };\n        // create reference to useRecords if useRecords is a function\n        const checkUseRecords = typeof this.useRecords == \"function\" && this.useRecords;\n        const writeObject = checkUseRecords ? (object)=>{\n            checkUseRecords(object) ? writeRecord(object) : writePlainObject(object);\n        } : writeRecord;\n        const makeRoom = (end)=>{\n            let newSize;\n            if (end > 0x1000000) {\n                // special handling for really large buffers\n                if (end - start > MAX_BUFFER_SIZE) throw new Error(\"Packed buffer would be larger than maximum buffer size\");\n                newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n            } else newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;\n            let newBuffer = new ByteArrayAllocate(newSize);\n            targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));\n            end = Math.min(end, target.length);\n            if (target.copy) target.copy(newBuffer, 0, start, end);\n            else newBuffer.set(target.slice(start, end));\n            position -= start;\n            start = 0;\n            safeEnd = newBuffer.length - 10;\n            return target = newBuffer;\n        };\n        const newRecord = (transition, keys, newTransitions)=>{\n            let recordId = structures.nextId;\n            if (!recordId) recordId = 0x40;\n            if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n                recordId = structures.nextOwnId;\n                if (!(recordId < maxStructureId)) recordId = sharedLimitId;\n                structures.nextOwnId = recordId + 1;\n            } else {\n                if (recordId >= maxStructureId) recordId = sharedLimitId;\n                structures.nextId = recordId + 1;\n            }\n            let highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? recordId - 0x60 >> 5 : -1;\n            transition[RECORD_SYMBOL] = recordId;\n            transition.__keys__ = keys;\n            structures[recordId - 0x40] = keys;\n            if (recordId < sharedLimitId) {\n                keys.isShared = true;\n                structures.sharedLength = recordId - 0x3f;\n                hasSharedUpdate = true;\n                if (highByte >= 0) {\n                    target[position++] = (recordId & 0x1f) + 0x60;\n                    target[position++] = highByte;\n                } else {\n                    target[position++] = recordId;\n                }\n            } else {\n                if (highByte >= 0) {\n                    target[position++] = 0xd5; // fixext 2\n                    target[position++] = 0x72; // \"r\" record defintion extension type\n                    target[position++] = (recordId & 0x1f) + 0x60;\n                    target[position++] = highByte;\n                } else {\n                    target[position++] = 0xd4; // fixext 1\n                    target[position++] = 0x72; // \"r\" record defintion extension type\n                    target[position++] = recordId;\n                }\n                if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n                // record the removal of the id, we can maintain our shared structure\n                if (recordIdsToRemove.length >= maxOwnStructures) recordIdsToRemove.shift()[RECORD_SYMBOL] = 0; // we are cycling back through, and have to remove old ones\n                recordIdsToRemove.push(transition);\n                pack(keys);\n            }\n        };\n        const insertNewRecord = (transition, keys, insertionOffset, newTransitions)=>{\n            let mainTarget = target;\n            let mainPosition = position;\n            let mainSafeEnd = safeEnd;\n            let mainStart = start;\n            target = keysTarget;\n            position = 0;\n            start = 0;\n            if (!target) keysTarget = target = new ByteArrayAllocate(8192);\n            safeEnd = target.length - 10;\n            newRecord(transition, keys, newTransitions);\n            keysTarget = target;\n            let keysPosition = position;\n            target = mainTarget;\n            position = mainPosition;\n            safeEnd = mainSafeEnd;\n            start = mainStart;\n            if (keysPosition > 1) {\n                let newEnd = position + keysPosition - 1;\n                if (newEnd > safeEnd) makeRoom(newEnd);\n                let insertionPosition = insertionOffset + start;\n                target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);\n                target.set(keysTarget.slice(0, keysPosition), insertionPosition);\n                position = newEnd;\n            } else {\n                target[insertionOffset + start] = keysTarget[0];\n            }\n        };\n        const writeStruct = (object)=>{\n            let newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate)=>{\n                if (notifySharedUpdate) return hasSharedUpdate = true;\n                position = newPosition;\n                let startTarget = target;\n                pack(value);\n                resetStructures();\n                if (startTarget !== target) {\n                    return {\n                        position,\n                        targetView,\n                        target\n                    }; // indicate the buffer was re-allocated\n                }\n                return position;\n            }, this);\n            if (newPosition === 0) return writeObject(object);\n            position = newPosition;\n        };\n    }\n    useBuffer(buffer) {\n        // this means we are finished using our own buffer and we can write over it safely\n        target = buffer;\n        target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));\n        targetView = target.dataView;\n        position = 0;\n    }\n    set position(value) {\n        position = value;\n    }\n    get position() {\n        return position;\n    }\n    clearSharedData() {\n        if (this.structures) this.structures = [];\n        if (this.typedStructs) this.typedStructs = [];\n    }\n}\nextensionClasses = [\n    Date,\n    Set,\n    Error,\n    RegExp,\n    ArrayBuffer,\n    Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/ ,\n    DataView,\n    C1Type\n];\nextensions = [\n    {\n        pack (date, allocateForWrite, pack) {\n            let seconds = date.getTime() / 1000;\n            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n                // Timestamp 32\n                let { target, targetView, position } = allocateForWrite(6);\n                target[position++] = 0xd6;\n                target[position++] = 0xff;\n                targetView.setUint32(position, seconds);\n            } else if (seconds > 0 && seconds < 0x100000000) {\n                // Timestamp 64\n                let { target, targetView, position } = allocateForWrite(10);\n                target[position++] = 0xd7;\n                target[position++] = 0xff;\n                targetView.setUint32(position, date.getMilliseconds() * 4000000 + (seconds / 1000 / 0x100000000 >> 0));\n                targetView.setUint32(position + 4, seconds);\n            } else if (isNaN(seconds)) {\n                if (this.onInvalidDate) {\n                    allocateForWrite(0);\n                    return pack(this.onInvalidDate());\n                }\n                // Intentionally invalid timestamp\n                let { target, targetView, position } = allocateForWrite(3);\n                target[position++] = 0xd4;\n                target[position++] = 0xff;\n                target[position++] = 0xff;\n            } else {\n                // Timestamp 96\n                let { target, targetView, position } = allocateForWrite(15);\n                target[position++] = 0xc7;\n                target[position++] = 12;\n                target[position++] = 0xff;\n                targetView.setUint32(position, date.getMilliseconds() * 1000000);\n                targetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)));\n            }\n        }\n    },\n    {\n        pack (set, allocateForWrite, pack) {\n            if (this.setAsEmptyObject) {\n                allocateForWrite(0);\n                return pack({});\n            }\n            let array = Array.from(set);\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x73; // 's' for Set\n                target[position++] = 0;\n            }\n            pack(array);\n        }\n    },\n    {\n        pack (error, allocateForWrite, pack) {\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x65; // 'e' for error\n                target[position++] = 0;\n            }\n            pack([\n                error.name,\n                error.message,\n                error.cause\n            ]);\n        }\n    },\n    {\n        pack (regex, allocateForWrite, pack) {\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x78; // 'x' for regeXp\n                target[position++] = 0;\n            }\n            pack([\n                regex.source,\n                regex.flags\n            ]);\n        }\n    },\n    {\n        pack (arrayBuffer, allocateForWrite) {\n            if (this.moreTypes) writeExtBuffer(arrayBuffer, 0x10, allocateForWrite);\n            else writeBuffer(hasNodeBuffer$1 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);\n        }\n    },\n    {\n        pack (typedArray, allocateForWrite) {\n            let constructor = typedArray.constructor;\n            if (constructor !== ByteArray && this.moreTypes) writeExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);\n            else writeBuffer(typedArray, allocateForWrite);\n        }\n    },\n    {\n        pack (arrayBuffer, allocateForWrite) {\n            if (this.moreTypes) writeExtBuffer(arrayBuffer, 0x11, allocateForWrite);\n            else writeBuffer(hasNodeBuffer$1 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);\n        }\n    },\n    {\n        pack (c1, allocateForWrite) {\n            let { target, position } = allocateForWrite(1);\n            target[position] = 0xc1;\n        }\n    }\n];\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n    let length = typedArray.byteLength;\n    if (length + 1 < 0x100) {\n        var { target, position } = allocateForWrite(4 + length);\n        target[position++] = 0xc7;\n        target[position++] = length + 1;\n    } else if (length + 1 < 0x10000) {\n        var { target, position } = allocateForWrite(5 + length);\n        target[position++] = 0xc8;\n        target[position++] = length + 1 >> 8;\n        target[position++] = length + 1 & 0xff;\n    } else {\n        var { target, position, targetView } = allocateForWrite(7 + length);\n        target[position++] = 0xc9;\n        targetView.setUint32(position, length + 1); // plus one for the type byte\n        position += 4;\n    }\n    target[position++] = 0x74; // \"t\" for typed array\n    target[position++] = type;\n    if (!typedArray.buffer) typedArray = new Uint8Array(typedArray);\n    target.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position);\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n    let length = buffer.byteLength;\n    var target, position;\n    if (length < 0x100) {\n        var { target, position } = allocateForWrite(length + 2);\n        target[position++] = 0xc4;\n        target[position++] = length;\n    } else if (length < 0x10000) {\n        var { target, position } = allocateForWrite(length + 3);\n        target[position++] = 0xc5;\n        target[position++] = length >> 8;\n        target[position++] = length & 0xff;\n    } else {\n        var { target, position, targetView } = allocateForWrite(length + 5);\n        target[position++] = 0xc6;\n        targetView.setUint32(position, length);\n        position += 4;\n    }\n    target.set(buffer, position);\n}\nfunction writeExtensionData(result, target, position, type) {\n    let length = result.length;\n    switch(length){\n        case 1:\n            target[position++] = 0xd4;\n            break;\n        case 2:\n            target[position++] = 0xd5;\n            break;\n        case 4:\n            target[position++] = 0xd6;\n            break;\n        case 8:\n            target[position++] = 0xd7;\n            break;\n        case 16:\n            target[position++] = 0xd8;\n            break;\n        default:\n            if (length < 0x100) {\n                target[position++] = 0xc7;\n                target[position++] = length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xc8;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xc9;\n                target[position++] = length >> 24;\n                target[position++] = length >> 16 & 0xff;\n                target[position++] = length >> 8 & 0xff;\n                target[position++] = length & 0xff;\n            }\n    }\n    target[position++] = type;\n    target.set(result, position);\n    position += length;\n    return position;\n}\nfunction insertIds(serialized, idsToInsert) {\n    // insert the ids that need to be referenced for structured clones\n    let nextId;\n    let distanceToMove = idsToInsert.length * 6;\n    let lastEnd = serialized.length - distanceToMove;\n    while(nextId = idsToInsert.pop()){\n        let offset = nextId.offset;\n        let id = nextId.id;\n        serialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n        distanceToMove -= 6;\n        let position = offset + distanceToMove;\n        serialized[position++] = 0xd6;\n        serialized[position++] = 0x69; // 'i'\n        serialized[position++] = id >> 24;\n        serialized[position++] = id >> 16 & 0xff;\n        serialized[position++] = id >> 8 & 0xff;\n        serialized[position++] = id & 0xff;\n        lastEnd = offset;\n    }\n    return serialized;\n}\nfunction writeBundles(start, pack, incrementPosition) {\n    if (bundledStrings.length > 0) {\n        targetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);\n        bundledStrings.stringsPosition = position - start;\n        let writeStrings = bundledStrings;\n        bundledStrings = null;\n        pack(writeStrings[0]);\n        pack(writeStrings[1]);\n    }\n}\nfunction addExtension(extension) {\n    if (extension.Class) {\n        if (!extension.pack && !extension.write) throw new Error(\"Extension has no pack or write function\");\n        if (extension.pack && !extension.type) throw new Error(\"Extension has no type (numeric code to identify the extension)\");\n        extensionClasses.unshift(extension.Class);\n        extensions.unshift(extension);\n    }\n    addExtension$1(extension);\n}\nfunction prepareStructures$1(structures, packr) {\n    structures.isCompatible = (existingStructures)=>{\n        let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;\n        if (!compatible) packr._mergeStructures(existingStructures);\n        return compatible;\n    };\n    return structures;\n}\nfunction setWriteStructSlots(writeSlots, makeStructures) {\n    writeStructSlots = writeSlots;\n    prepareStructures$1 = makeStructures;\n}\nlet defaultPackr = new Packr({\n    useRecords: false\n});\nconst pack = defaultPackr.pack;\nconst encode = defaultPackr.pack;\nconst Encoder = Packr;\nconst { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;\nconst REUSE_BUFFER_MODE = 512;\nconst RESET_BUFFER_MODE = 1024;\nconst RESERVE_START_SPACE = 2048;\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = [\n    \"num\",\n    \"object\",\n    \"string\",\n    \"ascii\"\n];\nTYPE_NAMES[DATE] = \"date\";\nconst float32Headers = [\n    false,\n    true,\n    true,\n    false,\n    false,\n    true,\n    true,\n    false\n];\nlet evalSupported;\ntry {\n    new Function(\"\");\n    evalSupported = true;\n} catch (error) {\n// if eval variants are not supported, do not create inline object readers ever\n}\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== \"undefined\";\nlet textEncoder, currentSource;\ntry {\n    textEncoder = new TextEncoder();\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n    return target.utf8Write(string, position, target.byteLength - position);\n} : textEncoder && textEncoder.encodeInto ? function(target, string, position) {\n    return textEncoder.encodeInto(string, target.subarray(position)).written;\n} : false;\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n    let typedStructs = packr.typedStructs || (packr.typedStructs = []);\n    // note that we rely on pack.js to load stored structures before we get to this point\n    let targetView = target.dataView;\n    let refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n    let safeEnd = target.length - 10;\n    let start = position;\n    if (position > safeEnd) {\n        target = makeRoom(position);\n        targetView = target.dataView;\n        position -= encodingStart;\n        start -= encodingStart;\n        refsStartPosition -= encodingStart;\n        encodingStart = 0;\n        safeEnd = target.length - 10;\n    }\n    let refOffset, refPosition = refsStartPosition;\n    let transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n    let nextId = typedStructs.nextId || typedStructs.length;\n    let headerSize = nextId < 0xf ? 1 : nextId < 0xf0 ? 2 : nextId < 0xf000 ? 3 : nextId < 0xf00000 ? 4 : 0;\n    if (headerSize === 0) return 0;\n    position += headerSize;\n    let queuedReferences = [];\n    let usedAscii0;\n    let keyIndex = 0;\n    for(let key in object){\n        let value = object[key];\n        let nextTransition = transition[key];\n        if (!nextTransition) {\n            transition[key] = nextTransition = {\n                key,\n                parent: transition,\n                enumerationOffset: 0,\n                ascii0: null,\n                ascii8: null,\n                num8: null,\n                string16: null,\n                object16: null,\n                num32: null,\n                float64: null,\n                date64: null\n            };\n        }\n        if (position > safeEnd) {\n            target = makeRoom(position);\n            targetView = target.dataView;\n            position -= encodingStart;\n            start -= encodingStart;\n            refsStartPosition -= encodingStart;\n            refPosition -= encodingStart;\n            encodingStart = 0;\n            safeEnd = target.length - 10;\n        }\n        switch(typeof value){\n            case \"number\":\n                let number = value;\n                // first check to see if we are using a lot of ids and should default to wide/common format\n                if (nextId < 200 || !nextTransition.num64) {\n                    if (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n                        if (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n                            transition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n                            target[position++] = number;\n                        } else {\n                            transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n                            targetView.setUint32(position, number, true);\n                            position += 4;\n                        }\n                        break;\n                    } else if (number < 0x100000000 && number >= -0x80000000) {\n                        targetView.setFloat32(position, number, true);\n                        if (float32Headers[target[position + 3] >>> 5]) {\n                            let xShifted;\n                            // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                            if ((xShifted = number * mult10[(target[position + 3] & 0x7f) << 1 | target[position + 2] >> 7]) >> 0 === xShifted) {\n                                transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n                                position += 4;\n                                break;\n                            }\n                        }\n                    }\n                }\n                transition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n                targetView.setFloat64(position, number, true);\n                position += 8;\n                break;\n            case \"string\":\n                let strLength = value.length;\n                refOffset = refPosition - refsStartPosition;\n                if ((strLength << 2) + refPosition > safeEnd) {\n                    target = makeRoom((strLength << 2) + refPosition);\n                    targetView = target.dataView;\n                    position -= encodingStart;\n                    start -= encodingStart;\n                    refsStartPosition -= encodingStart;\n                    refPosition -= encodingStart;\n                    encodingStart = 0;\n                    safeEnd = target.length - 10;\n                }\n                if (strLength > 0xff00 + refOffset >> 2) {\n                    queuedReferences.push(key, value, position - start);\n                    break;\n                }\n                let isNotAscii;\n                let strStart = refPosition;\n                if (strLength < 0x40) {\n                    let i, c1, c2;\n                    for(i = 0; i < strLength; i++){\n                        c1 = value.charCodeAt(i);\n                        if (c1 < 0x80) {\n                            target[refPosition++] = c1;\n                        } else if (c1 < 0x800) {\n                            isNotAscii = true;\n                            target[refPosition++] = c1 >> 6 | 0xc0;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n                            isNotAscii = true;\n                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n                            i++;\n                            target[refPosition++] = c1 >> 18 | 0xf0;\n                            target[refPosition++] = c1 >> 12 & 0x3f | 0x80;\n                            target[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        } else {\n                            isNotAscii = true;\n                            target[refPosition++] = c1 >> 12 | 0xe0;\n                            target[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        }\n                    }\n                } else {\n                    refPosition += encodeUtf8(target, value, refPosition);\n                    isNotAscii = refPosition - strStart > strLength;\n                }\n                if (refOffset < 0xa0 || refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8)) {\n                    // short strings\n                    if (isNotAscii) {\n                        if (!(transition = nextTransition.string8)) {\n                            if (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n                                // we can safely change ascii to utf8 in place since they are compatible\n                                transition.__type = UTF8;\n                                nextTransition.ascii8 = null;\n                                nextTransition.string8 = transition;\n                                pack(null, 0, true); // special call to notify that structures have been updated\n                            } else {\n                                transition = createTypeTransition(nextTransition, UTF8, 1);\n                            }\n                        }\n                    } else if (refOffset === 0 && !usedAscii0) {\n                        usedAscii0 = true;\n                        transition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n                        break; // don't increment position\n                    } else if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8))) transition = createTypeTransition(nextTransition, ASCII, 1);\n                    target[position++] = refOffset;\n                } else {\n                    // TODO: Enable ascii16 at some point, but get the logic right\n                    //if (isNotAscii)\n                    transition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n                    //else\n                    //transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n                    targetView.setUint16(position, refOffset, true);\n                    position += 2;\n                }\n                break;\n            case \"object\":\n                if (value) {\n                    if (value.constructor === Date) {\n                        transition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n                        targetView.setFloat64(position, value.getTime(), true);\n                        position += 8;\n                    } else {\n                        queuedReferences.push(key, value, keyIndex);\n                    }\n                    break;\n                } else {\n                    nextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n                    if (nextTransition) {\n                        transition = nextTransition;\n                        position = updatedPosition;\n                    } else queuedReferences.push(key, value, keyIndex);\n                }\n                break;\n            case \"boolean\":\n                transition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n                target[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n                break;\n            case \"undefined\":\n                nextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n                if (nextTransition) {\n                    transition = nextTransition;\n                    position = updatedPosition;\n                } else queuedReferences.push(key, value, keyIndex);\n                break;\n            default:\n                queuedReferences.push(key, value, keyIndex);\n        }\n        keyIndex++;\n    }\n    for(let i = 0, l = queuedReferences.length; i < l;){\n        let key = queuedReferences[i++];\n        let value = queuedReferences[i++];\n        let propertyIndex = queuedReferences[i++];\n        let nextTransition = transition[key];\n        if (!nextTransition) {\n            transition[key] = nextTransition = {\n                key,\n                parent: transition,\n                enumerationOffset: propertyIndex - keyIndex,\n                ascii0: null,\n                ascii8: null,\n                num8: null,\n                string16: null,\n                object16: null,\n                num32: null,\n                float64: null\n            };\n        }\n        let newPosition;\n        if (value) {\n            /*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */ let size;\n            refOffset = refPosition - refsStartPosition;\n            if (refOffset < 0xff00) {\n                transition = nextTransition.object16;\n                if (transition) size = 2;\n                else if (transition = nextTransition.object32) size = 4;\n                else {\n                    transition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n                    size = 2;\n                }\n            } else {\n                transition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n                size = 4;\n            }\n            newPosition = pack(value, refPosition);\n            //}\n            if (typeof newPosition === \"object\") {\n                // re-allocated\n                refPosition = newPosition.position;\n                targetView = newPosition.targetView;\n                target = newPosition.target;\n                refsStartPosition -= encodingStart;\n                position -= encodingStart;\n                start -= encodingStart;\n                encodingStart = 0;\n            } else refPosition = newPosition;\n            if (size === 2) {\n                targetView.setUint16(position, refOffset, true);\n                position += 2;\n            } else {\n                targetView.setUint32(position, refOffset, true);\n                position += 4;\n            }\n        } else {\n            transition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n            targetView.setInt16(position, value === null ? -10 : -9, true);\n            position += 2;\n        }\n        keyIndex++;\n    }\n    let recordId = transition[RECORD_SYMBOL];\n    if (recordId == null) {\n        recordId = packr.typedStructs.length;\n        let structure = [];\n        let nextTransition = transition;\n        let key, type;\n        while((type = nextTransition.__type) !== undefined){\n            let size = nextTransition.__size;\n            nextTransition = nextTransition.__parent;\n            key = nextTransition.key;\n            let property = [\n                type,\n                size,\n                key\n            ];\n            if (nextTransition.enumerationOffset) property.push(nextTransition.enumerationOffset);\n            structure.push(property);\n            nextTransition = nextTransition.parent;\n        }\n        structure.reverse();\n        transition[RECORD_SYMBOL] = recordId;\n        packr.typedStructs[recordId] = structure;\n        pack(null, 0, true); // special call to notify that structures have been updated\n    }\n    switch(headerSize){\n        case 1:\n            if (recordId >= 0x10) return 0;\n            target[start] = recordId + 0x20;\n            break;\n        case 2:\n            if (recordId >= 0x100) return 0;\n            target[start] = 0x38;\n            target[start + 1] = recordId;\n            break;\n        case 3:\n            if (recordId >= 0x10000) return 0;\n            target[start] = 0x39;\n            targetView.setUint16(start + 1, recordId, true);\n            break;\n        case 4:\n            if (recordId >= 0x1000000) return 0;\n            targetView.setUint32(start, (recordId << 8) + 0x3a, true);\n            break;\n    }\n    if (position < refsStartPosition) {\n        if (refsStartPosition === refPosition) return position; // no refs\n        // adjust positioning\n        target.copyWithin(position, refsStartPosition, refPosition);\n        refPosition += position - refsStartPosition;\n        typedStructs.lastStringStart = position - start;\n    } else if (position > refsStartPosition) {\n        if (refsStartPosition === refPosition) return position; // no refs\n        typedStructs.lastStringStart = position - start;\n        return writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n    }\n    return refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n    let nextTransition;\n    if (nextTransition = transition.ascii8 || transition.num8) {\n        targetView.setInt8(position, value, true);\n        updatedPosition = position + 1;\n        return nextTransition;\n    }\n    if (nextTransition = transition.string16 || transition.object16) {\n        targetView.setInt16(position, value, true);\n        updatedPosition = position + 2;\n        return nextTransition;\n    }\n    if (nextTransition = transition.num32) {\n        targetView.setUint32(position, 0xe0000100 + value, true);\n        updatedPosition = position + 4;\n        return nextTransition;\n    }\n    // transition.float64\n    if (nextTransition = transition.num64) {\n        targetView.setFloat64(position, NaN, true);\n        targetView.setInt8(position, value);\n        updatedPosition = position + 8;\n        return nextTransition;\n    }\n    updatedPosition = position;\n    // TODO: can we do an \"any\" type where we defer the decision?\n    return;\n}\nfunction createTypeTransition(transition, type, size) {\n    let typeName = TYPE_NAMES[type] + (size << 3);\n    let newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n    newTransition.__type = type;\n    newTransition.__size = size;\n    newTransition.__parent = transition;\n    return newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n    if (!(sharedData instanceof Map)) return sharedData;\n    let typed = sharedData.get(\"typed\") || [];\n    if (Object.isFrozen(typed)) typed = typed.map((structure)=>structure.slice(0));\n    let named = sharedData.get(\"named\");\n    let transitions = Object.create(null);\n    for(let i = 0, l = typed.length; i < l; i++){\n        let structure = typed[i];\n        let transition = transitions;\n        for (let [type, size, key] of structure){\n            let nextTransition = transition[key];\n            if (!nextTransition) {\n                transition[key] = nextTransition = {\n                    key,\n                    parent: transition,\n                    enumerationOffset: 0,\n                    ascii0: null,\n                    ascii8: null,\n                    num8: null,\n                    string16: null,\n                    object16: null,\n                    num32: null,\n                    float64: null,\n                    date64: null\n                };\n            }\n            transition = createTypeTransition(nextTransition, type, size);\n        }\n        transition[RECORD_SYMBOL] = i;\n    }\n    typed.transitions = transitions;\n    this.typedStructs = typed;\n    this.lastTypedStructuresLength = typed.length;\n    return named;\n}\nvar sourceSymbol = Symbol.for(\"source\");\nfunction readStruct(src, position, srcEnd, unpackr) {\n    let recordId = src[position++] - 0x20;\n    if (recordId >= 24) {\n        switch(recordId){\n            case 24:\n                recordId = src[position++];\n                break;\n            // little endian:\n            case 25:\n                recordId = src[position++] + (src[position++] << 8);\n                break;\n            case 26:\n                recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16);\n                break;\n            case 27:\n                recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24);\n                break;\n        }\n    }\n    let structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n    if (!structure) {\n        // copy src buffer because getStructures will override it\n        src = Uint8Array.prototype.slice.call(src, position, srcEnd);\n        srcEnd -= position;\n        position = 0;\n        if (!unpackr.getStructures) throw new Error(`Reference to shared structure ${recordId} without getStructures method`);\n        unpackr._mergeStructures(unpackr.getStructures());\n        if (!unpackr.typedStructs) throw new Error(\"Could not find any shared typed structures\");\n        unpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n        structure = unpackr.typedStructs[recordId];\n        if (!structure) throw new Error(\"Could not find typed structure \" + recordId);\n    }\n    var construct = structure.construct;\n    var fullConstruct = structure.fullConstruct;\n    if (!construct) {\n        construct = structure.construct = function LazyObject() {};\n        fullConstruct = structure.fullConstruct = function LoadedObject() {};\n        fullConstruct.prototype = unpackr.structPrototype || {};\n        var prototype = construct.prototype = unpackr.structPrototype ? Object.create(unpackr.structPrototype) : {};\n        let properties = [];\n        let currentOffset = 0;\n        let lastRefProperty;\n        for(let i = 0, l = structure.length; i < l; i++){\n            let definition = structure[i];\n            let [type, size, key, enumerationOffset] = definition;\n            if (key === \"__proto__\") key = \"__proto_\";\n            let property = {\n                key,\n                offset: currentOffset\n            };\n            if (enumerationOffset) properties.splice(i + enumerationOffset, 0, property);\n            else properties.push(property);\n            let getRef;\n            switch(size){\n                case 0:\n                    getRef = ()=>0;\n                    break;\n                case 1:\n                    getRef = (source, position)=>{\n                        let ref = source.bytes[position + property.offset];\n                        return ref >= 0xf6 ? toConstant(ref) : ref;\n                    };\n                    break;\n                case 2:\n                    getRef = (source, position)=>{\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        let ref = dataView.getUint16(position + property.offset, true);\n                        return ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n                    };\n                    break;\n                case 4:\n                    getRef = (source, position)=>{\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        let ref = dataView.getUint32(position + property.offset, true);\n                        return ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n                    };\n                    break;\n            }\n            property.getRef = getRef;\n            currentOffset += size;\n            let get;\n            switch(type){\n                case ASCII:\n                    if (lastRefProperty && !lastRefProperty.next) lastRefProperty.next = property;\n                    lastRefProperty = property;\n                    property.multiGetCount = 0;\n                    get = function(source) {\n                        let src = source.bytes;\n                        let position = source.position;\n                        let refStart = currentOffset + position;\n                        let ref = getRef(source, position);\n                        if (typeof ref !== \"number\") return ref;\n                        let end, next = property.next;\n                        while(next){\n                            end = next.getRef(source, position);\n                            if (typeof end === \"number\") break;\n                            else end = null;\n                            next = next.next;\n                        }\n                        if (end == null) end = source.bytesEnd - refStart;\n                        if (source.srcString) {\n                            return source.srcString.slice(ref, end);\n                        }\n                        /*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/ return readString(src, ref + refStart, end - ref);\n                    //return src.toString('latin1', ref + refStart, end + refStart);\n                    };\n                    break;\n                case UTF8:\n                case OBJECT_DATA:\n                    if (lastRefProperty && !lastRefProperty.next) lastRefProperty.next = property;\n                    lastRefProperty = property;\n                    get = function(source) {\n                        let position = source.position;\n                        let refStart = currentOffset + position;\n                        let ref = getRef(source, position);\n                        if (typeof ref !== \"number\") return ref;\n                        let src = source.bytes;\n                        let end, next = property.next;\n                        while(next){\n                            end = next.getRef(source, position);\n                            if (typeof end === \"number\") break;\n                            else end = null;\n                            next = next.next;\n                        }\n                        if (end == null) end = source.bytesEnd - refStart;\n                        if (type === UTF8) {\n                            return src.toString(\"utf8\", ref + refStart, end + refStart);\n                        } else {\n                            currentSource = source;\n                            try {\n                                return unpackr.unpack(src, {\n                                    start: ref + refStart,\n                                    end: end + refStart\n                                });\n                            } finally{\n                                currentSource = null;\n                            }\n                        }\n                    };\n                    break;\n                case NUMBER:\n                    switch(size){\n                        case 4:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                                let position = source.position + property.offset;\n                                let value = dataView.getInt32(position, true);\n                                if (value < 0x20000000) {\n                                    if (value > -0x1f000000) return value;\n                                    if (value > -0x20000000) return toConstant(value & 0xff);\n                                }\n                                let fValue = dataView.getFloat32(position, true);\n                                // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                                let multiplier = mult10[(src[position + 3] & 0x7f) << 1 | src[position + 2] >> 7];\n                                return (multiplier * fValue + (fValue > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n                            };\n                            break;\n                        case 8:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                                let value = dataView.getFloat64(source.position + property.offset, true);\n                                if (isNaN(value)) {\n                                    let byte = src[source.position + property.offset];\n                                    if (byte >= 0xf6) return toConstant(byte);\n                                }\n                                return value;\n                            };\n                            break;\n                        case 1:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let value = src[source.position + property.offset];\n                                return value < 0xf6 ? value : toConstant(value);\n                            };\n                            break;\n                    }\n                    break;\n                case DATE:\n                    get = function(source) {\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        return new Date(dataView.getFloat64(source.position + property.offset, true));\n                    };\n                    break;\n            }\n            property.get = get;\n        }\n        // TODO: load the srcString for faster string decoding on toJSON\n        if (evalSupported) {\n            let objectLiteralProperties = [];\n            let args = [];\n            let i = 0;\n            let hasInheritedProperties;\n            for (let property of properties){\n                if (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n                    // these properties are not eagerly evaluated and this can be used for creating properties\n                    // that are not serialized as JSON\n                    hasInheritedProperties = true;\n                    continue;\n                }\n                Object.defineProperty(prototype, property.key, {\n                    get: withSource(property.get),\n                    enumerable: true\n                });\n                let valueFunction = \"v\" + i++;\n                args.push(valueFunction);\n                objectLiteralProperties.push(\"o[\" + JSON.stringify(property.key) + \"]=\" + valueFunction + \"(s)\");\n            }\n            if (hasInheritedProperties) {\n                objectLiteralProperties.push(\"__proto__:this\");\n            }\n            let toObject = new Function(...args, \"var c=this;return function(s){var o=new c();\" + objectLiteralProperties.join(\";\") + \";return o;}\").apply(fullConstruct, properties.map((prop)=>prop.get));\n            Object.defineProperty(prototype, \"toJSON\", {\n                value (omitUnderscoredProperties) {\n                    return toObject.call(this, this[sourceSymbol]);\n                }\n            });\n        } else {\n            Object.defineProperty(prototype, \"toJSON\", {\n                value (omitUnderscoredProperties) {\n                    // return an enumerable object with own properties to JSON stringify\n                    let resolved = {};\n                    for(let i = 0, l = properties.length; i < l; i++){\n                        // TODO: check alwaysLazyProperty\n                        let key = properties[i].key;\n                        resolved[key] = this[key];\n                    }\n                    return resolved;\n                }\n            });\n        }\n    }\n    var instance = new construct();\n    instance[sourceSymbol] = {\n        bytes: src,\n        position,\n        srcString: \"\",\n        bytesEnd: srcEnd\n    };\n    return instance;\n}\nfunction toConstant(code) {\n    switch(code){\n        case 0xf6:\n            return null;\n        case 0xf7:\n            return undefined;\n        case 0xf8:\n            return false;\n        case 0xf9:\n            return true;\n    }\n    throw new Error(\"Unknown constant\");\n}\nfunction withSource(get) {\n    return function() {\n        return get(this[sourceSymbol]);\n    };\n}\nfunction saveState() {\n    if (currentSource) {\n        currentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n        currentSource.position = 0;\n        currentSource.bytesEnd = currentSource.bytes.length;\n    }\n}\nfunction prepareStructures(structures, packr) {\n    if (packr.typedStructs) {\n        let structMap = new Map();\n        structMap.set(\"named\", structures);\n        structMap.set(\"typed\", packr.typedStructs);\n        structures = structMap;\n    }\n    let lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n    structures.isCompatible = (existing)=>{\n        let compatible = true;\n        if (existing instanceof Map) {\n            let named = existing.get(\"named\") || [];\n            if (named.length !== (packr.lastNamedStructuresLength || 0)) compatible = false;\n            let typed = existing.get(\"typed\") || [];\n            if (typed.length !== lastTypedStructuresLength) compatible = false;\n        } else if (existing instanceof Array || Array.isArray(existing)) {\n            if (existing.length !== (packr.lastNamedStructuresLength || 0)) compatible = false;\n        }\n        if (!compatible) packr._mergeStructures(existing);\n        return compatible;\n    };\n    packr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n    return structures;\n}\nsetReadStruct(readStruct, onLoadedStructures, saveState);\nclass PackrStream extends stream.Transform {\n    constructor(options){\n        if (!options) options = {};\n        options.writableObjectMode = true;\n        super(options);\n        options.sequential = true;\n        this.packr = options.packr || new Packr(options);\n    }\n    _transform(value, encoding, callback) {\n        this.push(this.packr.pack(value));\n        callback();\n    }\n}\nclass UnpackrStream extends stream.Transform {\n    constructor(options){\n        if (!options) options = {};\n        options.objectMode = true;\n        super(options);\n        options.structures = [];\n        this.unpackr = options.unpackr || new Unpackr(options);\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.incompleteBuffer) {\n            chunk = Buffer.concat([\n                this.incompleteBuffer,\n                chunk\n            ]);\n            this.incompleteBuffer = null;\n        }\n        let values;\n        try {\n            values = this.unpackr.unpackMultiple(chunk);\n        } catch (error) {\n            if (error.incomplete) {\n                this.incompleteBuffer = chunk.slice(error.lastPosition);\n                values = error.values;\n            } else throw error;\n        } finally{\n            for (let value of values || []){\n                if (value === null) value = this.getNullValue();\n                this.push(value);\n            }\n        }\n        if (callback) callback();\n    }\n    getNullValue() {\n        return Symbol.for(null);\n    }\n}\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */ function packIter(objectIterator, options = {}) {\n    if (!objectIterator || typeof objectIterator !== \"object\") {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable\");\n    } else if (typeof objectIterator[Symbol.iterator] === \"function\") {\n        return packIterSync(objectIterator, options);\n    } else if (typeof objectIterator.then === \"function\" || typeof objectIterator[Symbol.asyncIterator] === \"function\") {\n        return packIterAsync(objectIterator, options);\n    } else {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise\");\n    }\n}\nfunction* packIterSync(objectIterator, options) {\n    const packr = new Packr(options);\n    for (const value of objectIterator){\n        yield packr.pack(value);\n    }\n}\nasync function* packIterAsync(objectIterator, options) {\n    const packr = new Packr(options);\n    for await (const value of objectIterator){\n        yield packr.pack(value);\n    }\n}\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */ function unpackIter(bufferIterator, options = {}) {\n    if (!bufferIterator || typeof bufferIterator !== \"object\") {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise\");\n    }\n    const unpackr = new Unpackr(options);\n    let incomplete;\n    const parser = (chunk)=>{\n        let yields;\n        // if there's incomplete data from previous chunk, concatinate and try again\n        if (incomplete) {\n            chunk = Buffer.concat([\n                incomplete,\n                chunk\n            ]);\n            incomplete = undefined;\n        }\n        try {\n            yields = unpackr.unpackMultiple(chunk);\n        } catch (err) {\n            if (err.incomplete) {\n                incomplete = chunk.slice(err.lastPosition);\n                yields = err.values;\n            } else {\n                throw err;\n            }\n        }\n        return yields;\n    };\n    if (typeof bufferIterator[Symbol.iterator] === \"function\") {\n        return function* iter() {\n            for (const value of bufferIterator){\n                yield* parser(value);\n            }\n        }();\n    } else if (typeof bufferIterator[Symbol.asyncIterator] === \"function\") {\n        return async function* iter() {\n            for await (const value of bufferIterator){\n                yield* parser(value);\n            }\n        }();\n    }\n}\nconst decodeIter = unpackIter;\nconst encodeIter = packIter;\nconst useRecords = false;\nconst mapsAsObjects = true;\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === \"true\";\nif (!nativeAccelerationDisabled) {\n    let extractor;\n    try {\n        if (true) extractor = __webpack_require__(/*! msgpackr-extract */ \"(rsc)/./node_modules/msgpackr-extract/index.js\");\n        else {}\n        if (extractor) setExtractor(extractor.extractStrings);\n    } catch (error) {\n    // native module is optional\n    }\n}\nexports.ALWAYS = ALWAYS;\nexports.C1 = C1;\nexports.DECIMAL_FIT = DECIMAL_FIT;\nexports.DECIMAL_ROUND = DECIMAL_ROUND;\nexports.Decoder = Decoder;\nexports.DecoderStream = UnpackrStream;\nexports.Encoder = Encoder;\nexports.EncoderStream = PackrStream;\nexports.FLOAT32_OPTIONS = FLOAT32_OPTIONS;\nexports.NEVER = NEVER;\nexports.Packr = Packr;\nexports.PackrStream = PackrStream;\nexports.Unpackr = Unpackr;\nexports.UnpackrStream = UnpackrStream;\nexports.addExtension = addExtension;\nexports.clearSource = clearSource;\nexports.decode = decode;\nexports.decodeIter = decodeIter;\nexports.encode = encode;\nexports.encodeIter = encodeIter;\nexports.mapsAsObjects = mapsAsObjects;\nexports.pack = pack;\nexports.roundFloat32 = roundFloat32;\nexports.unpack = unpack;\nexports.unpackMultiple = unpackMultiple;\nexports.useRecords = useRecords; //# sourceMappingURL=node.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbXNncGFja3IvZGlzdC9ub2RlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLElBQUlFO0FBQ0osSUFBSTtJQUNIQSxVQUFVLElBQUlDO0FBQ2YsRUFBRSxPQUFNQyxPQUFPLENBQUM7QUFDaEIsSUFBSUM7QUFDSixJQUFJQztBQUNKLElBQUlDLGFBQWE7QUFDakIsTUFBTUMsY0FBYyxFQUFFO0FBQ3RCLElBQUlDLFVBQVVEO0FBQ2QsSUFBSUUsaUJBQWlCO0FBQ3JCLElBQUlDLGlCQUFpQixDQUFDO0FBQ3RCLElBQUlDO0FBQ0osSUFBSUM7QUFDSixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsZUFBZTtBQUNuQixJQUFJQztBQUNKLElBQUlDO0FBQ0osSUFBSUMsb0JBQW9CLEVBQUU7QUFDMUIsSUFBSUM7QUFDSixJQUFJQyxpQkFBaUI7SUFDcEJDLFlBQVk7SUFDWkMsZUFBZTtBQUNoQjtBQUNBLE1BQU1DO0FBQVE7QUFDZCxNQUFNQyxLQUFLLElBQUlEO0FBQ2ZDLEdBQUdDLElBQUksR0FBRztBQUNWLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyw0QkFBNEI7QUFDaEMsSUFBSUMsY0FBY0Msc0JBQXNCQztBQUN4QyxnQkFBZ0I7QUFDaEIsSUFBSTtJQUNILElBQUlDLFNBQVM7QUFDZCxFQUFFLE9BQU0zQixPQUFPO0lBQ2QsK0VBQStFO0lBQy9FdUIsNEJBQTRCSztBQUM3QjtBQUVBLE1BQU1DO0lBQ0xDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixJQUFJQSxTQUFTO1lBQ1osSUFBSUEsUUFBUWQsVUFBVSxLQUFLLFNBQVNjLFFBQVFiLGFBQWEsS0FBS2MsV0FDN0RELFFBQVFiLGFBQWEsR0FBRztZQUN6QixJQUFJYSxRQUFRRSxVQUFVLElBQUlGLFFBQVFHLE9BQU8sS0FBSyxPQUFPO2dCQUNwREgsUUFBUUcsT0FB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b2R1bGVzL21zZ3BhY2tyL2Rpc3Qvbm9kZS5janM/MDA4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBtb2R1bGUkMSA9IHJlcXVpcmUoJ21vZHVsZScpO1xuXG52YXIgZGVjb2RlcjtcbnRyeSB7XG5cdGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbn0gY2F0Y2goZXJyb3IpIHt9XG52YXIgc3JjO1xudmFyIHNyY0VuZDtcbnZhciBwb3NpdGlvbiQxID0gMDtcbmNvbnN0IEVNUFRZX0FSUkFZID0gW107XG52YXIgc3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xudmFyIHN0cmluZ1Bvc2l0aW9uID0gMDtcbnZhciBjdXJyZW50VW5wYWNrciA9IHt9O1xudmFyIGN1cnJlbnRTdHJ1Y3R1cmVzO1xudmFyIHNyY1N0cmluZztcbnZhciBzcmNTdHJpbmdTdGFydCA9IDA7XG52YXIgc3JjU3RyaW5nRW5kID0gMDtcbnZhciBidW5kbGVkU3RyaW5ncyQxO1xudmFyIHJlZmVyZW5jZU1hcDtcbnZhciBjdXJyZW50RXh0ZW5zaW9ucyA9IFtdO1xudmFyIGRhdGFWaWV3O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHR1c2VSZWNvcmRzOiBmYWxzZSxcblx0bWFwc0FzT2JqZWN0czogdHJ1ZVxufTtcbmNsYXNzIEMxVHlwZSB7fVxuY29uc3QgQzEgPSBuZXcgQzFUeXBlKCk7XG5DMS5uYW1lID0gJ01lc3NhZ2VQYWNrIDB4QzEnO1xudmFyIHNlcXVlbnRpYWxNb2RlID0gZmFsc2U7XG52YXIgaW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCA9IDI7XG52YXIgcmVhZFN0cnVjdCQxLCBvbkxvYWRlZFN0cnVjdHVyZXMkMSwgb25TYXZlU3RhdGU7XG4vLyBuby1ldmFsIGJ1aWxkXG50cnkge1xuXHRuZXcgRnVuY3Rpb24oJycpO1xufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG5cdGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSBJbmZpbml0eTtcbn1cblxuY2xhc3MgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMudXNlUmVjb3JkcyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5tYXBzQXNPYmplY3RzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9IHRydWU7XG5cdFx0XHRpZiAob3B0aW9ucy5zZXF1ZW50aWFsICYmIG9wdGlvbnMudHJ1c3RlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0b3B0aW9ucy50cnVzdGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCFvcHRpb25zLnN0cnVjdHVyZXMgJiYgb3B0aW9ucy51c2VSZWNvcmRzICE9IGZhbHNlKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMpXG5cdFx0XHRcdFx0XHRvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVzKVxuXHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gb3B0aW9ucy5zdHJ1Y3R1cmVzLmxlbmd0aDtcblx0XHRcdGVsc2UgaWYgKG9wdGlvbnMuZ2V0U3RydWN0dXJlcykge1xuXHRcdFx0XHQob3B0aW9ucy5zdHJ1Y3R1cmVzID0gW10pLnVuaW5pdGlhbGl6ZWQgPSB0cnVlOyAvLyB0aGlzIGlzIHdoYXQgd2UgdXNlIHRvIGRlbm90ZSBhbiB1bmluaXRpYWxpemVkIHN0cnVjdHVyZXNcblx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5pbnQ2NEFzTnVtYmVyKSB7XG5cdFx0XHRcdG9wdGlvbnMuaW50NjRBc1R5cGUgPSAnbnVtYmVyJztcblx0XHRcdH1cblx0XHR9XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblx0fVxuXHR1bnBhY2soc291cmNlLCBvcHRpb25zKSB7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Ly8gcmUtZW50cmFudCBleGVjdXRpb24sIHNhdmUgdGhlIHN0YXRlIGFuZCByZXN0b3JlIGl0IGFmdGVyIHdlIGRvIHRoaXMgdW5wYWNrXG5cdFx0XHRyZXR1cm4gc2F2ZVN0YXRlJDEoKCkgPT4ge1xuXHRcdFx0XHRjbGVhclNvdXJjZSgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcyA/IHRoaXMudW5wYWNrKHNvdXJjZSwgb3B0aW9ucykgOiBVbnBhY2tyLnByb3RvdHlwZS51bnBhY2suY2FsbChkZWZhdWx0T3B0aW9ucywgc291cmNlLCBvcHRpb25zKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0aWYgKCFzb3VyY2UuYnVmZmVyICYmIHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpXG5cdFx0XHRzb3VyY2UgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IEJ1ZmZlci5mcm9tKHNvdXJjZSkgOiBuZXcgVWludDhBcnJheShzb3VyY2UpO1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMuZW5kIHx8IHNvdXJjZS5sZW5ndGg7XG5cdFx0XHRwb3NpdGlvbiQxID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiQxID0gMDtcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMgPiAtMSA/IG9wdGlvbnMgOiBzb3VyY2UubGVuZ3RoO1xuXHRcdH1cblx0XHRzdHJpbmdQb3NpdGlvbiA9IDA7XG5cdFx0c3JjU3RyaW5nRW5kID0gMDtcblx0XHRzcmNTdHJpbmcgPSBudWxsO1xuXHRcdHN0cmluZ3MgPSBFTVBUWV9BUlJBWTtcblx0XHRidW5kbGVkU3RyaW5ncyQxID0gbnVsbDtcblx0XHRzcmMgPSBzb3VyY2U7XG5cdFx0Ly8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuXHRcdC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcblx0XHQvLyBuZXcgb25lc1xuXHRcdHRyeSB7XG5cdFx0XHRkYXRhVmlldyA9IHNvdXJjZS5kYXRhVmlldyB8fCAoc291cmNlLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCkpO1xuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIGJ1ZmZlciwgbWF5YmUgaXQgaXMgdGhlIHdyb25nIHR5cGUgb2Ygb2JqZWN0XG5cdFx0XHRzcmMgPSBudWxsO1xuXHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBtdXN0IGJlIGEgVWludDhBcnJheSBvciBCdWZmZXIgYnV0IHdhcyBhICcgKyAoKHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09ICdvYmplY3QnKSA/IHNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lIDogdHlwZW9mIHNvdXJjZSkpXG5cdFx0fVxuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgVW5wYWNrcikge1xuXHRcdFx0Y3VycmVudFVucGFja3IgPSB0aGlzO1xuXHRcdFx0aWYgKHRoaXMuc3RydWN0dXJlcykge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IHRoaXMuc3RydWN0dXJlcztcblx0XHRcdFx0cmV0dXJuIGNoZWNrZWRSZWFkKG9wdGlvbnMpXG5cdFx0XHR9IGVsc2UgaWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gZGVmYXVsdE9wdGlvbnM7XG5cdFx0XHRpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG5cdFx0fVxuXHRcdHJldHVybiBjaGVja2VkUmVhZChvcHRpb25zKVxuXHR9XG5cdHVucGFja011bHRpcGxlKHNvdXJjZSwgZm9yRWFjaCkge1xuXHRcdGxldCB2YWx1ZXMsIGxhc3RQb3NpdGlvbiA9IDA7XG5cdFx0dHJ5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gdHJ1ZTtcblx0XHRcdGxldCBzaXplID0gc291cmNlLmxlbmd0aDtcblx0XHRcdGxldCB2YWx1ZSA9IHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIHNpemUpIDogZGVmYXVsdFVucGFja3IudW5wYWNrKHNvdXJjZSwgc2l6ZSk7XG5cdFx0XHRpZiAoZm9yRWFjaCkge1xuXHRcdFx0XHRpZiAoZm9yRWFjaCh2YWx1ZSwgbGFzdFBvc2l0aW9uLCBwb3NpdGlvbiQxKSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRcdFx0d2hpbGUocG9zaXRpb24kMSA8IHNpemUpIHtcblx0XHRcdFx0XHRsYXN0UG9zaXRpb24gPSBwb3NpdGlvbiQxO1xuXHRcdFx0XHRcdGlmIChmb3JFYWNoKGNoZWNrZWRSZWFkKCksIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24kMSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YWx1ZXMgPSBbIHZhbHVlIF07XG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uJDEgPCBzaXplKSB7XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChjaGVja2VkUmVhZCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzXG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0ZXJyb3IubGFzdFBvc2l0aW9uID0gbGFzdFBvc2l0aW9uO1xuXHRcdFx0ZXJyb3IudmFsdWVzID0gdmFsdWVzO1xuXHRcdFx0dGhyb3cgZXJyb3Jcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2VxdWVudGlhbE1vZGUgPSBmYWxzZTtcblx0XHRcdGNsZWFyU291cmNlKCk7XG5cdFx0fVxuXHR9XG5cdF9tZXJnZVN0cnVjdHVyZXMobG9hZGVkU3RydWN0dXJlcywgZXhpc3RpbmdTdHJ1Y3R1cmVzKSB7XG5cdFx0aWYgKG9uTG9hZGVkU3RydWN0dXJlcyQxKVxuXHRcdFx0bG9hZGVkU3RydWN0dXJlcyA9IG9uTG9hZGVkU3RydWN0dXJlcyQxLmNhbGwodGhpcywgbG9hZGVkU3RydWN0dXJlcyk7XG5cdFx0bG9hZGVkU3RydWN0dXJlcyA9IGxvYWRlZFN0cnVjdHVyZXMgfHwgW107XG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihsb2FkZWRTdHJ1Y3R1cmVzKSlcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGxvYWRlZFN0cnVjdHVyZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpXTtcblx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0c3RydWN0dXJlLmlzU2hhcmVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKGkgPj0gMzIpXG5cdFx0XHRcdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gKGkgLSAzMikgPj4gNTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9hZGVkU3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSBsb2FkZWRTdHJ1Y3R1cmVzLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpZCBpbiBleGlzdGluZ1N0cnVjdHVyZXMgfHwgW10pIHtcblx0XHRcdGlmIChpZCA+PSAwKSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBsb2FkZWRTdHJ1Y3R1cmVzW2lkXTtcblx0XHRcdFx0bGV0IGV4aXN0aW5nID0gZXhpc3RpbmdTdHJ1Y3R1cmVzW2lkXTtcblx0XHRcdFx0aWYgKGV4aXN0aW5nKSB7XG5cdFx0XHRcdFx0aWYgKHN0cnVjdHVyZSlcblx0XHRcdFx0XHRcdChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gW10pKVtpZF0gPSBzdHJ1Y3R1cmU7XG5cdFx0XHRcdFx0bG9hZGVkU3RydWN0dXJlc1tpZF0gPSBleGlzdGluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlc1xuXHR9XG5cdGRlY29kZShzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51bnBhY2soc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5mdW5jdGlvbiBjaGVja2VkUmVhZChvcHRpb25zKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFjdXJyZW50VW5wYWNrci50cnVzdGVkICYmICFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IGN1cnJlbnRTdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwO1xuXHRcdFx0aWYgKHNoYXJlZExlbmd0aCA8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aClcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID0gc2hhcmVkTGVuZ3RoO1xuXHRcdH1cblx0XHRsZXQgcmVzdWx0O1xuXHRcdGlmIChjdXJyZW50VW5wYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgc3JjW3Bvc2l0aW9uJDFdIDwgMHg0MCAmJiBzcmNbcG9zaXRpb24kMV0gPj0gMHgyMCAmJiByZWFkU3RydWN0JDEpIHtcblx0XHRcdHJlc3VsdCA9IHJlYWRTdHJ1Y3QkMShzcmMsIHBvc2l0aW9uJDEsIHNyY0VuZCwgY3VycmVudFVucGFja3IpO1xuXHRcdFx0c3JjID0gbnVsbDsgLy8gZGlzcG9zZSBvZiB0aGlzIHNvIHRoYXQgcmVjdXJzaXZlIHVucGFjayBjYWxscyBkb24ndCBzYXZlIHN0YXRlXG5cdFx0XHRpZiAoIShvcHRpb25zICYmIG9wdGlvbnMubGF6eSkgJiYgcmVzdWx0KVxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudG9KU09OKCk7XG5cdFx0XHRwb3NpdGlvbiQxID0gc3JjRW5kO1xuXHRcdH0gZWxzZVxuXHRcdFx0cmVzdWx0ID0gcmVhZCgpO1xuXHRcdGlmIChidW5kbGVkU3RyaW5ncyQxKSB7IC8vIGJ1bmRsZWQgc3RyaW5ncyB0byBza2lwIHBhc3Rcblx0XHRcdHBvc2l0aW9uJDEgPSBidW5kbGVkU3RyaW5ncyQxLnBvc3RCdW5kbGVQb3NpdGlvbjtcblx0XHRcdGJ1bmRsZWRTdHJpbmdzJDEgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoc2VxdWVudGlhbE1vZGUpXG5cdFx0XHQvLyB3ZSBvbmx5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RydWN0dXJlcyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IsIGJ1dCBpZiB3ZSBjb21wbGV0ZWQgYSByZWFkLFxuXHRcdFx0Ly8gd2UgY2FuIGNsZWFyIHRoaXMgb3V0IGFuZCBrZWVwIHRoZSBzdHJ1Y3R1cmVzIHdlIHJlYWRcblx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gbnVsbDtcblxuXHRcdGlmIChwb3NpdGlvbiQxID09IHNyY0VuZCkge1xuXHRcdFx0Ly8gZmluaXNoZWQgcmVhZGluZyB0aGlzIHNvdXJjZSwgY2xlYW51cCByZWZlcmVuY2VzXG5cdFx0XHRpZiAoY3VycmVudFN0cnVjdHVyZXMgJiYgY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpXG5cdFx0XHRcdHJlc3RvcmVTdHJ1Y3R1cmVzKCk7XG5cdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGw7XG5cdFx0XHRzcmMgPSBudWxsO1xuXHRcdFx0aWYgKHJlZmVyZW5jZU1hcClcblx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uJDEgPiBzcmNFbmQpIHtcblx0XHRcdC8vIG92ZXIgcmVhZFxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBNZXNzYWdlUGFjayBkYXRhJylcblx0XHR9IGVsc2UgaWYgKCFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IGpzb25WaWV3O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvblZpZXcgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQsIChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gYCR7dmFsdWV9bmAgOiB2YWx1ZSkuc2xpY2UoMCwgMTAwKTtcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdFx0anNvblZpZXcgPSAnKEpTT04gdmlldyBub3QgYXZhaWxhYmxlICcgKyBlcnJvciArICcpJztcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignRGF0YSByZWFkLCBidXQgZW5kIG9mIGJ1ZmZlciBub3QgcmVhY2hlZCAnICsganNvblZpZXcpXG5cdFx0fVxuXHRcdC8vIGVsc2UgbW9yZSB0byByZWFkLCBidXQgd2UgYXJlIHJlYWRpbmcgc2VxdWVudGlhbGx5LCBzbyBkb24ndCBjbGVhciBzb3VyY2UgeWV0XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKTtcblx0XHRjbGVhclNvdXJjZSgpO1xuXHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IgfHwgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKSB8fCBwb3NpdGlvbiQxID4gc3JjRW5kKSB7XG5cdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0dGhyb3cgZXJyb3Jcblx0fVxufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RydWN0dXJlcygpIHtcblx0Zm9yIChsZXQgaWQgaW4gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpIHtcblx0XHRjdXJyZW50U3RydWN0dXJlc1tpZF0gPSBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlc1tpZF07XG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0aWYgKHRva2VuIDwgMHhhMCkge1xuXHRcdGlmICh0b2tlbiA8IDB4ODApIHtcblx0XHRcdGlmICh0b2tlbiA8IDB4NDApXG5cdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1t0b2tlbiAmIDB4M2ZdIHx8XG5cdFx0XHRcdFx0Y3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcyAmJiBsb2FkU3RydWN0dXJlcygpW3Rva2VuICYgMHgzZl07XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0XHRpZiAoIXN0cnVjdHVyZS5yZWFkKSB7XG5cdFx0XHRcdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIHRva2VuICYgMHgzZik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodG9rZW4gPCAweDkwKSB7XG5cdFx0XHQvLyBtYXBcblx0XHRcdHRva2VuIC09IDB4ODA7XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdFx0XHRsZXQgb2JqZWN0ID0ge307XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdGxldCBrZXkgPSByZWFkS2V5KCk7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmplY3Rcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBtYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdG1hcC5zZXQocmVhZCgpLCByZWFkKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXBcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9rZW4gLT0gMHg5MDtcblx0XHRcdGxldCBhcnJheSA9IG5ldyBBcnJheSh0b2tlbik7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0YXJyYXlbaV0gPSByZWFkKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdFx0XHRyZXR1cm4gYXJyYXlcblx0XHR9XG5cdH0gZWxzZSBpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGV0IGxlbmd0aCA9IHRva2VuIC0gMHhhMDtcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSBsZW5ndGgpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0fVxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPT0gMCAmJiBzcmNFbmQgPCAxNDApIHtcblx0XHRcdC8vIGZvciBzbWFsbCBibG9ja3MsIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgZXh0cmFjdCBjYWxsIGlzIGhlbHBmdWxcblx0XHRcdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKTtcblx0XHRcdGlmIChzdHJpbmcgIT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHN0cmluZ1xuXHRcdH1cblx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHtcblx0XHRsZXQgdmFsdWU7XG5cdFx0c3dpdGNoICh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGMwOiByZXR1cm4gbnVsbFxuXHRcdFx0Y2FzZSAweGMxOlxuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MkMSkge1xuXHRcdFx0XHRcdHZhbHVlID0gcmVhZCgpOyAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaW4gY2hhcmFjdGVycyAobm90IGJ5dGVzISlcblx0XHRcdFx0XHRpZiAodmFsdWUgPiAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1bmRsZWRTdHJpbmdzJDFbMV0uc2xpY2UoYnVuZGxlZFN0cmluZ3MkMS5wb3NpdGlvbjEsIGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24xICs9IHZhbHVlKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5ncyQxWzBdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24wLCBidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMCAtPSB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gQzE7IC8vIFwibmV2ZXItdXNlZFwiLCByZXR1cm4gc3BlY2lhbCBvYmplY3QgdG8gZGVub3RlIHRoYXRcblx0XHRcdGNhc2UgMHhjMjogcmV0dXJuIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzM6IHJldHVybiB0cnVlXG5cdFx0XHRjYXNlIDB4YzQ6XG5cdFx0XHRcdC8vIGJpbiA4XG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzU6XG5cdFx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM3OlxuXHRcdFx0XHQvLyBleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dChzcmNbcG9zaXRpb24kMSsrXSlcblx0XHRcdGNhc2UgMHhjODpcblx0XHRcdFx0Ly8gZXh0IDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM5OlxuXHRcdFx0XHQvLyBleHQgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQodmFsdWUpXG5cdFx0XHRjYXNlIDB4Y2E6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLnVzZUZsb2F0MzIgPiAyKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygoc3JjW3Bvc2l0aW9uJDFdICYgMHg3ZikgPDwgMSkgfCAoc3JjW3Bvc2l0aW9uJDEgKyAxXSA+PiA3KV07XG5cdFx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRcdHJldHVybiAoKG11bHRpcGxpZXIgKiB2YWx1ZSArICh2YWx1ZSA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhjYjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDg7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Ly8gdWludCBoYW5kbGVyc1xuXHRcdFx0Y2FzZSAweGNjOlxuXHRcdFx0XHRyZXR1cm4gc3JjW3Bvc2l0aW9uJDErK11cblx0XHRcdGNhc2UgMHhjZDpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSkgKiAweDEwMDAwMDAwMDtcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSArIDQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uJDEpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRcdGlmICh2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA4O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblxuXHRcdFx0Ly8gaW50IGhhbmRsZXJzXG5cdFx0XHRjYXNlIDB4ZDA6XG5cdFx0XHRcdHJldHVybiBkYXRhVmlldy5nZXRJbnQ4KHBvc2l0aW9uJDErKylcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24kMSkgKiAweDEwMDAwMDAwMDtcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSArIDQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24kMSkudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0XHRpZiAodmFsdWU+PUJpZ0ludCgtMik8PEJpZ0ludCg1MikmJnZhbHVlPD1CaWdJbnQoMik8PEJpZ0ludCg1MikpIHZhbHVlPU51bWJlcih2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gODtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cblx0XHRcdGNhc2UgMHhkNDpcblx0XHRcdFx0Ly8gZml4ZXh0IDFcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2YpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGN1cnJlbnRFeHRlbnNpb25zW3ZhbHVlXTtcblx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLnJlYWQpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24kMSsrOyAvLyBza2lwIGZpbGxlciBieXRlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24ucmVhZChyZWFkKCkpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGV4dGVuc2lvbi5ub0J1ZmZlcikge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiQxKys7IC8vIHNraXAgZmlsbGVyIGJ5dGVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbigpXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbihzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgKytwb3NpdGlvbiQxKSlcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBleHRlbnNpb24gJyArIHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIDB4ZDU6XG5cdFx0XHRcdC8vIGZpeGV4dCAyXG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uJDFdO1xuXHRcdFx0XHRpZiAodmFsdWUgPT0gMHg3Mikge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDErKztcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2YsIHNyY1twb3NpdGlvbiQxKytdKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gcmVhZEV4dCgyKVxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg0KVxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg4KVxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHQvLyBmaXhleHQgMTZcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMTYpXG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmc4KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzE2KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzMyKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRjOlxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHJlYWRBcnJheSh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdC8vIGFycmF5IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGU6XG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRkZWZhdWx0OiAvLyBuZWdhdGl2ZSBpbnRcblx0XHRcdFx0aWYgKHRva2VuID49IDB4ZTApXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuIC0gMHgxMDBcblx0XHRcdFx0aWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgZXJyb3IgPSBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKTtcblx0XHRcdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBNZXNzYWdlUGFjayB0b2tlbiAnICsgdG9rZW4pXG5cblx0XHR9XG5cdH1cbn1cbmNvbnN0IHZhbGlkTmFtZSA9IC9eW2EtekEtWl8kXVthLXpBLVpcXGRfJF0qJC87XG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdElkKSB7XG5cdGZ1bmN0aW9uIHJlYWRPYmplY3QoKSB7XG5cdFx0Ly8gVGhpcyBpbml0aWFsIGZ1bmN0aW9uIGlzIHF1aWNrIHRvIGluc3RhbnRpYXRlLCBidXQgcnVucyBzbG93ZXIuIEFmdGVyIHNldmVyYWwgaXRlcmF0aW9ucyBwYXkgdGhlIGNvc3QgdG8gYnVpbGQgdGhlIGZhc3RlciBmdW5jdGlvblxuXHRcdGlmIChyZWFkT2JqZWN0LmNvdW50KysgPiBpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkKSB7XG5cdFx0XHRsZXQgcmVhZE9iamVjdCA9IHN0cnVjdHVyZS5yZWFkID0gKG5ldyBGdW5jdGlvbigncicsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gJyArIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhID8gJ09iamVjdC5mcmVlemUnIDogJycpICtcblx0XHRcdFx0Jyh7JyArIHN0cnVjdHVyZS5tYXAoa2V5ID0+IGtleSA9PT0gJ19fcHJvdG9fXycgPyAnX19wcm90b186cigpJyA6IHZhbGlkTmFtZS50ZXN0KGtleSkgPyBrZXkgKyAnOnIoKScgOiAoJ1snICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddOnIoKScpKS5qb2luKCcsJykgKyAnfSl9JykpKHJlYWQpO1xuXHRcdFx0aWYgKHN0cnVjdHVyZS5oaWdoQnl0ZSA9PT0gMClcblx0XHRcdFx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyKGZpcnN0SWQsIHN0cnVjdHVyZS5yZWFkKTtcblx0XHRcdHJldHVybiByZWFkT2JqZWN0KCkgLy8gc2Vjb25kIGJ5dGUgaXMgYWxyZWFkeSByZWFkLCBpZiB0aGVyZSBpcyBvbmUgc28gaW1tZWRpYXRlbHkgcmVhZCBvYmplY3Rcblx0XHR9XG5cdFx0bGV0IG9iamVjdCA9IHt9O1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGtleSA9IHN0cnVjdHVyZVtpXTtcblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0b2JqZWN0W2tleV0gPSByZWFkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcblx0XHRyZXR1cm4gb2JqZWN0XG5cdH1cblx0cmVhZE9iamVjdC5jb3VudCA9IDA7XG5cdGlmIChzdHJ1Y3R1cmUuaGlnaEJ5dGUgPT09IDApIHtcblx0XHRyZXR1cm4gY3JlYXRlU2Vjb25kQnl0ZVJlYWRlcihmaXJzdElkLCByZWFkT2JqZWN0KVxuXHR9XG5cdHJldHVybiByZWFkT2JqZWN0XG59XG5cbmNvbnN0IGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIgPSAoZmlyc3RJZCwgcmVhZDApID0+IHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGxldCBoaWdoQnl0ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmIChoaWdoQnl0ZSA9PT0gMClcblx0XHRcdHJldHVybiByZWFkMCgpXG5cdFx0bGV0IGlkID0gZmlyc3RJZCA8IDMyID8gLShmaXJzdElkICsgKGhpZ2hCeXRlIDw8IDUpKSA6IGZpcnN0SWQgKyAoaGlnaEJ5dGUgPDwgNSk7XG5cdFx0bGV0IHN0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXSB8fCBsb2FkU3RydWN0dXJlcygpW2lkXTtcblx0XHRpZiAoIXN0cnVjdHVyZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZWNvcmQgaWQgaXMgbm90IGRlZmluZWQgZm9yICcgKyBpZClcblx0XHR9XG5cdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZClcblx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZCk7XG5cdFx0cmV0dXJuIHN0cnVjdHVyZS5yZWFkKClcblx0fVxufTtcblxuZnVuY3Rpb24gbG9hZFN0cnVjdHVyZXMoKSB7XG5cdGxldCBsb2FkZWRTdHJ1Y3R1cmVzID0gc2F2ZVN0YXRlJDEoKCkgPT4ge1xuXHRcdC8vIHNhdmUgdGhlIHN0YXRlIGluIGNhc2UgZ2V0U3RydWN0dXJlcyBtb2RpZmllcyBvdXIgYnVmZmVyXG5cdFx0c3JjID0gbnVsbDtcblx0XHRyZXR1cm4gY3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcygpXG5cdH0pO1xuXHRyZXR1cm4gY3VycmVudFN0cnVjdHVyZXMgPSBjdXJyZW50VW5wYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGxvYWRlZFN0cnVjdHVyZXMsIGN1cnJlbnRTdHJ1Y3R1cmVzKVxufVxuXG52YXIgcmVhZEZpeGVkU3RyaW5nID0gcmVhZFN0cmluZ0pTO1xudmFyIHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZ0pTO1xudmFyIHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmdKUztcbnZhciByZWFkU3RyaW5nMzIgPSByZWFkU3RyaW5nSlM7XG5leHBvcnRzLmlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRFeHRyYWN0b3IoZXh0cmFjdFN0cmluZ3MpIHtcblx0ZXhwb3J0cy5pc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQgPSB0cnVlO1xuXHRyZWFkRml4ZWRTdHJpbmcgPSByZWFkU3RyaW5nKDEpO1xuXHRyZWFkU3RyaW5nOCA9IHJlYWRTdHJpbmcoMik7XG5cdHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmcoMyk7XG5cdHJlYWRTdHJpbmczMiA9IHJlYWRTdHJpbmcoNSk7XG5cdGZ1bmN0aW9uIHJlYWRTdHJpbmcoaGVhZGVyTGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlYWRTdHJpbmcobGVuZ3RoKSB7XG5cdFx0XHRsZXQgc3RyaW5nID0gc3RyaW5nc1tzdHJpbmdQb3NpdGlvbisrXTtcblx0XHRcdGlmIChzdHJpbmcgPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MkMSlcblx0XHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZ0pTKGxlbmd0aClcblx0XHRcdFx0bGV0IGJ5dGVPZmZzZXQgPSBzcmMuYnl0ZU9mZnNldDtcblx0XHRcdFx0bGV0IGV4dHJhY3Rpb24gPSBleHRyYWN0U3RyaW5ncyhwb3NpdGlvbiQxIC0gaGVhZGVyTGVuZ3RoICsgYnl0ZU9mZnNldCwgc3JjRW5kICsgYnl0ZU9mZnNldCwgc3JjLmJ1ZmZlcik7XG5cdFx0XHRcdGlmICh0eXBlb2YgZXh0cmFjdGlvbiA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHN0cmluZyA9IGV4dHJhY3Rpb247XG5cdFx0XHRcdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0cmluZ3MgPSBleHRyYWN0aW9uO1xuXHRcdFx0XHRcdHN0cmluZ1Bvc2l0aW9uID0gMTtcblx0XHRcdFx0XHRzcmNTdHJpbmdFbmQgPSAxOyAvLyBldmVuIGlmIGEgdXRmLTggc3RyaW5nIHdhcyBkZWNvZGVkLCBtdXN0IGluZGljYXRlIHdlIGFyZSBpbiB0aGUgbWlkc3Qgb2YgZXh0cmFjdGVkIHN0cmluZ3MgYW5kIGNhbid0IHNraXAgc3RyaW5nc1xuXHRcdFx0XHRcdHN0cmluZyA9IHN0cmluZ3NbMF07XG5cdFx0XHRcdFx0aWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXQgc3JjU3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdGlmIChzcmNTdHJpbmdMZW5ndGggPD0gbGVuZ3RoKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gbGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHR9XG5cdFx0XHRzcmNTdHJpbmcgPSBzdHJpbmc7XG5cdFx0XHRzcmNTdHJpbmdTdGFydCA9IHBvc2l0aW9uJDE7XG5cdFx0XHRzcmNTdHJpbmdFbmQgPSBwb3NpdGlvbiQxICsgc3JjU3RyaW5nTGVuZ3RoO1xuXHRcdFx0cG9zaXRpb24kMSArPSBsZW5ndGg7XG5cdFx0XHRyZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxlbmd0aCkgLy8gd2Uga25vdyB3ZSBqdXN0IHdhbnQgdGhlIGJlZ2lubmluZ1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gcmVhZFN0cmluZ0pTKGxlbmd0aCkge1xuXHRsZXQgcmVzdWx0O1xuXHRpZiAobGVuZ3RoIDwgMTYpIHtcblx0XHRpZiAocmVzdWx0ID0gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblx0aWYgKGxlbmd0aCA+IDY0ICYmIGRlY29kZXIpXG5cdFx0cmV0dXJuIGRlY29kZXIuZGVjb2RlKHNyYy5zdWJhcnJheShwb3NpdGlvbiQxLCBwb3NpdGlvbiQxICs9IGxlbmd0aCkpXG5cdGNvbnN0IGVuZCA9IHBvc2l0aW9uJDEgKyBsZW5ndGg7XG5cdGNvbnN0IHVuaXRzID0gW107XG5cdHJlc3VsdCA9ICcnO1xuXHR3aGlsZSAocG9zaXRpb24kMSA8IGVuZCkge1xuXHRcdGNvbnN0IGJ5dGUxID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09PSAwKSB7XG5cdFx0XHQvLyAxIGJ5dGVcblx0XHRcdHVuaXRzLnB1c2goYnl0ZTEpO1xuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhlMCkgPT09IDB4YzApIHtcblx0XHRcdC8vIDIgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0dW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMik7XG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuXHRcdFx0Ly8gMyBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzKTtcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZjgpID09PSAweGYwKSB7XG5cdFx0XHQvLyA0IGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0Y29uc3QgYnl0ZTQgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHRsZXQgdW5pdCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBjKSB8IChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKHVuaXQgPiAweGZmZmYpIHtcblx0XHRcdFx0dW5pdCAtPSAweDEwMDAwO1xuXHRcdFx0XHR1bml0cy5wdXNoKCgodW5pdCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcblx0XHRcdFx0dW5pdCA9IDB4ZGMwMCB8ICh1bml0ICYgMHgzZmYpO1xuXHRcdFx0fVxuXHRcdFx0dW5pdHMucHVzaCh1bml0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dW5pdHMucHVzaChieXRlMSk7XG5cdFx0fVxuXG5cdFx0aWYgKHVuaXRzLmxlbmd0aCA+PSAweDEwMDApIHtcblx0XHRcdHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG5cdFx0XHR1bml0cy5sZW5ndGggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG5cdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHRcbn1cbmZ1bmN0aW9uIHJlYWRTdHJpbmcoc291cmNlLCBzdGFydCwgbGVuZ3RoKSB7XG5cdGxldCBleGlzdGluZ1NyYyA9IHNyYztcblx0c3JjID0gc291cmNlO1xuXHRwb3NpdGlvbiQxID0gc3RhcnQ7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNyYyA9IGV4aXN0aW5nU3JjO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheShsZW5ndGgpIHtcblx0bGV0IGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcnJheVtpXSA9IHJlYWQoKTtcblx0fVxuXHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShhcnJheSlcblx0cmV0dXJuIGFycmF5XG59XG5cbmZ1bmN0aW9uIHJlYWRNYXAobGVuZ3RoKSB7XG5cdGlmIChjdXJyZW50VW5wYWNrci5tYXBzQXNPYmplY3RzKSB7XG5cdFx0bGV0IG9iamVjdCA9IHt9O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBrZXkgPSByZWFkS2V5KCk7XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqZWN0XG5cdH0gZWxzZSB7XG5cdFx0bGV0IG1hcCA9IG5ldyBNYXAoKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG59XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuZnVuY3Rpb24gbG9uZ1N0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGxldCBzdGFydCA9IHBvc2l0aW9uJDE7XG5cdGxldCBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgYnl0ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmICgoYnl0ZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ynl0ZXNbaV0gPSBieXRlO1xuXHRcdH1cblx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYnl0ZXMpXG59XG5mdW5jdGlvbiBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGlmIChsZW5ndGggPCA0KSB7XG5cdFx0aWYgKGxlbmd0aCA8IDIpIHtcblx0XHRcdGlmIChsZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiAnJ1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoYSAmIDB4ODApID4gMSkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gMjtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiKVxuXHRcdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoYyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDM7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGxldCBiID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRsZXQgZCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCB8fCAoYyAmIDB4ODApID4gMCB8fCAoZCAmIDB4ODApID4gMCkge1xuXHRcdFx0cG9zaXRpb24kMSAtPSA0O1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmIChsZW5ndGggPCA2KSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSA0KVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKChlICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24kMSAtPSA1O1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSlcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDgpIHtcblx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgZiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gNjtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgNylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmKVxuXHRcdFx0bGV0IGcgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoZyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDc7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgaCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwIHx8IChnICYgMHg4MCkgPiAwIHx8IChoICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gODtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMTApIHtcblx0XHRcdFx0aWYgKGxlbmd0aCA9PT0gOClcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDk7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDEyKSB7XG5cdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGxldCBqID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCB8fCAoaiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTA7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxlbmd0aCA8IDExKVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgailcblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKChrICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxMTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGspXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgayA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgbCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDAgfHwgKGsgJiAweDgwKSA+IDAgfHwgKGwgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDEyO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxNCkge1xuXHRcdFx0XHRcdGlmIChsZW5ndGggPT09IDEyKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDEzO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRsZXQgbiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCB8fCAobiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxNDtcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobGVuZ3RoIDwgMTUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4pXG5cdFx0XHRcdFx0bGV0IG8gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRpZiAoKG8gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTU7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRPbmx5SlNTdHJpbmcoKSB7XG5cdGxldCB0b2tlbiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRsZXQgbGVuZ3RoO1xuXHRpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGVuZ3RoID0gdG9rZW4gLSAweGEwO1xuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0Ly8gc3RyIDhcblx0XHRcdFx0bGVuZ3RoID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGE6XG5cdFx0XHQvLyBzdHIgMTZcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGI6XG5cdFx0XHQvLyBzdHIgMzJcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0cmluZycpXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRCaW4obGVuZ3RoKSB7XG5cdHJldHVybiBjdXJyZW50VW5wYWNrci5jb3B5QnVmZmVycyA/XG5cdFx0Ly8gc3BlY2lmaWNhbGx5IHVzZSB0aGUgY29weWluZyBzbGljZSAobm90IHRoZSBub2RlIG9uZSlcblx0XHRVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24kMSwgcG9zaXRpb24kMSArPSBsZW5ndGgpIDpcblx0XHRzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgcG9zaXRpb24kMSArPSBsZW5ndGgpXG59XG5mdW5jdGlvbiByZWFkRXh0KGxlbmd0aCkge1xuXHRsZXQgdHlwZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRpZiAoY3VycmVudEV4dGVuc2lvbnNbdHlwZV0pIHtcblx0XHRsZXQgZW5kO1xuXHRcdHJldHVybiBjdXJyZW50RXh0ZW5zaW9uc1t0eXBlXShzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgZW5kID0gKHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSksIChyZWFkUG9zaXRpb24pID0+IHtcblx0XHRcdHBvc2l0aW9uJDEgPSByZWFkUG9zaXRpb247XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gcmVhZCgpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0cG9zaXRpb24kMSA9IGVuZDtcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cdGVsc2Vcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uIHR5cGUgJyArIHR5cGUpXG59XG5cbnZhciBrZXlDYWNoZSA9IG5ldyBBcnJheSg0MDk2KTtcbmZ1bmN0aW9uIHJlYWRLZXkoKSB7XG5cdGxldCBsZW5ndGggPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0aWYgKGxlbmd0aCA+PSAweGEwICYmIGxlbmd0aCA8IDB4YzApIHtcblx0XHQvLyBmaXhzdHIsIHBvdGVudGlhbGx5IHVzZSBrZXkgY2FjaGVcblx0XHRsZW5ndGggPSBsZW5ndGggLSAweGEwO1xuXHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkgLy8gaWYgaXQgaGFzIGJlZW4gZXh0cmFjdGVkLCBtdXN0IHVzZSBpdCAoYW5kIGZhc3RlciBhbnl3YXkpXG5cdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdGVsc2UgaWYgKCEoc3JjU3RyaW5nRW5kID09IDAgJiYgc3JjRW5kIDwgMTgwKSlcblx0XHRcdHJldHVybiByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKVxuXHR9IGVsc2UgeyAvLyBub3QgY2FjaGVhYmxlLCBnbyBiYWNrIGFuZCBkbyBhIHN0YW5kYXJkIHJlYWRcblx0XHRwb3NpdGlvbiQxLS07XG5cdFx0cmV0dXJuIGFzU2FmZVN0cmluZyhyZWFkKCkpXG5cdH1cblx0bGV0IGtleSA9ICgobGVuZ3RoIDw8IDUpIF4gKGxlbmd0aCA+IDEgPyBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSkgOiBsZW5ndGggPiAwID8gc3JjW3Bvc2l0aW9uJDFdIDogMCkpICYgMHhmZmY7XG5cdGxldCBlbnRyeSA9IGtleUNhY2hlW2tleV07XG5cdGxldCBjaGVja1Bvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0bGV0IGVuZCA9IHBvc2l0aW9uJDEgKyBsZW5ndGggLSAzO1xuXHRsZXQgY2h1bms7XG5cdGxldCBpID0gMDtcblx0aWYgKGVudHJ5ICYmIGVudHJ5LmJ5dGVzID09IGxlbmd0aCkge1xuXHRcdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKTtcblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tQb3NpdGlvbiArPSA0O1xuXHRcdH1cblx0XHRlbmQgKz0gMztcblx0XHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXTtcblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2hlY2tQb3NpdGlvbiA9PT0gZW5kKSB7XG5cdFx0XHRwb3NpdGlvbiQxID0gY2hlY2tQb3NpdGlvbjtcblx0XHRcdHJldHVybiBlbnRyeS5zdHJpbmdcblx0XHR9XG5cdFx0ZW5kIC09IDM7XG5cdFx0Y2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdH1cblx0ZW50cnkgPSBbXTtcblx0a2V5Q2FjaGVba2V5XSA9IGVudHJ5O1xuXHRlbnRyeS5ieXRlcyA9IGxlbmd0aDtcblx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKTtcblx0XHRlbnRyeS5wdXNoKGNodW5rKTtcblx0XHRjaGVja1Bvc2l0aW9uICs9IDQ7XG5cdH1cblx0ZW5kICs9IDM7XG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXTtcblx0XHRlbnRyeS5wdXNoKGNodW5rKTtcblx0fVxuXHQvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG5cdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKTtcblx0aWYgKHN0cmluZyAhPSBudWxsKVxuXHRcdHJldHVybiBlbnRyeS5zdHJpbmcgPSBzdHJpbmdcblx0cmV0dXJuIGVudHJ5LnN0cmluZyA9IHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzU2FmZVN0cmluZyhwcm9wZXJ0eSkge1xuXHQvLyBwcm90ZWN0IGFnYWluc3QgZXhwZW5zaXZlIChEb1MpIHN0cmluZyBjb252ZXJzaW9uc1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykgcmV0dXJuIHByb3BlcnR5O1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdiaWdpbnQnKSByZXR1cm4gcHJvcGVydHkudG9TdHJpbmcoKTtcblx0aWYgKHByb3BlcnR5ID09IG51bGwpIHJldHVybiBwcm9wZXJ0eSArICcnO1xuXHRpZiAoY3VycmVudFVucGFja3IuYWxsb3dBcnJheXNJbk1hcEtleXMgJiYgQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkgJiYgcHJvcGVydHkuZmxhdCgpLmV2ZXJ5KGl0ZW0gPT4gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnYmlnaW50J10uaW5jbHVkZXModHlwZW9mIGl0ZW0pKSkge1xuXHRcdHJldHVybiBwcm9wZXJ0eS5mbGF0KCkudG9TdHJpbmcoKTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJvcGVydHkgdHlwZSBmb3IgcmVjb3JkOiAke3R5cGVvZiBwcm9wZXJ0eX1gKTtcbn1cbi8vIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIHJlY29yZCBkZWZpbml0aW9uIGV4dGVuc2lvbiAoYXMgXCJyXCIpXG5jb25zdCByZWNvcmREZWZpbml0aW9uID0gKGlkLCBoaWdoQnl0ZSkgPT4ge1xuXHRsZXQgc3RydWN0dXJlID0gcmVhZCgpLm1hcChhc1NhZmVTdHJpbmcpOyAvLyBlbnN1cmUgdGhhdCBhbGwga2V5cyBhcmUgc3RyaW5ncyBhbmRcblx0Ly8gdGhhdCB0aGUgYXJyYXkgaXMgbXV0YWJsZVxuXHRsZXQgZmlyc3RCeXRlID0gaWQ7XG5cdGlmIChoaWdoQnl0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWQgPSBpZCA8IDMyID8gLSgoaGlnaEJ5dGUgPDwgNSkgKyBpZCkgOiAoKGhpZ2hCeXRlIDw8IDUpICsgaWQpO1xuXHRcdHN0cnVjdHVyZS5oaWdoQnl0ZSA9IGhpZ2hCeXRlO1xuXHR9XG5cdGxldCBleGlzdGluZ1N0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXTtcblx0Ly8gSWYgaXQgaXMgYSBzaGFyZWQgc3RydWN0dXJlLCB3ZSBuZWVkIHRvIHJlc3RvcmUgYW55IGNoYW5nZXMgYWZ0ZXIgcmVhZGluZy5cblx0Ly8gQWxzbyBpbiBzZXF1ZW50aWFsIG1vZGUsIHdlIG1heSBnZXQgaW5jb21wbGV0ZSByZWFkcyBhbmQgdGh1cyBlcnJvcnMsIGFuZCB3ZSBuZWVkIHRvIHJlc3RvcmVcblx0Ly8gdG8gdGhlIHN0YXRlIHByaW9yIHRvIGFuIGluY29tcGxldGUgcmVhZCBpbiBvcmRlciB0byBwcm9wZXJseSByZXN1bWUuXG5cdGlmIChleGlzdGluZ1N0cnVjdHVyZSAmJiAoZXhpc3RpbmdTdHJ1Y3R1cmUuaXNTaGFyZWQgfHwgc2VxdWVudGlhbE1vZGUpKSB7XG5cdFx0KGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gZXhpc3RpbmdTdHJ1Y3R1cmU7XG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gc3RydWN0dXJlO1xuXHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIGZpcnN0Qnl0ZSk7XG5cdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG59O1xuY3VycmVudEV4dGVuc2lvbnNbMF0gPSAoKSA9PiB7fTsgLy8gbm90ZXBhY2sgZGVmaW5lcyBleHRlbnNpb24gMCB0byBtZWFuIHVuZGVmaW5lZCwgc28gdXNlIHRoYXQgYXMgdGhlIGRlZmF1bHQgaGVyZVxuY3VycmVudEV4dGVuc2lvbnNbMF0ubm9CdWZmZXIgPSB0cnVlO1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDQyXSA9IGRhdGEgPT4ge1xuXHRsZXQgaGVhZExlbmd0aCA9IChkYXRhLmJ5dGVMZW5ndGggJSA4KSB8fCA4O1xuXHRsZXQgaGVhZCA9IEJpZ0ludChkYXRhWzBdICYgMHg4MCA/IGRhdGFbMF0gLSAweDEwMCA6IGRhdGFbMF0pO1xuXHRmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRMZW5ndGg7IGkrKykge1xuXHRcdGhlYWQgPDw9IEJpZ0ludCg4KTtcblx0XHRoZWFkICs9IEJpZ0ludChkYXRhW2ldKTtcblx0fVxuXHRpZiAoZGF0YS5ieXRlTGVuZ3RoICE9PSBoZWFkTGVuZ3RoKSB7XG5cdFx0bGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcblx0XHRsZXQgZGVjb2RlID0gKHN0YXJ0LCBlbmQpID0+IHtcblx0XHRcdGxldCBsZW5ndGggPSBlbmQgLSBzdGFydDtcblx0XHRcdGlmIChsZW5ndGggPD0gNDApIHtcblx0XHRcdFx0bGV0IG91dCA9IHZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0KTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0ICsgODsgaSA8IGVuZDsgaSArPSA4KSB7XG5cdFx0XHRcdFx0b3V0IDw8PSBCaWdJbnQoNjRuKTtcblx0XHRcdFx0XHRvdXQgfD0gdmlldy5nZXRCaWdVaW50NjQoaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG91dFxuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgKGxlbmd0aCA9PT0gOCkgcmV0dXJuIHZpZXcuZ2V0QmlnVWludDY0KHN0YXJ0KVxuXHRcdFx0bGV0IG1pZGRsZSA9IHN0YXJ0ICsgKGxlbmd0aCA+PiA0IDw8IDMpO1xuXHRcdFx0bGV0IGxlZnQgPSBkZWNvZGUoc3RhcnQsIG1pZGRsZSk7XG5cdFx0XHRsZXQgcmlnaHQgPSBkZWNvZGUobWlkZGxlLCBlbmQpO1xuXHRcdFx0cmV0dXJuIChsZWZ0IDw8IEJpZ0ludCgoZW5kIC0gbWlkZGxlKSAqIDgpKSB8IHJpZ2h0XG5cdFx0fTtcblx0XHRoZWFkID0gKGhlYWQgPDwgQmlnSW50KCh2aWV3LmJ5dGVMZW5ndGggLSBoZWFkTGVuZ3RoKSAqIDgpKSB8IGRlY29kZShoZWFkTGVuZ3RoLCB2aWV3LmJ5dGVMZW5ndGgpO1xuXHR9XG5cdHJldHVybiBoZWFkXG59O1xuXG5sZXQgZXJyb3JzID0ge1xuXHRFcnJvciwgRXZhbEVycm9yLCBSYW5nZUVycm9yLCBSZWZlcmVuY2VFcnJvciwgU3ludGF4RXJyb3IsIFR5cGVFcnJvciwgVVJJRXJyb3IsIEFnZ3JlZ2F0ZUVycm9yOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICdmdW5jdGlvbicgPyBBZ2dyZWdhdGVFcnJvciA6IG51bGwsXG59O1xuY3VycmVudEV4dGVuc2lvbnNbMHg2NV0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpO1xuXHRpZiAoIWVycm9yc1tkYXRhWzBdXSkge1xuXHRcdGxldCBlcnJvciA9IEVycm9yKGRhdGFbMV0sIHsgY2F1c2U6IGRhdGFbMl0gfSk7XG5cdFx0ZXJyb3IubmFtZSA9IGRhdGFbMF07XG5cdFx0cmV0dXJuIGVycm9yXG5cdH1cblx0cmV0dXJuIGVycm9yc1tkYXRhWzBdXShkYXRhWzFdLCB7IGNhdXNlOiBkYXRhWzJdIH0pXG59O1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDY5XSA9IChkYXRhKSA9PiB7XG5cdC8vIGlkIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxIC0gNCk7XG5cdGlmICghcmVmZXJlbmNlTWFwKVxuXHRcdHJlZmVyZW5jZU1hcCA9IG5ldyBNYXAoKTtcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uJDFdO1xuXHRsZXQgdGFyZ2V0O1xuXHQvLyBUT0RPOiBoYW5kbGUgYW55IG90aGVyIHR5cGVzIHRoYXQgY2FuIGN5Y2xlIGFuZCBtYWtlIHRoZSBjb2RlIG1vcmUgcm9idXN0IGlmIHRoZXJlIGFyZSBvdGhlciBleHRlbnNpb25zXG5cdGlmICh0b2tlbiA+PSAweDkwICYmIHRva2VuIDwgMHhhMCB8fCB0b2tlbiA9PSAweGRjIHx8IHRva2VuID09IDB4ZGQpXG5cdFx0dGFyZ2V0ID0gW107XG5cdGVsc2UgaWYgKHRva2VuID49IDB4ODAgJiYgdG9rZW4gPCAweDkwIHx8IHRva2VuID09IDB4ZGUgfHwgdG9rZW4gPT0gMHhkZilcblx0XHR0YXJnZXQgPSBuZXcgTWFwKCk7XG5cdGVsc2UgaWYgKCh0b2tlbiA+PSAweGM3ICYmIHRva2VuIDw9IDB4YzkgfHwgdG9rZW4gPj0gMHhkNCAmJiB0b2tlbiA8PSAweGQ4KSAmJiBzcmNbcG9zaXRpb24kMSArIDFdID09PSAweDczKVxuXHRcdHRhcmdldCA9IG5ldyBTZXQoKTtcblx0ZWxzZVxuXHRcdHRhcmdldCA9IHt9O1xuXG5cdGxldCByZWZFbnRyeSA9IHsgdGFyZ2V0IH07IC8vIGEgcGxhY2Vob2xkZXIgb2JqZWN0XG5cdHJlZmVyZW5jZU1hcC5zZXQoaWQsIHJlZkVudHJ5KTtcblx0bGV0IHRhcmdldFByb3BlcnRpZXMgPSByZWFkKCk7IC8vIHJlYWQgdGhlIG5leHQgdmFsdWUgYXMgdGhlIHRhcmdldCBvYmplY3QgdG8gaWRcblx0aWYgKCFyZWZFbnRyeS51c2VkKSB7XG5cdFx0Ly8gbm8gY3ljbGUsIGNhbiBqdXN0IHVzZSB0aGUgcmV0dXJuZWQgcmVhZCBvYmplY3Rcblx0XHRyZXR1cm4gcmVmRW50cnkudGFyZ2V0ID0gdGFyZ2V0UHJvcGVydGllcyAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHRoZSByZWFsIG9uZVxuXHR9IGVsc2Uge1xuXHRcdC8vIHRoZXJlIGlzIGEgY3ljbGUsIHNvIHdlIGhhdmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gb3JpZ2luYWwgdGFyZ2V0XG5cdFx0T2JqZWN0LmFzc2lnbih0YXJnZXQsIHRhcmdldFByb3BlcnRpZXMpO1xuXHR9XG5cblx0Ly8gY29weSBvdmVyIG1hcC9zZXQgZW50cmllcyBpZiB3ZSdyZSBhYmxlIHRvXG5cdGlmICh0YXJnZXQgaW5zdGFuY2VvZiBNYXApXG5cdFx0Zm9yIChsZXQgW2ssIHZdIG9mIHRhcmdldFByb3BlcnRpZXMuZW50cmllcygpKSB0YXJnZXQuc2V0KGssIHYpO1xuXHRpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2V0KVxuXHRcdGZvciAobGV0IGkgb2YgQXJyYXkuZnJvbSh0YXJnZXRQcm9wZXJ0aWVzKSkgdGFyZ2V0LmFkZChpKTtcblx0cmV0dXJuIHRhcmdldFxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHg3MF0gPSAoZGF0YSkgPT4ge1xuXHQvLyBwb2ludGVyIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxIC0gNCk7XG5cdGxldCByZWZFbnRyeSA9IHJlZmVyZW5jZU1hcC5nZXQoaWQpO1xuXHRyZWZFbnRyeS51c2VkID0gdHJ1ZTtcblx0cmV0dXJuIHJlZkVudHJ5LnRhcmdldFxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHg3M10gPSAoKSA9PiBuZXcgU2V0KHJlYWQoKSk7XG5cbmNvbnN0IHR5cGVkQXJyYXlzID0gWydJbnQ4JywnVWludDgnLCdVaW50OENsYW1wZWQnLCdJbnQxNicsJ1VpbnQxNicsJ0ludDMyJywnVWludDMyJywnRmxvYXQzMicsJ0Zsb2F0NjQnLCdCaWdJbnQ2NCcsJ0JpZ1VpbnQ2NCddLm1hcCh0eXBlID0+IHR5cGUgKyAnQXJyYXknKTtcblxubGV0IGdsYmwgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3NF0gPSAoZGF0YSkgPT4ge1xuXHRsZXQgdHlwZUNvZGUgPSBkYXRhWzBdO1xuXHQvLyB3ZSBhbHdheXMgaGF2ZSB0byBzbGljZSB0byBnZXQgYSBuZXcgQXJyYXlCdWZmZXIgdGhhdCBpcyBhbGlnbmVkXG5cdGxldCBidWZmZXIgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEsIDEpLmJ1ZmZlcjtcblxuXHRsZXQgdHlwZWRBcnJheU5hbWUgPSB0eXBlZEFycmF5c1t0eXBlQ29kZV07XG5cdGlmICghdHlwZWRBcnJheU5hbWUpIHtcblx0XHRpZiAodHlwZUNvZGUgPT09IDE2KSByZXR1cm4gYnVmZmVyXG5cdFx0aWYgKHR5cGVDb2RlID09PSAxNykgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eXBlZCBhcnJheSBmb3IgY29kZSAnICsgdHlwZUNvZGUpXG5cdH1cblx0cmV0dXJuIG5ldyBnbGJsW3R5cGVkQXJyYXlOYW1lXShidWZmZXIpXG59O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3OF0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpO1xuXHRyZXR1cm4gbmV3IFJlZ0V4cChkYXRhWzBdLCBkYXRhWzFdKVxufTtcbmNvbnN0IFRFTVBfQlVORExFID0gW107XG5jdXJyZW50RXh0ZW5zaW9uc1sweDYyXSA9IChkYXRhKSA9PiB7XG5cdGxldCBkYXRhU2l6ZSA9IChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXTtcblx0bGV0IGRhdGFQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdHBvc2l0aW9uJDEgKz0gZGF0YVNpemUgLSBkYXRhLmxlbmd0aDtcblx0YnVuZGxlZFN0cmluZ3MkMSA9IFRFTVBfQlVORExFO1xuXHRidW5kbGVkU3RyaW5ncyQxID0gW3JlYWRPbmx5SlNTdHJpbmcoKSwgcmVhZE9ubHlKU1N0cmluZygpXTtcblx0YnVuZGxlZFN0cmluZ3MkMS5wb3NpdGlvbjAgPSAwO1xuXHRidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMSA9IDA7XG5cdGJ1bmRsZWRTdHJpbmdzJDEucG9zdEJ1bmRsZVBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0cG9zaXRpb24kMSA9IGRhdGFQb3NpdGlvbjtcblx0cmV0dXJuIHJlYWQoKVxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHhmZl0gPSAoZGF0YSkgPT4ge1xuXHQvLyAzMi1iaXQgZGF0ZSBleHRlbnNpb25cblx0aWYgKGRhdGEubGVuZ3RoID09IDQpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKChkYXRhWzBdICogMHgxMDAwMDAwICsgKGRhdGFbMV0gPDwgMTYpICsgKGRhdGFbMl0gPDwgOCkgKyBkYXRhWzNdKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDgpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDIyKSArIChkYXRhWzFdIDw8IDE0KSArIChkYXRhWzJdIDw8IDYpICsgKGRhdGFbM10gPj4gMikpIC8gMTAwMDAwMCArXG5cdFx0XHQoKGRhdGFbM10gJiAweDMpICogMHgxMDAwMDAwMDAgKyBkYXRhWzRdICogMHgxMDAwMDAwICsgKGRhdGFbNV0gPDwgMTYpICsgKGRhdGFbNl0gPDwgOCkgKyBkYXRhWzddKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDEyKVxuXHRcdHJldHVybiBuZXcgRGF0ZShcblx0XHRcdCgoZGF0YVswXSA8PCAyNCkgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pIC8gMTAwMDAwMCArXG5cdFx0XHQoKChkYXRhWzRdICYgMHg4MCkgPyAtMHgxMDAwMDAwMDAwMDAwIDogMCkgKyBkYXRhWzZdICogMHgxMDAwMDAwMDAwMCArIGRhdGFbN10gKiAweDEwMDAwMDAwMCArIGRhdGFbOF0gKiAweDEwMDAwMDAgKyAoZGF0YVs5XSA8PCAxNikgKyAoZGF0YVsxMF0gPDwgOCkgKyBkYXRhWzExXSkgKiAxMDAwKVxuXHRlbHNlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCdpbnZhbGlkJylcbn07XG4vLyByZWdpc3RyYXRpb24gb2YgYnVsayByZWNvcmQgZGVmaW5pdGlvbj9cbi8vIGN1cnJlbnRFeHRlbnNpb25zWzB4NTJdID0gKCkgPT5cblxuZnVuY3Rpb24gc2F2ZVN0YXRlJDEoY2FsbGJhY2spIHtcblx0aWYgKG9uU2F2ZVN0YXRlKVxuXHRcdG9uU2F2ZVN0YXRlKCk7XG5cdGxldCBzYXZlZFNyY0VuZCA9IHNyY0VuZDtcblx0bGV0IHNhdmVkUG9zaXRpb24gPSBwb3NpdGlvbiQxO1xuXHRsZXQgc2F2ZWRTdHJpbmdQb3NpdGlvbiA9IHN0cmluZ1Bvc2l0aW9uO1xuXHRsZXQgc2F2ZWRTcmNTdHJpbmdTdGFydCA9IHNyY1N0cmluZ1N0YXJ0O1xuXHRsZXQgc2F2ZWRTcmNTdHJpbmdFbmQgPSBzcmNTdHJpbmdFbmQ7XG5cdGxldCBzYXZlZFNyY1N0cmluZyA9IHNyY1N0cmluZztcblx0bGV0IHNhdmVkU3RyaW5ncyA9IHN0cmluZ3M7XG5cdGxldCBzYXZlZFJlZmVyZW5jZU1hcCA9IHJlZmVyZW5jZU1hcDtcblx0bGV0IHNhdmVkQnVuZGxlZFN0cmluZ3MgPSBidW5kbGVkU3RyaW5ncyQxO1xuXG5cdC8vIFRPRE86IFdlIG1heSBuZWVkIHRvIHJldmlzaXQgdGhpcyBpZiB3ZSBkbyBtb3JlIGV4dGVybmFsIGNhbGxzIHRvIHVzZXIgY29kZSAoc2luY2UgaXQgY291bGQgYmUgc2xvdylcblx0bGV0IHNhdmVkU3JjID0gbmV3IFVpbnQ4QXJyYXkoc3JjLnNsaWNlKDAsIHNyY0VuZCkpOyAvLyB3ZSBjb3B5IHRoZSBkYXRhIGluIGNhc2UgaXQgY2hhbmdlcyB3aGlsZSBleHRlcm5hbCBkYXRhIGlzIHByb2Nlc3NlZFxuXHRsZXQgc2F2ZWRTdHJ1Y3R1cmVzID0gY3VycmVudFN0cnVjdHVyZXM7XG5cdGxldCBzYXZlZFN0cnVjdHVyZXNDb250ZW50cyA9IGN1cnJlbnRTdHJ1Y3R1cmVzLnNsaWNlKDAsIGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCk7XG5cdGxldCBzYXZlZFBhY2tyID0gY3VycmVudFVucGFja3I7XG5cdGxldCBzYXZlZFNlcXVlbnRpYWxNb2RlID0gc2VxdWVudGlhbE1vZGU7XG5cdGxldCB2YWx1ZSA9IGNhbGxiYWNrKCk7XG5cdHNyY0VuZCA9IHNhdmVkU3JjRW5kO1xuXHRwb3NpdGlvbiQxID0gc2F2ZWRQb3NpdGlvbjtcblx0c3RyaW5nUG9zaXRpb24gPSBzYXZlZFN0cmluZ1Bvc2l0aW9uO1xuXHRzcmNTdHJpbmdTdGFydCA9IHNhdmVkU3JjU3RyaW5nU3RhcnQ7XG5cdHNyY1N0cmluZ0VuZCA9IHNhdmVkU3JjU3RyaW5nRW5kO1xuXHRzcmNTdHJpbmcgPSBzYXZlZFNyY1N0cmluZztcblx0c3RyaW5ncyA9IHNhdmVkU3RyaW5ncztcblx0cmVmZXJlbmNlTWFwID0gc2F2ZWRSZWZlcmVuY2VNYXA7XG5cdGJ1bmRsZWRTdHJpbmdzJDEgPSBzYXZlZEJ1bmRsZWRTdHJpbmdzO1xuXHRzcmMgPSBzYXZlZFNyYztcblx0c2VxdWVudGlhbE1vZGUgPSBzYXZlZFNlcXVlbnRpYWxNb2RlO1xuXHRjdXJyZW50U3RydWN0dXJlcyA9IHNhdmVkU3RydWN0dXJlcztcblx0Y3VycmVudFN0cnVjdHVyZXMuc3BsaWNlKDAsIGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCwgLi4uc2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMpO1xuXHRjdXJyZW50VW5wYWNrciA9IHNhdmVkUGFja3I7XG5cdGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCk7XG5cdHJldHVybiB2YWx1ZVxufVxuZnVuY3Rpb24gY2xlYXJTb3VyY2UoKSB7XG5cdHNyYyA9IG51bGw7XG5cdHJlZmVyZW5jZU1hcCA9IG51bGw7XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWRkRXh0ZW5zaW9uJDEoZXh0ZW5zaW9uKSB7XG5cdGlmIChleHRlbnNpb24udW5wYWNrKVxuXHRcdGN1cnJlbnRFeHRlbnNpb25zW2V4dGVuc2lvbi50eXBlXSA9IGV4dGVuc2lvbi51bnBhY2s7XG5cdGVsc2Vcblx0XHRjdXJyZW50RXh0ZW5zaW9uc1tleHRlbnNpb24udHlwZV0gPSBleHRlbnNpb247XG59XG5cbmNvbnN0IG11bHQxMCA9IG5ldyBBcnJheSgxNDcpOyAvLyB0aGlzIGlzIGEgdGFibGUgbWF0Y2hpbmcgYmluYXJ5IGV4cG9uZW50cyB0byB0aGUgbXVsdGlwbGllciB0byBkZXRlcm1pbmUgc2lnbmlmaWNhbnQgZGlnaXQgcm91bmRpbmdcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0bXVsdDEwW2ldID0gKygnMWUnICsgTWF0aC5mbG9vcig0NS4xNSAtIGkgKiAwLjMwMTAzKSk7XG59XG5jb25zdCBEZWNvZGVyID0gVW5wYWNrcjtcbnZhciBkZWZhdWx0VW5wYWNrciA9IG5ldyBVbnBhY2tyKHsgdXNlUmVjb3JkczogZmFsc2UgfSk7XG5jb25zdCB1bnBhY2sgPSBkZWZhdWx0VW5wYWNrci51bnBhY2s7XG5jb25zdCB1bnBhY2tNdWx0aXBsZSA9IGRlZmF1bHRVbnBhY2tyLnVucGFja011bHRpcGxlO1xuY29uc3QgZGVjb2RlID0gZGVmYXVsdFVucGFja3IudW5wYWNrO1xuY29uc3QgRkxPQVQzMl9PUFRJT05TID0ge1xuXHRORVZFUjogMCxcblx0QUxXQVlTOiAxLFxuXHRERUNJTUFMX1JPVU5EOiAzLFxuXHRERUNJTUFMX0ZJVDogNFxufTtcbmxldCBmMzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5sZXQgdThBcnJheSA9IG5ldyBVaW50OEFycmF5KGYzMkFycmF5LmJ1ZmZlciwgMCwgNCk7XG5mdW5jdGlvbiByb3VuZEZsb2F0MzIoZmxvYXQzMk51bWJlcikge1xuXHRmMzJBcnJheVswXSA9IGZsb2F0MzJOdW1iZXI7XG5cdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygodThBcnJheVszXSAmIDB4N2YpIDw8IDEpIHwgKHU4QXJyYXlbMl0gPj4gNyldO1xuXHRyZXR1cm4gKChtdWx0aXBsaWVyICogZmxvYXQzMk51bWJlciArIChmbG9hdDMyTnVtYmVyID4gMCA/IDAuNSA6IC0wLjUpKSA+PiAwKSAvIG11bHRpcGxpZXJcbn1cbmZ1bmN0aW9uIHNldFJlYWRTdHJ1Y3QodXBkYXRlZFJlYWRTdHJ1Y3QsIGxvYWRlZFN0cnVjdHMsIHNhdmVTdGF0ZSkge1xuXHRyZWFkU3RydWN0JDEgPSB1cGRhdGVkUmVhZFN0cnVjdDtcblx0b25Mb2FkZWRTdHJ1Y3R1cmVzJDEgPSBsb2FkZWRTdHJ1Y3RzO1xuXHRvblNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbn1cblxubGV0IHRleHRFbmNvZGVyJDE7XG50cnkge1xuXHR0ZXh0RW5jb2RlciQxID0gbmV3IFRleHRFbmNvZGVyKCk7XG59IGNhdGNoIChlcnJvcikge31cbmxldCBleHRlbnNpb25zLCBleHRlbnNpb25DbGFzc2VzO1xuY29uc3QgaGFzTm9kZUJ1ZmZlciQxID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBCeXRlQXJyYXlBbGxvY2F0ZSA9IGhhc05vZGVCdWZmZXIkMSA/XG5cdGZ1bmN0aW9uKGxlbmd0aCkgeyByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhsZW5ndGgpIH0gOiBVaW50OEFycmF5O1xuY29uc3QgQnl0ZUFycmF5ID0gaGFzTm9kZUJ1ZmZlciQxID8gQnVmZmVyIDogVWludDhBcnJheTtcbmNvbnN0IE1BWF9CVUZGRVJfU0laRSA9IGhhc05vZGVCdWZmZXIkMSA/IDB4MTAwMDAwMDAwIDogMHg3ZmQwMDAwMDtcbmxldCB0YXJnZXQsIGtleXNUYXJnZXQ7XG5sZXQgdGFyZ2V0VmlldztcbmxldCBwb3NpdGlvbiA9IDA7XG5sZXQgc2FmZUVuZDtcbmxldCBidW5kbGVkU3RyaW5ncyA9IG51bGw7XG5sZXQgd3JpdGVTdHJ1Y3RTbG90cztcbmNvbnN0IE1BWF9CVU5ETEVfU0laRSA9IDB4NTUwMDsgLy8gbWF4aW11bSBjaGFyYWN0ZXJzIHN1Y2ggdGhhdCB0aGUgZW5jb2RlZCBieXRlcyBmaXRzIGluIDE2IGJpdHMuXG5jb25zdCBoYXNOb25MYXRpbiA9IC9bXFx1MDA4MC1cXHVGRkZGXS87XG5jb25zdCBSRUNPUkRfU1lNQk9MID0gU3ltYm9sKCdyZWNvcmQtaWQnKTtcbmNsYXNzIFBhY2tyIGV4dGVuZHMgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0XHR0aGlzLm9mZnNldCA9IDA7XG5cdFx0bGV0IHN0YXJ0O1xuXHRcdGxldCBoYXNTaGFyZWRVcGRhdGU7XG5cdFx0bGV0IHN0cnVjdHVyZXM7XG5cdFx0bGV0IHJlZmVyZW5jZU1hcDtcblx0XHRsZXQgZW5jb2RlVXRmOCA9IEJ5dGVBcnJheS5wcm90b3R5cGUudXRmOFdyaXRlID8gZnVuY3Rpb24oc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRhcmdldC51dGY4V3JpdGUoc3RyaW5nLCBwb3NpdGlvbiwgdGFyZ2V0LmJ5dGVMZW5ndGggLSBwb3NpdGlvbilcblx0XHR9IDogKHRleHRFbmNvZGVyJDEgJiYgdGV4dEVuY29kZXIkMS5lbmNvZGVJbnRvKSA/XG5cdFx0XHRmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0ZXh0RW5jb2RlciQxLmVuY29kZUludG8oc3RyaW5nLCB0YXJnZXQuc3ViYXJyYXkocG9zaXRpb24pKS53cml0dGVuXG5cdFx0XHR9IDogZmFsc2U7XG5cblx0XHRsZXQgcGFja3IgPSB0aGlzO1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRsZXQgaXNTZXF1ZW50aWFsID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcXVlbnRpYWw7XG5cdFx0bGV0IGhhc1NoYXJlZFN0cnVjdHVyZXMgPSBvcHRpb25zLnN0cnVjdHVyZXMgfHwgb3B0aW9ucy5zYXZlU3RydWN0dXJlcztcblx0XHRsZXQgbWF4U2hhcmVkU3RydWN0dXJlcyA9IG9wdGlvbnMubWF4U2hhcmVkU3RydWN0dXJlcztcblx0XHRpZiAobWF4U2hhcmVkU3RydWN0dXJlcyA9PSBudWxsKVxuXHRcdFx0bWF4U2hhcmVkU3RydWN0dXJlcyA9IGhhc1NoYXJlZFN0cnVjdHVyZXMgPyAzMiA6IDA7XG5cdFx0aWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPiA4MTYwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIG1heFNoYXJlZFN0cnVjdHVyZSBpcyA4MTYwJylcblx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVkQ2xvbmUgJiYgb3B0aW9ucy5tb3JlVHlwZXMgPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLm1vcmVUeXBlcyA9IHRydWU7XG5cdFx0fVxuXHRcdGxldCBtYXhPd25TdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhPd25TdHJ1Y3R1cmVzO1xuXHRcdGlmIChtYXhPd25TdHJ1Y3R1cmVzID09IG51bGwpXG5cdFx0XHRtYXhPd25TdHJ1Y3R1cmVzID0gaGFzU2hhcmVkU3RydWN0dXJlcyA/IDMyIDogNjQ7XG5cdFx0aWYgKCF0aGlzLnN0cnVjdHVyZXMgJiYgb3B0aW9ucy51c2VSZWNvcmRzICE9IGZhbHNlKVxuXHRcdFx0dGhpcy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0Ly8gdHdvIGJ5dGUgcmVjb3JkIGlkcyBmb3Igc2hhcmVkIHN0cnVjdHVyZXNcblx0XHRsZXQgdXNlVHdvQnl0ZVJlY29yZHMgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gMzIgfHwgKG1heE93blN0cnVjdHVyZXMgKyBtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gNjQpO1xuXHRcdGxldCBzaGFyZWRMaW1pdElkID0gbWF4U2hhcmVkU3RydWN0dXJlcyArIDB4NDA7XG5cdFx0bGV0IG1heFN0cnVjdHVyZUlkID0gbWF4U2hhcmVkU3RydWN0dXJlcyArIG1heE93blN0cnVjdHVyZXMgKyAweDQwO1xuXHRcdGlmIChtYXhTdHJ1Y3R1cmVJZCA+IDgyNTYpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgKyBtYXhPd25TdHJ1Y3R1cmUgaXMgODE5MicpXG5cdFx0fVxuXHRcdGxldCByZWNvcmRJZHNUb1JlbW92ZSA9IFtdO1xuXHRcdGxldCB0cmFuc2l0aW9uc0NvdW50ID0gMDtcblx0XHRsZXQgc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkID0gMDtcblxuXHRcdHRoaXMucGFjayA9IHRoaXMuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIGVuY29kZU9wdGlvbnMpIHtcblx0XHRcdGlmICghdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSg4MTkyKTtcblx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIDAsIDgxOTIpKTtcblx0XHRcdFx0cG9zaXRpb24gPSAwO1xuXHRcdFx0fVxuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0XHRcdGlmIChzYWZlRW5kIC0gcG9zaXRpb24gPCAweDgwMCkge1xuXHRcdFx0XHQvLyBkb24ndCBzdGFydCB0b28gY2xvc2UgdG8gdGhlIGVuZCxcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKHRhcmdldC5sZW5ndGgpO1xuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgdGFyZ2V0Lmxlbmd0aCkpO1xuXHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cG9zaXRpb24gPSAocG9zaXRpb24gKyA3KSAmIDB4N2ZmZmZmZjg7IC8vIFdvcmQgYWxpZ24gdG8gbWFrZSBhbnkgZnV0dXJlIGNvcHlpbmcgb2YgdGhpcyBidWZmZXIgZmFzdGVyXG5cdFx0XHRzdGFydCA9IHBvc2l0aW9uO1xuXHRcdFx0aWYgKGVuY29kZU9wdGlvbnMgJiBSRVNFUlZFX1NUQVJUX1NQQUNFKSBwb3NpdGlvbiArPSAoZW5jb2RlT3B0aW9ucyAmIDB4ZmYpO1xuXHRcdFx0cmVmZXJlbmNlTWFwID0gcGFja3Iuc3RydWN0dXJlZENsb25lID8gbmV3IE1hcCgpIDogbnVsbDtcblx0XHRcdGlmIChwYWNrci5idW5kbGVTdHJpbmdzICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbXTtcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3Muc2l6ZSA9IEluZmluaXR5OyAvLyBmb3JjZSBhIG5ldyBidW5kbGUgc3RhcnQgb24gZmlyc3Qgc3RyaW5nXG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBudWxsO1xuXHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLnN0cnVjdHVyZXM7XG5cdFx0XHRpZiAoc3RydWN0dXJlcykge1xuXHRcdFx0XHRpZiAoc3RydWN0dXJlcy51bmluaXRpYWxpemVkKVxuXHRcdFx0XHRcdHN0cnVjdHVyZXMgPSBwYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKHBhY2tyLmdldFN0cnVjdHVyZXMoKSk7XG5cdFx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwO1xuXHRcdFx0XHRpZiAoc2hhcmVkTGVuZ3RoID4gbWF4U2hhcmVkU3RydWN0dXJlcykge1xuXHRcdFx0XHRcdC8vaWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPD0gMzIgJiYgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPiAzMikgLy8gVE9ETzogY291bGQgc3VwcG9ydCB0aGlzLCBidXQgd291bGQgbmVlZCB0byB1cGRhdGUgdGhlIGxpbWl0IGlkc1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignU2hhcmVkIHN0cnVjdHVyZXMgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaGFyZWQgc3RydWN0dXJlcywgdHJ5IGluY3JlYXNpbmcgbWF4U2hhcmVkU3RydWN0dXJlcyB0byAnICsgc3RydWN0dXJlcy5zaGFyZWRMZW5ndGgpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zKSB7XG5cdFx0XHRcdFx0Ly8gcmVidWlsZCBvdXIgc3RydWN0dXJlIHRyYW5zaXRpb25zXG5cdFx0XHRcdFx0c3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzaGFyZWRMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0bGV0IGtleXMgPSBzdHJ1Y3R1cmVzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCFrZXlzKVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucztcblx0XHRcdFx0XHRcdGZvciAobGV0IGogPSAwLCBsID0ga2V5cy5sZW5ndGg7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGtleSA9IGtleXNbal07XG5cdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF0gPSBpICsgMHg0MDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gc2hhcmVkTGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdFx0c3RydWN0dXJlcy5uZXh0SWQgPSBzaGFyZWRMZW5ndGggKyAweDQwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzU2hhcmVkVXBkYXRlKVxuXHRcdFx0XHRoYXNTaGFyZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGxldCBlbmNvZGluZ0Vycm9yO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHBhY2tyLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuXHRcdFx0XHRcdHdyaXRlU3RydWN0KHZhbHVlKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBhY2sodmFsdWUpO1xuXHRcdFx0XHRsZXQgbGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzO1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MpXG5cdFx0XHRcdFx0d3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCAwKTtcblx0XHRcdFx0aWYgKHJlZmVyZW5jZU1hcCAmJiByZWZlcmVuY2VNYXAuaWRzVG9JbnNlcnQpIHtcblx0XHRcdFx0XHRsZXQgaWRzVG9JbnNlcnQgPSByZWZlcmVuY2VNYXAuaWRzVG9JbnNlcnQuc29ydCgoYSwgYikgPT4gYS5vZmZzZXQgPiBiLm9mZnNldCA/IDEgOiAtMSk7XG5cdFx0XHRcdFx0bGV0IGkgPSBpZHNUb0luc2VydC5sZW5ndGg7XG5cdFx0XHRcdFx0bGV0IGluY3JlbWVudFBvc2l0aW9uID0gLTE7XG5cdFx0XHRcdFx0d2hpbGUgKGxhc3RCdW5kbGUgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdGxldCBpbnNlcnRpb25Qb2ludCA9IGlkc1RvSW5zZXJ0Wy0taV0ub2Zmc2V0ICsgc3RhcnQ7XG5cdFx0XHRcdFx0XHRpZiAoaW5zZXJ0aW9uUG9pbnQgPCAobGFzdEJ1bmRsZS5zdHJpbmdzUG9zaXRpb24gKyBzdGFydCkgJiYgaW5jcmVtZW50UG9zaXRpb24gPT09IC0xKVxuXHRcdFx0XHRcdFx0XHRpbmNyZW1lbnRQb3NpdGlvbiA9IDA7XG5cdFx0XHRcdFx0XHRpZiAoaW5zZXJ0aW9uUG9pbnQgPiAobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0KSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMClcblx0XHRcdFx0XHRcdFx0XHRpbmNyZW1lbnRQb3NpdGlvbiArPSA2O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluY3JlbWVudFBvc2l0aW9uID49IDApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB1cGRhdGUgdGhlIGJ1bmRsZSByZWZlcmVuY2Ugbm93XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5nZXRVaW50MzIobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0KSArIGluY3JlbWVudFBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0XHRpbmNyZW1lbnRQb3NpdGlvbiA9IC0xOyAvLyByZXNldFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxhc3RCdW5kbGUgPSBsYXN0QnVuZGxlLnByZXZpb3VzO1xuXHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwICYmIGxhc3RCdW5kbGUpIHtcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5nZXRVaW50MzIobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0KSArIGluY3JlbWVudFBvc2l0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gaWRzVG9JbnNlcnQubGVuZ3RoICogNjtcblx0XHRcdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0bWFrZVJvb20ocG9zaXRpb24pO1xuXHRcdFx0XHRcdHBhY2tyLm9mZnNldCA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdGxldCBzZXJpYWxpemVkID0gaW5zZXJ0SWRzKHRhcmdldC5zdWJhcnJheShzdGFydCwgcG9zaXRpb24pLCBpZHNUb0luc2VydCk7XG5cdFx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gc2VyaWFsaXplZFxuXHRcdFx0XHR9XG5cdFx0XHRcdHBhY2tyLm9mZnNldCA9IHBvc2l0aW9uOyAvLyB1cGRhdGUgdGhlIG9mZnNldCBzbyBuZXh0IHNlcmlhbGl6YXRpb24gZG9lc24ndCB3cml0ZSBvdmVyIG91ciBidWZmZXIsIGJ1dCBjYW4gY29udGludWUgd3JpdGluZyB0byBzYW1lIGJ1ZmZlciBzZXF1ZW50aWFsbHlcblx0XHRcdFx0aWYgKGVuY29kZU9wdGlvbnMgJiBSRVVTRV9CVUZGRVJfTU9ERSkge1xuXHRcdFx0XHRcdHRhcmdldC5zdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRcdHRhcmdldC5lbmQgPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRhcmdldC5zdWJhcnJheShzdGFydCwgcG9zaXRpb24pIC8vIHBvc2l0aW9uIGNhbiBjaGFuZ2UgaWYgd2UgY2FsbCBwYWNrIGFnYWluIGluIHNhdmVTdHJ1Y3R1cmVzLCBzbyB3ZSBnZXQgdGhlIGJ1ZmZlciBub3dcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdFx0ZW5jb2RpbmdFcnJvciA9IGVycm9yO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0cmVzZXRTdHJ1Y3R1cmVzKCk7XG5cdFx0XHRcdFx0aWYgKGhhc1NoYXJlZFVwZGF0ZSAmJiBwYWNrci5zYXZlU3RydWN0dXJlcykge1xuXHRcdFx0XHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDA7XG5cdFx0XHRcdFx0XHQvLyB3ZSBjYW4ndCByZWx5IG9uIHN0YXJ0L2VuZCB3aXRoIFJFVVNFX0JVRkZFUl9NT0RFIHNpbmNlIHRoZXkgd2lsbCAocHJvYmFibHkpIGNoYW5nZSB3aGVuIHdlIHNhdmVcblx0XHRcdFx0XHRcdGxldCByZXR1cm5CdWZmZXIgPSB0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdGxldCBuZXdTaGFyZWREYXRhID0gcHJlcGFyZVN0cnVjdHVyZXMkMShzdHJ1Y3R1cmVzLCBwYWNrcik7XG5cdFx0XHRcdFx0XHRpZiAoIWVuY29kaW5nRXJyb3IpIHsgLy8gVE9ETzogSWYgdGhlcmUgaXMgYW4gZW5jb2RpbmcgZXJyb3IsIHNob3VsZCBtYWtlIHRoZSBzdHJ1Y3R1cmVzIGFzIHVuaW5pdGlhbGl6ZWQgc28gdGhleSBnZXQgcmVidWlsdCBuZXh0IHRpbWVcblx0XHRcdFx0XHRcdFx0aWYgKHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKG5ld1NoYXJlZERhdGEsIG5ld1NoYXJlZERhdGEuaXNDb21wYXRpYmxlKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBnZXQgdXBkYXRlZCBzdHJ1Y3R1cmVzIGFuZCB0cnkgYWdhaW4gaWYgdGhlIHVwZGF0ZSBmYWlsZWRcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFja3IucGFjayh2YWx1ZSwgZW5jb2RlT3B0aW9ucylcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gc2hhcmVkTGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHQvLyBkb24ndCBrZWVwIGxhcmdlIGJ1ZmZlcnMgYXJvdW5kXG5cdFx0XHRcdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybkJ1ZmZlclxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkb24ndCBrZWVwIGxhcmdlIGJ1ZmZlcnMgYXJvdW5kLCB0aGV5IHRha2UgdG9vIG11Y2ggbWVtb3J5IGFuZCBjYXVzZSBwcm9ibGVtcyAobGltaXQgYXQgMUdCKVxuXHRcdFx0XHRpZiAodGFyZ2V0Lmxlbmd0aCA+IDB4NDAwMDAwMDApIHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVTRVRfQlVGRkVSX01PREUpXG5cdFx0XHRcdFx0cG9zaXRpb24gPSBzdGFydDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHJlc2V0U3RydWN0dXJlcyA9ICgpID0+IHtcblx0XHRcdGlmIChzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPCAxMClcblx0XHRcdFx0c2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkKys7XG5cdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMDtcblx0XHRcdGlmIChzdHJ1Y3R1cmVzLmxlbmd0aCA+IHNoYXJlZExlbmd0aCAmJiAhaXNTZXF1ZW50aWFsKVxuXHRcdFx0XHRzdHJ1Y3R1cmVzLmxlbmd0aCA9IHNoYXJlZExlbmd0aDtcblx0XHRcdGlmICh0cmFuc2l0aW9uc0NvdW50ID4gMTAwMDApIHtcblx0XHRcdFx0Ly8gZm9yY2UgYSByZWJ1aWxkIG9jY2FzaW9uYWxseSBhZnRlciBhIGxvdCBvZiB0cmFuc2l0aW9ucyBzbyBpdCBjYW4gZ2V0IGNsZWFuZWQgdXBcblx0XHRcdFx0c3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IG51bGw7XG5cdFx0XHRcdHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA9IDA7XG5cdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgPSAwO1xuXHRcdFx0XHRpZiAocmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoID4gMClcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZSA9IFtdO1xuXHRcdFx0fSBlbHNlIGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPiAwICYmICFpc1NlcXVlbnRpYWwpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSByZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZVtpXVtSRUNPUkRfU1lNQk9MXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUgPSBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHBhY2tBcnJheSA9ICh2YWx1ZSkgPT4ge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4OTAgfCBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYztcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRkO1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdH1cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cGFjayh2YWx1ZVtpXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCBwYWNrID0gKHZhbHVlKSA9PiB7XG5cdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbik7XG5cblx0XHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRcdFx0dmFyIGxlbmd0aDtcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRsZXQgc3RyTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MgJiYgc3RyTGVuZ3RoID49IDQgJiYgc3RyTGVuZ3RoIDwgMHgxMDAwKSB7XG5cdFx0XHRcdFx0aWYgKChidW5kbGVkU3RyaW5ncy5zaXplICs9IHN0ckxlbmd0aCkgPiBNQVhfQlVORExFX1NJWkUpIHtcblx0XHRcdFx0XHRcdGxldCBleHRTdGFydDtcblx0XHRcdFx0XHRcdGxldCBtYXhCeXRlcyA9IChidW5kbGVkU3RyaW5nc1swXSA/IGJ1bmRsZWRTdHJpbmdzWzBdLmxlbmd0aCAqIDMgKyBidW5kbGVkU3RyaW5nc1sxXS5sZW5ndGggOiAwKSArIDEwO1xuXHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uICsgbWF4Qnl0ZXMgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKTtcblx0XHRcdFx0XHRcdGxldCBsYXN0QnVuZGxlO1xuXHRcdFx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uKSB7IC8vIGhlcmUgd2UgdXNlIHRoZSAweDYyIGV4dGVuc2lvbiB0byB3cml0ZSB0aGUgbGFzdCBidW5kbGUgYW5kIHJlc2VydmUgc3BhY2UgZm9yIHRoZSByZWZlcmVuY2UgcG9pbnRlciB0byB0aGUgbmV4dC9jdXJyZW50IGJ1bmRsZVxuXHRcdFx0XHRcdFx0XHRsYXN0QnVuZGxlID0gYnVuZGxlZFN0cmluZ3M7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbl0gPSAweGM4OyAvLyBleHQgMTZcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gMzsgLy8gcmVzZXJ2ZSBmb3IgdGhlIHdyaXRpbmcgYnVuZGxlIHNpemVcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg2MjsgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDsgLy8gcmVzZXJ2ZSBmb3Igd3JpdGluZyBidW5kbGUgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRcdHdyaXRlQnVuZGxlcyhzdGFydCwgcGFjaywgMCk7IC8vIHdyaXRlIHRoZSBsYXN0IGJ1bmRsZXNcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYoZXh0U3RhcnQgKyBzdGFydCAtIDMsIHBvc2l0aW9uIC0gc3RhcnQgLSBleHRTdGFydCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBoZXJlIHdlIHVzZSB0aGUgMHg2MiBleHRlbnNpb24ganVzdCB0byByZXNlcnZlIHRoZSBzcGFjZSBmb3IgdGhlIHJlZmVyZW5jZSBwb2ludGVyIHRvIHRoZSBidW5kbGUgKHdpbGwgYmUgdXBkYXRlZCBvbmNlIHRoZSBidW5kbGUgaXMgd3JpdHRlbilcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNjsgLy8gZml4ZXh0IDRcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg2MjsgLy8gJ2InXG5cdFx0XHRcdFx0XHRcdGV4dFN0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDsgLy8gcmVzZXJ2ZSBmb3Igd3JpdGluZyBidW5kbGUgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IFsnJywgJyddOyAvLyBjcmVhdGUgbmV3IG9uZXNcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnByZXZpb3VzID0gbGFzdEJ1bmRsZTtcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnNpemUgPSAwO1xuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MucG9zaXRpb24gPSBleHRTdGFydDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IHR3b0J5dGUgPSBoYXNOb25MYXRpbi50ZXN0KHZhbHVlKTtcblx0XHRcdFx0XHRidW5kbGVkU3RyaW5nc1t0d29CeXRlID8gMCA6IDFdICs9IHZhbHVlO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzE7XG5cdFx0XHRcdFx0cGFjayh0d29CeXRlID8gLXN0ckxlbmd0aCA6IHN0ckxlbmd0aCk7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGhlYWRlclNpemU7XG5cdFx0XHRcdC8vIGZpcnN0IHdlIGVzdGltYXRlIHRoZSBoZWFkZXIgc2l6ZSwgc28gd2UgY2FuIHdyaXRlIHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDE7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RyTGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gMjtcblx0XHRcdFx0fSBlbHNlIGlmIChzdHJMZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG1heEJ5dGVzID0gc3RyTGVuZ3RoICogMztcblx0XHRcdFx0aWYgKHBvc2l0aW9uICsgbWF4Qnl0ZXMgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgbWF4Qnl0ZXMpO1xuXG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDQwIHx8ICFlbmNvZGVVdGY4KSB7XG5cdFx0XHRcdFx0bGV0IGksIGMxLCBjMiwgc3RyUG9zaXRpb24gPSBwb3NpdGlvbiArIGhlYWRlclNpemU7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHN0ckxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdFx0XHRpZiAoYzEgPCAweDgwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjMSA8IDB4ODAwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgfCAweGMwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0KGMxICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG5cdFx0XHRcdFx0XHRcdCgoYzIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweGZjMDApID09PSAweGRjMDBcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuXHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDE4IHwgMHhmMDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTIgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTIgfCAweGUwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxlbmd0aCA9IHN0clBvc2l0aW9uIC0gcG9zaXRpb24gLSBoZWFkZXJTaXplO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxlbmd0aCA9IGVuY29kZVV0ZjgodmFsdWUsIHBvc2l0aW9uICsgaGVhZGVyU2l6ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YTAgfCBsZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyU2l6ZSA8IDIpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uICsgMiwgcG9zaXRpb24gKyAxLCBwb3NpdGlvbiArIDEgKyBsZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ5O1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCAzKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDMsIHBvc2l0aW9uICsgMiwgcG9zaXRpb24gKyAyICsgbGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYTtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgNSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyA1LCBwb3NpdGlvbiArIDMsIHBvc2l0aW9uICsgMyArIGxlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGI7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCk7XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA+Pj4gMCA9PT0gdmFsdWUpIHsvLyBwb3NpdGl2ZSBpbnRlZ2VyLCAzMi1iaXQgb3IgbGVzc1xuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIHVpbnRcblx0XHRcdFx0XHRpZiAodmFsdWUgPCAweDIwIHx8ICh2YWx1ZSA8IDB4ODAgJiYgdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSkgfHwgKHZhbHVlIDwgMHg0MCAmJiAhdGhpcy5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUpKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMHgxMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2M7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjZDtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID4+IDg7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSAmIDB4ZmY7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2U7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj4gMCA9PT0gdmFsdWUpIHsgLy8gbmVnYXRpdmUgaW50ZWdlclxuXHRcdFx0XHRcdGlmICh2YWx1ZSA+PSAtMHgyMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHgxMDAgKyB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID49IC0weDgwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQwO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgKyAweDEwMDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID49IC0weDgwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDE7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQyO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQzMihwb3NpdGlvbiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IHVzZUZsb2F0MzI7XG5cdFx0XHRcdFx0aWYgKCh1c2VGbG9hdDMyID0gdGhpcy51c2VGbG9hdDMyKSA+IDAgJiYgdmFsdWUgPCAweDEwMDAwMDAwMCAmJiB2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYTtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQzMihwb3NpdGlvbiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0bGV0IHhTaGlmdGVkO1xuXHRcdFx0XHRcdFx0aWYgKHVzZUZsb2F0MzIgPCA0IHx8XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBjaGVja3MgZm9yIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRcdCgoeFNoaWZ0ZWQgPSB2YWx1ZSAqIG11bHQxMFsoKHRhcmdldFtwb3NpdGlvbl0gJiAweDdmKSA8PCAxKSB8ICh0YXJnZXRbcG9zaXRpb24gKyAxXSA+PiA3KV0pID4+IDApID09PSB4U2hpZnRlZCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbi0tOyAvLyBtb3ZlIGJhY2sgaW50byBwb3NpdGlvbiBmb3Igd3JpdGluZyBhIGRvdWJsZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNiO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgdmFsdWUpO1xuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRpZiAoIXZhbHVlKVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzA7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZWZlcmVuY2VNYXApIHtcblx0XHRcdFx0XHRcdGxldCByZWZlcmVlID0gcmVmZXJlbmNlTWFwLmdldCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAocmVmZXJlZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXJlZmVyZWUuaWQpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgaWRzVG9JbnNlcnQgPSByZWZlcmVuY2VNYXAuaWRzVG9JbnNlcnQgfHwgKHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCA9IFtdKTtcblx0XHRcdFx0XHRcdFx0XHRyZWZlcmVlLmlkID0gaWRzVG9JbnNlcnQucHVzaChyZWZlcmVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2OyAvLyBmaXhleHQgNFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcwOyAvLyBcInBcIiBmb3IgcG9pbnRlclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgcmVmZXJlZS5pZCk7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHJlZmVyZW5jZU1hcC5zZXQodmFsdWUsIHsgb2Zmc2V0OiBwb3NpdGlvbiAtIHN0YXJ0IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3Rvcjtcblx0XHRcdFx0XHRpZiAoY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuXHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG5cdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT09IE1hcCkge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubWFwQXNFbXB0eU9iamVjdCkgdGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MDtcblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5zaXplO1xuXHRcdFx0XHRcdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ODAgfCBsZW5ndGg7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGU7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRmO1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgW2tleSwgZW50cnlWYWx1ZV0gb2YgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKGtleSk7XG5cdFx0XHRcdFx0XHRcdFx0cGFjayhlbnRyeVZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBleHRlbnNpb25DbGFzcyA9IGV4dGVuc2lvbkNsYXNzZXNbaV07XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIGV4dGVuc2lvbkNsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbaV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi53cml0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGV4dGVuc2lvbi50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7IC8vIG9uZSBieXRlIFwidGFnXCIgZXh0ZW5zaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGV4dGVuc2lvbi50eXBlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IHdyaXRlUmVzdWx0ID0gZXh0ZW5zaW9uLndyaXRlLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHdyaXRlUmVzdWx0ID09PSB2YWx1ZSkgeyAvLyBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGFja0FycmF5KHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3cml0ZU9iamVjdCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhY2sod3JpdGVSZXN1bHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGxldCBjdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0XHRcdGxldCBjdXJyZW50VGFyZ2V0VmlldyA9IHRhcmdldFZpZXc7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHJlc3VsdDtcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gZXh0ZW5zaW9uLnBhY2suY2FsbCh0aGlzLCB2YWx1ZSwgKHNpemUpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSB0YXJnZXQgYW5kIHVzZSBpdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gc2l6ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbjogcG9zaXRpb24gLSBzaXplXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sIHBhY2spO1xuXHRcdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyByZXN0b3JlIGN1cnJlbnQgdGFyZ2V0IGluZm9ybWF0aW9uICh1bmxlc3MgYWxyZWFkeSByZXN0b3JlZClcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChjdXJyZW50VGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcgPSBjdXJyZW50VGFyZ2V0Vmlldztcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb247XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtYWtlUm9vbShyZXN1bHQubGVuZ3RoICsgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gPSB3cml0ZUV4dGVuc2lvbkRhdGEocmVzdWx0LCB0YXJnZXQsIHBvc2l0aW9uLCBleHRlbnNpb24udHlwZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpc0FycmF5IGFmdGVyIGV4dGVuc2lvbnMsIGJlY2F1c2UgZXh0ZW5zaW9ucyBjYW4gZXh0ZW5kIEFycmF5XG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0cGFja0FycmF5KHZhbHVlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSB0aGlzIGFzIGFuIGFsdGVybmF0ZSBtZWNoYW5pc20gZm9yIGV4cHJlc3NpbmcgaG93IHRvIHNlcmlhbGl6ZVxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUudG9KU09OKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QganNvbiA9IHZhbHVlLnRvSlNPTigpO1xuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIGZvciBzb21lIHJlYXNvbiB2YWx1ZS50b0pTT04gcmV0dXJucyBpdHNlbGYgaXQnbGwgbG9vcCBmb3JldmVyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGpzb24gIT09IHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2soanNvbilcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGEgd3JpdGVGdW5jdGlvbiwgdXNlIGl0LCBvdGhlcndpc2UganVzdCBlbmNvZGUgYXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnZnVuY3Rpb24nKVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYWNrKHRoaXMud3JpdGVGdW5jdGlvbiAmJiB0aGlzLndyaXRlRnVuY3Rpb24odmFsdWUpKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBubyBleHRlbnNpb24gZm91bmQsIHdyaXRlIGFzIHBsYWluIG9iamVjdFxuXHRcdFx0XHRcdFx0XHR3cml0ZU9iamVjdCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSA/IDB4YzMgOiAweGMyO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYmlnaW50Jykge1xuXHRcdFx0XHRpZiAodmFsdWUgPCAweDgwMDAwMDAwMDAwMDAwMDAgJiYgdmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMCkge1xuXHRcdFx0XHRcdC8vIHVzZSBhIHNpZ25lZCBpbnQgYXMgbG9uZyBhcyBpdCBmaXRzXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMztcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ0ludDY0KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMDAwMDAwMDAwMDAwMDAwICYmIHZhbHVlID4gMCkge1xuXHRcdFx0XHRcdC8vIGlmIHdlIGNhbiBmaXQgYW4gdW5zaWduZWQgaW50LCB1c2UgdGhhdFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Y7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdVaW50NjQocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBvdmVyZmxvd1xuXHRcdFx0XHRcdGlmICh0aGlzLmxhcmdlQmlnSW50VG9GbG9hdCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYjtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTnVtYmVyKHZhbHVlKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmxhcmdlQmlnSW50VG9TdHJpbmcpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwYWNrKHZhbHVlLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy51c2VCaWdJbnRFeHRlbnNpb24gfHwgdGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdFx0XHRcdGxldCBlbXB0eSA9IHZhbHVlIDwgMCA/IEJpZ0ludCgtMSkgOiBCaWdJbnQoMCk7XG5cblx0XHRcdFx0XHRcdGxldCBhcnJheTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSA+PiBCaWdJbnQoMHgxMDAwMCkgPT09IGVtcHR5KSB7XG5cdFx0XHRcdFx0XHRcdGxldCBtYXNrID0gQmlnSW50KDB4MTAwMDAwMDAwMDAwMDAwMDApIC0gQmlnSW50KDEpOyAvLyBsaXRlcmFsIHdvdWxkIG92ZXJmbG93XG5cdFx0XHRcdFx0XHRcdGxldCBjaHVua3MgPSBbXTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRjaHVua3MucHVzaCh2YWx1ZSAmIG1hc2spO1xuXHRcdFx0XHRcdFx0XHRcdGlmICgodmFsdWUgPj4gQmlnSW50KDYzKSkgPT09IGVtcHR5KSBicmVha1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID4+PSBCaWdJbnQoNjQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YXJyYXkgPSBuZXcgVWludDhBcnJheShuZXcgQmlnVWludDY0QXJyYXkoY2h1bmtzKS5idWZmZXIpO1xuXHRcdFx0XHRcdFx0XHRhcnJheS5yZXZlcnNlKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZXQgaW52ZXJ0ID0gdmFsdWUgPCAwO1xuXHRcdFx0XHRcdFx0XHRsZXQgc3RyaW5nID0gKGludmVydCA/IH52YWx1ZSA6IHZhbHVlKS50b1N0cmluZygxNik7XG5cdFx0XHRcdFx0XHRcdGlmIChzdHJpbmcubGVuZ3RoICUgMikge1xuXHRcdFx0XHRcdFx0XHRcdHN0cmluZyA9ICcwJyArIHN0cmluZztcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwYXJzZUludChzdHJpbmcuY2hhckF0KDApLCAxNikgPj0gOCkge1xuXHRcdFx0XHRcdFx0XHRcdHN0cmluZyA9ICcwMCcgKyBzdHJpbmc7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzTm9kZUJ1ZmZlciQxKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXJyYXkgPSBCdWZmZXIuZnJvbShzdHJpbmcsICdoZXgnKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRhcnJheSA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGggLyAyKTtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhcnJheVtpXSA9IHBhcnNlSW50KHN0cmluZy5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnZlcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBhcnJheVtpXSA9IH5hcnJheVtpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoYXJyYXkubGVuZ3RoICsgcG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRtYWtlUm9vbShhcnJheS5sZW5ndGggKyBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHdyaXRlRXh0ZW5zaW9uRGF0YShhcnJheSwgdGFyZ2V0LCBwb3NpdGlvbiwgMHg0Mik7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IodmFsdWUgKyAnIHdhcyB0b28gbGFyZ2UgdG8gZml0IGluIE1lc3NhZ2VQYWNrIDY0LWJpdCBpbnRlZ2VyIGZvcm1hdCwgdXNlJyArXG5cdFx0XHRcdFx0XHRcdCcgdXNlQmlnSW50RXh0ZW5zaW9uLCBvciBzZXQgbGFyZ2VCaWdJbnRUb0Zsb2F0IHRvIGNvbnZlcnQgdG8gZmxvYXQtNjQsIG9yIHNldCcgK1xuXHRcdFx0XHRcdFx0XHQnIGxhcmdlQmlnSW50VG9TdHJpbmcgdG8gY29udmVydCB0byBzdHJpbmcnKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4O1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRpZiAodGhpcy5lbmNvZGVVbmRlZmluZWRBc05pbClcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwO1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0OyAvLyBhIG51bWJlciBvZiBpbXBsZW1lbnRhdGlvbnMgdXNlIGZpeGV4dDEgd2l0aCB0eXBlIDAsIGRhdGEgMCB0byBkZW5vdGUgdW5kZWZpbmVkLCBzbyB3ZSBmb2xsb3cgc3VpdGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgdHlwZSlcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgd3JpdGVQbGFpbk9iamVjdCA9ICh0aGlzLnZhcmlhYmxlTWFwU2l6ZSB8fCB0aGlzLmNvZXJjaWJsZUtleUFzTnVtYmVyIHx8IHRoaXMuc2tpcFZhbHVlcykgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHQvLyB0aGlzIG1ldGhvZCBpcyBzbGlnaHRseSBzbG93ZXIsIGJ1dCBnZW5lcmF0ZXMgXCJwcmVmZXJyZWQgc2VyaWFsaXphdGlvblwiIChvcHRpbWFsbHkgc21hbGwgZm9yIHNtYWxsZXIgb2JqZWN0cylcblx0XHRcdGxldCBrZXlzO1xuXHRcdFx0aWYgKHRoaXMuc2tpcFZhbHVlcykge1xuXHRcdFx0XHRrZXlzID0gW107XG5cdFx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0XHRpZiAoKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpICYmXG5cdFx0XHRcdFx0XHQhdGhpcy5za2lwVmFsdWVzLmluY2x1ZGVzKG9iamVjdFtrZXldKSlcblx0XHRcdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblx0XHRcdH1cblx0XHRcdGxldCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ODAgfCBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZTtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRmO1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdH1cblx0XHRcdGxldCBrZXk7XG5cdFx0XHRpZiAodGhpcy5jb2VyY2libGVLZXlBc051bWJlcikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRsZXQgbnVtID0gTnVtYmVyKGtleSk7XG5cdFx0XHRcdFx0cGFjayhpc05hTihudW0pID8ga2V5IDogbnVtKTtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cGFjayhrZXkgPSBrZXlzW2ldKTtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGU7IC8vIGFsd2F5cyB1c2luZyBtYXAgMTYsIHNvIHdlIGNhbiBwcmVhbGxvY2F0ZSBhbmQgc2V0IHRoZSBsZW5ndGggYWZ0ZXJ3YXJkc1xuXHRcdFx0bGV0IG9iamVjdE9mZnNldCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdFx0bGV0IHNpemUgPSAwO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdHBhY2soa2V5KTtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0XHRzaXplKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChzaXplID4gMHhmZmZmKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignT2JqZWN0IGlzIHRvbyBsYXJnZSB0byBzZXJpYWxpemUgd2l0aCBmYXN0IDE2LWJpdCBtYXAgc2l6ZSwnICtcblx0XHRcdFx0JyB1c2UgdGhlIFwidmFyaWFibGVNYXBTaXplXCIgb3B0aW9uIHRvIHNlcmlhbGl6ZSB0aGlzIG9iamVjdCcpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0W29iamVjdE9mZnNldCsrICsgc3RhcnRdID0gc2l6ZSA+PiA4O1xuXHRcdFx0dGFyZ2V0W29iamVjdE9mZnNldCArIHN0YXJ0XSA9IHNpemUgJiAweGZmO1xuXHRcdH07XG5cblx0XHRjb25zdCB3cml0ZVJlY29yZCA9IHRoaXMudXNlUmVjb3JkcyA9PT0gZmFsc2UgPyB3cml0ZVBsYWluT2JqZWN0IDpcblx0XHQob3B0aW9ucy5wcm9ncmVzc2l2ZVJlY29yZHMgJiYgIXVzZVR3b0J5dGVSZWNvcmRzKSA/ICAvLyB0aGlzIGlzIGFib3V0IDIlIGZhc3RlciBmb3IgaGlnaGx5IHN0YWJsZSBzdHJ1Y3R1cmVzLCBzaW5jZSBpdCBvbmx5IHJlcXVpcmVzIG9uZSBmb3ItaW4gbG9vcCAoYnV0IG11Y2ggbW9yZSBleHBlbnNpdmUgd2hlbiBuZXcgc3RydWN0dXJlIG5lZWRzIHRvIGJlIHdyaXR0ZW4pXG5cdFx0KG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucyB8fCAoc3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRcdFx0bGV0IG9iamVjdE9mZnNldCA9IHBvc2l0aW9uKysgLSBzdGFydDtcblx0XHRcdGxldCB3cm90ZUtleXM7XG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gcmVjb3JkIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBmdWxsIG5ldyByZWNvcmQgYW5kIGluc2VydCBpdFxuXHRcdFx0XHRcdFx0bGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXHRcdFx0XHRcdFx0bGV0IGxhc3RUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zO1xuXHRcdFx0XHRcdFx0bGV0IG5ld1RyYW5zaXRpb25zID0gMDtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdFx0XHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRcdFx0XHRcdG5ld1RyYW5zaXRpb25zKys7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG9iamVjdE9mZnNldCArIHN0YXJ0ICsgMSA9PSBwb3NpdGlvbikge1xuXHRcdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXksIHNvIHdlIGRvbid0IG5lZWQgdG8gaW5zZXJ0LCB3ZSBjYW4ganVzdCB3cml0ZSByZWNvcmQgZGlyZWN0bHlcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24tLTtcblx0XHRcdFx0XHRcdFx0bmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG5ld1RyYW5zaXRpb25zKTtcblx0XHRcdFx0XHRcdH0gZWxzZSAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBpbnNlcnQgdGhlIHJlY29yZCwgbW92aW5nIGV4aXN0aW5nIGRhdGEgYWZ0ZXIgdGhlIHJlY29yZFxuXHRcdFx0XHRcdFx0XHRpbnNlcnROZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgb2JqZWN0T2Zmc2V0LCBuZXdUcmFuc2l0aW9ucyk7XG5cdFx0XHRcdFx0XHR3cm90ZUtleXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGxhc3RUcmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXdyb3RlS2V5cykge1xuXHRcdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdO1xuXHRcdFx0XHRpZiAocmVjb3JkSWQpXG5cdFx0XHRcdFx0dGFyZ2V0W29iamVjdE9mZnNldCArIHN0YXJ0XSA9IHJlY29yZElkO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0aW5zZXJ0TmV3UmVjb3JkKHRyYW5zaXRpb24sIE9iamVjdC5rZXlzKG9iamVjdCksIG9iamVjdE9mZnNldCwgMCk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5leHRUcmFuc2l0aW9uLCB0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucyB8fCAoc3RydWN0dXJlcy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRcdFx0bGV0IG5ld1RyYW5zaXRpb25zID0gMDtcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRcdG5ld1RyYW5zaXRpb25zKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0fVxuXHRcdFx0bGV0IHJlY29yZElkID0gdHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXTtcblx0XHRcdGlmIChyZWNvcmRJZCkge1xuXHRcdFx0XHRpZiAocmVjb3JkSWQgPj0gMHg2MCAmJiB1c2VUd29CeXRlUmVjb3Jkcykge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9ICgocmVjb3JkSWQgLT0gMHg2MCkgJiAweDFmKSArIDB4NjA7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWQgPj4gNTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwgdHJhbnNpdGlvbi5fX2tleXNfXyB8fCBPYmplY3Qua2V5cyhvYmplY3QpLCBuZXdUcmFuc2l0aW9ucyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBub3cgd3JpdGUgdGhlIHZhbHVlc1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdClcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBjcmVhdGUgcmVmZXJlbmNlIHRvIHVzZVJlY29yZHMgaWYgdXNlUmVjb3JkcyBpcyBhIGZ1bmN0aW9uXG5cdFx0Y29uc3QgY2hlY2tVc2VSZWNvcmRzID0gdHlwZW9mIHRoaXMudXNlUmVjb3JkcyA9PSAnZnVuY3Rpb24nICYmIHRoaXMudXNlUmVjb3JkcztcblxuXHRcdGNvbnN0IHdyaXRlT2JqZWN0ID0gY2hlY2tVc2VSZWNvcmRzID8gKG9iamVjdCkgPT4ge1xuXHRcdFx0Y2hlY2tVc2VSZWNvcmRzKG9iamVjdCkgPyB3cml0ZVJlY29yZChvYmplY3QpIDogd3JpdGVQbGFpbk9iamVjdChvYmplY3QpO1xuXHRcdH0gOiB3cml0ZVJlY29yZDtcblxuXHRcdGNvbnN0IG1ha2VSb29tID0gKGVuZCkgPT4ge1xuXHRcdFx0bGV0IG5ld1NpemU7XG5cdFx0XHRpZiAoZW5kID4gMHgxMDAwMDAwKSB7XG5cdFx0XHRcdC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHJlYWxseSBsYXJnZSBidWZmZXJzXG5cdFx0XHRcdGlmICgoZW5kIC0gc3RhcnQpID4gTUFYX0JVRkZFUl9TSVpFKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignUGFja2VkIGJ1ZmZlciB3b3VsZCBiZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGJ1ZmZlciBzaXplJylcblx0XHRcdFx0bmV3U2l6ZSA9IE1hdGgubWluKE1BWF9CVUZGRVJfU0laRSxcblx0XHRcdFx0XHRNYXRoLnJvdW5kKE1hdGgubWF4KChlbmQgLSBzdGFydCkgKiAoZW5kID4gMHg0MDAwMDAwID8gMS4yNSA6IDIpLCAweDQwMDAwMCkgLyAweDEwMDApICogMHgxMDAwKTtcblx0XHRcdH0gZWxzZSAvLyBmYXN0ZXIgaGFuZGxpbmcgZm9yIHNtYWxsZXIgYnVmZmVyc1xuXHRcdFx0XHRuZXdTaXplID0gKChNYXRoLm1heCgoZW5kIC0gc3RhcnQpIDw8IDIsIHRhcmdldC5sZW5ndGggLSAxKSA+PiAxMikgKyAxKSA8PCAxMjtcblx0XHRcdGxldCBuZXdCdWZmZXIgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUobmV3U2l6ZSk7XG5cdFx0XHR0YXJnZXRWaWV3ID0gbmV3QnVmZmVyLmRhdGFWaWV3IHx8IChuZXdCdWZmZXIuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcobmV3QnVmZmVyLmJ1ZmZlciwgMCwgbmV3U2l6ZSkpO1xuXHRcdFx0ZW5kID0gTWF0aC5taW4oZW5kLCB0YXJnZXQubGVuZ3RoKTtcblx0XHRcdGlmICh0YXJnZXQuY29weSlcblx0XHRcdFx0dGFyZ2V0LmNvcHkobmV3QnVmZmVyLCAwLCBzdGFydCwgZW5kKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0bmV3QnVmZmVyLnNldCh0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuXHRcdFx0cG9zaXRpb24gLT0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRzYWZlRW5kID0gbmV3QnVmZmVyLmxlbmd0aCAtIDEwO1xuXHRcdFx0cmV0dXJuIHRhcmdldCA9IG5ld0J1ZmZlclxuXHRcdH07XG5cdFx0Y29uc3QgbmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIG5ld1RyYW5zaXRpb25zKSA9PiB7XG5cdFx0XHRsZXQgcmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRJZDtcblx0XHRcdGlmICghcmVjb3JkSWQpXG5cdFx0XHRcdHJlY29yZElkID0gMHg0MDtcblx0XHRcdGlmIChyZWNvcmRJZCA8IHNoYXJlZExpbWl0SWQgJiYgdGhpcy5zaG91bGRTaGFyZVN0cnVjdHVyZSAmJiAhdGhpcy5zaG91bGRTaGFyZVN0cnVjdHVyZShrZXlzKSkge1xuXHRcdFx0XHRyZWNvcmRJZCA9IHN0cnVjdHVyZXMubmV4dE93bklkO1xuXHRcdFx0XHRpZiAoIShyZWNvcmRJZCA8IG1heFN0cnVjdHVyZUlkKSlcblx0XHRcdFx0XHRyZWNvcmRJZCA9IHNoYXJlZExpbWl0SWQ7XG5cdFx0XHRcdHN0cnVjdHVyZXMubmV4dE93bklkID0gcmVjb3JkSWQgKyAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlY29yZElkID49IG1heFN0cnVjdHVyZUlkKS8vIGN5Y2xlIGJhY2sgYXJvdW5kXG5cdFx0XHRcdFx0cmVjb3JkSWQgPSBzaGFyZWRMaW1pdElkO1xuXHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHJlY29yZElkICsgMTtcblx0XHRcdH1cblx0XHRcdGxldCBoaWdoQnl0ZSA9IGtleXMuaGlnaEJ5dGUgPSByZWNvcmRJZCA+PSAweDYwICYmIHVzZVR3b0J5dGVSZWNvcmRzID8gKHJlY29yZElkIC0gMHg2MCkgPj4gNSA6IC0xO1xuXHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IHJlY29yZElkO1xuXHRcdFx0dHJhbnNpdGlvbi5fX2tleXNfXyA9IGtleXM7XG5cdFx0XHRzdHJ1Y3R1cmVzW3JlY29yZElkIC0gMHg0MF0gPSBrZXlzO1xuXG5cdFx0XHRpZiAocmVjb3JkSWQgPCBzaGFyZWRMaW1pdElkKSB7XG5cdFx0XHRcdGtleXMuaXNTaGFyZWQgPSB0cnVlO1xuXHRcdFx0XHRzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IHJlY29yZElkIC0gMHgzZjtcblx0XHRcdFx0aGFzU2hhcmVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0aWYgKGhpZ2hCeXRlID49IDApIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjA7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gaGlnaEJ5dGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChoaWdoQnl0ZSA+PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNTsgLy8gZml4ZXh0IDJcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyOyAvLyBcInJcIiByZWNvcmQgZGVmaW50aW9uIGV4dGVuc2lvbiB0eXBlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKHJlY29yZElkICYgMHgxZikgKyAweDYwO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGhpZ2hCeXRlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7IC8vIGZpeGV4dCAxXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3MjsgLy8gXCJyXCIgcmVjb3JkIGRlZmludGlvbiBleHRlbnNpb24gdHlwZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG5ld1RyYW5zaXRpb25zKVxuXHRcdFx0XHRcdHRyYW5zaXRpb25zQ291bnQgKz0gc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkICogbmV3VHJhbnNpdGlvbnM7XG5cdFx0XHRcdC8vIHJlY29yZCB0aGUgcmVtb3ZhbCBvZiB0aGUgaWQsIHdlIGNhbiBtYWludGFpbiBvdXIgc2hhcmVkIHN0cnVjdHVyZVxuXHRcdFx0XHRpZiAocmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoID49IG1heE93blN0cnVjdHVyZXMpXG5cdFx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUuc2hpZnQoKVtSRUNPUkRfU1lNQk9MXSA9IDA7IC8vIHdlIGFyZSBjeWNsaW5nIGJhY2sgdGhyb3VnaCwgYW5kIGhhdmUgdG8gcmVtb3ZlIG9sZCBvbmVzXG5cdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlLnB1c2godHJhbnNpdGlvbik7XG5cdFx0XHRcdHBhY2soa2V5cyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCBpbnNlcnROZXdSZWNvcmQgPSAodHJhbnNpdGlvbiwga2V5cywgaW5zZXJ0aW9uT2Zmc2V0LCBuZXdUcmFuc2l0aW9ucykgPT4ge1xuXHRcdFx0bGV0IG1haW5UYXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRsZXQgbWFpblBvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0XHRsZXQgbWFpblNhZmVFbmQgPSBzYWZlRW5kO1xuXHRcdFx0bGV0IG1haW5TdGFydCA9IHN0YXJ0O1xuXHRcdFx0dGFyZ2V0ID0ga2V5c1RhcmdldDtcblx0XHRcdHBvc2l0aW9uID0gMDtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdGlmICghdGFyZ2V0KVxuXHRcdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKDgxOTIpO1xuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCBrZXlzLCBuZXdUcmFuc2l0aW9ucyk7XG5cdFx0XHRrZXlzVGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0bGV0IGtleXNQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdFx0dGFyZ2V0ID0gbWFpblRhcmdldDtcblx0XHRcdHBvc2l0aW9uID0gbWFpblBvc2l0aW9uO1xuXHRcdFx0c2FmZUVuZCA9IG1haW5TYWZlRW5kO1xuXHRcdFx0c3RhcnQgPSBtYWluU3RhcnQ7XG5cdFx0XHRpZiAoa2V5c1Bvc2l0aW9uID4gMSkge1xuXHRcdFx0XHRsZXQgbmV3RW5kID0gcG9zaXRpb24gKyBrZXlzUG9zaXRpb24gLSAxO1xuXHRcdFx0XHRpZiAobmV3RW5kID4gc2FmZUVuZClcblx0XHRcdFx0XHRtYWtlUm9vbShuZXdFbmQpO1xuXHRcdFx0XHRsZXQgaW5zZXJ0aW9uUG9zaXRpb24gPSBpbnNlcnRpb25PZmZzZXQgKyBzdGFydDtcblx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4oaW5zZXJ0aW9uUG9zaXRpb24gKyBrZXlzUG9zaXRpb24sIGluc2VydGlvblBvc2l0aW9uICsgMSwgcG9zaXRpb24pO1xuXHRcdFx0XHR0YXJnZXQuc2V0KGtleXNUYXJnZXQuc2xpY2UoMCwga2V5c1Bvc2l0aW9uKSwgaW5zZXJ0aW9uUG9zaXRpb24pO1xuXHRcdFx0XHRwb3NpdGlvbiA9IG5ld0VuZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtpbnNlcnRpb25PZmZzZXQgKyBzdGFydF0gPSBrZXlzVGFyZ2V0WzBdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3Qgd3JpdGVTdHJ1Y3QgPSAob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV3UG9zaXRpb24gPSB3cml0ZVN0cnVjdFNsb3RzKG9iamVjdCwgdGFyZ2V0LCBzdGFydCwgcG9zaXRpb24sIHN0cnVjdHVyZXMsIG1ha2VSb29tLCAodmFsdWUsIG5ld1Bvc2l0aW9uLCBub3RpZnlTaGFyZWRVcGRhdGUpID0+IHtcblx0XHRcdFx0aWYgKG5vdGlmeVNoYXJlZFVwZGF0ZSlcblx0XHRcdFx0XHRyZXR1cm4gaGFzU2hhcmVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0cG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHRcdFx0bGV0IHN0YXJ0VGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRwYWNrKHZhbHVlKTtcblx0XHRcdFx0cmVzZXRTdHJ1Y3R1cmVzKCk7XG5cdFx0XHRcdGlmIChzdGFydFRhcmdldCAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgcG9zaXRpb24sIHRhcmdldFZpZXcsIHRhcmdldCB9OyAvLyBpbmRpY2F0ZSB0aGUgYnVmZmVyIHdhcyByZS1hbGxvY2F0ZWRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcG9zaXRpb247XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdGlmIChuZXdQb3NpdGlvbiA9PT0gMCkgLy8gYmFpbCBhbmQgZ28gdG8gYSBtc2dwYWNrIG9iamVjdFxuXHRcdFx0XHRyZXR1cm4gd3JpdGVPYmplY3Qob2JqZWN0KTtcblx0XHRcdHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0fTtcblx0fVxuXHR1c2VCdWZmZXIoYnVmZmVyKSB7XG5cdFx0Ly8gdGhpcyBtZWFucyB3ZSBhcmUgZmluaXNoZWQgdXNpbmcgb3VyIG93biBidWZmZXIgYW5kIHdlIGNhbiB3cml0ZSBvdmVyIGl0IHNhZmVseVxuXHRcdHRhcmdldCA9IGJ1ZmZlcjtcblx0XHR0YXJnZXQuZGF0YVZpZXcgfHwgKHRhcmdldC5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpKTtcblx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdHBvc2l0aW9uID0gMDtcblx0fVxuXHRzZXQgcG9zaXRpb24gKHZhbHVlKSB7XG5cdFx0cG9zaXRpb24gPSB2YWx1ZTtcblx0fVxuXHRnZXQgcG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHR9XG5cdGNsZWFyU2hhcmVkRGF0YSgpIHtcblx0XHRpZiAodGhpcy5zdHJ1Y3R1cmVzKVxuXHRcdFx0dGhpcy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0aWYgKHRoaXMudHlwZWRTdHJ1Y3RzKVxuXHRcdFx0dGhpcy50eXBlZFN0cnVjdHMgPSBbXTtcblx0fVxufVxuXG5leHRlbnNpb25DbGFzc2VzID0gWyBEYXRlLCBTZXQsIEVycm9yLCBSZWdFeHAsIEFycmF5QnVmZmVyLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yIC8qVHlwZWRBcnJheSovLCBEYXRhVmlldywgQzFUeXBlIF07XG5leHRlbnNpb25zID0gW3tcblx0cGFjayhkYXRlLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHNlY29uZHMgPSBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XG5cdFx0aWYgKCh0aGlzLnVzZVRpbWVzdGFtcDMyIHx8IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgPT09IDApICYmIHNlY29uZHMgPj0gMCAmJiBzZWNvbmRzIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdC8vIFRpbWVzdGFtcCAzMlxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDYpO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNjtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmY7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgc2Vjb25kcyk7XG5cdFx0fSBlbHNlIGlmIChzZWNvbmRzID4gMCAmJiBzZWNvbmRzIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdC8vIFRpbWVzdGFtcCA2NFxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDEwKTtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDc7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKiA0MDAwMDAwICsgKChzZWNvbmRzIC8gMTAwMCAvIDB4MTAwMDAwMDAwKSA+PiAwKSk7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiArIDQsIHNlY29uZHMpO1xuXHRcdH0gZWxzZSBpZiAoaXNOYU4oc2Vjb25kcykpIHtcblx0XHRcdGlmICh0aGlzLm9uSW52YWxpZERhdGUpIHtcblx0XHRcdFx0YWxsb2NhdGVGb3JXcml0ZSgwKTtcblx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy5vbkludmFsaWREYXRlKCkpXG5cdFx0XHR9XG5cdFx0XHQvLyBJbnRlbnRpb25hbGx5IGludmFsaWQgdGltZXN0YW1wXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMyk7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRpbWVzdGFtcCA5NlxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDE1KTtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzc7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAxMjtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmY7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIDEwMDAwMDApO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdJbnQ2NChwb3NpdGlvbiArIDQsIEJpZ0ludChNYXRoLmZsb29yKHNlY29uZHMpKSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdHBhY2soc2V0LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0aWYgKHRoaXMuc2V0QXNFbXB0eU9iamVjdCkge1xuXHRcdFx0YWxsb2NhdGVGb3JXcml0ZSgwKTtcblx0XHRcdHJldHVybiBwYWNrKHt9KVxuXHRcdH1cblx0XHRsZXQgYXJyYXkgPSBBcnJheS5mcm9tKHNldCk7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApO1xuXHRcdGlmICh0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzM7IC8vICdzJyBmb3IgU2V0XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwO1xuXHRcdH1cblx0XHRwYWNrKGFycmF5KTtcblx0fVxufSwge1xuXHRwYWNrKGVycm9yLCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApO1xuXHRcdGlmICh0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjU7IC8vICdlJyBmb3IgZXJyb3Jcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0fVxuXHRcdHBhY2soWyBlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlLCBlcnJvci5jYXVzZSBdKTtcblx0fVxufSwge1xuXHRwYWNrKHJlZ2V4LCBhbGxvY2F0ZUZvcldyaXRlLCBwYWNrKSB7XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKHRoaXMubW9yZVR5cGVzID8gMyA6IDApO1xuXHRcdGlmICh0aGlzLm1vcmVUeXBlcykge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Nzg7IC8vICd4JyBmb3IgcmVnZVhwXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwO1xuXHRcdH1cblx0XHRwYWNrKFsgcmVnZXguc291cmNlLCByZWdleC5mbGFncyBdKTtcblx0fVxufSwge1xuXHRwYWNrKGFycmF5QnVmZmVyLCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKVxuXHRcdFx0d3JpdGVFeHRCdWZmZXIoYXJyYXlCdWZmZXIsIDB4MTAsIGFsbG9jYXRlRm9yV3JpdGUpO1xuXHRcdGVsc2Vcblx0XHRcdHdyaXRlQnVmZmVyKGhhc05vZGVCdWZmZXIkMSA/IEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKSA6IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdH1cbn0sIHtcblx0cGFjayh0eXBlZEFycmF5LCBhbGxvY2F0ZUZvcldyaXRlKSB7XG5cdFx0bGV0IGNvbnN0cnVjdG9yID0gdHlwZWRBcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRpZiAoY29uc3RydWN0b3IgIT09IEJ5dGVBcnJheSAmJiB0aGlzLm1vcmVUeXBlcylcblx0XHRcdHdyaXRlRXh0QnVmZmVyKHR5cGVkQXJyYXksIHR5cGVkQXJyYXlzLmluZGV4T2YoY29uc3RydWN0b3IubmFtZSksIGFsbG9jYXRlRm9yV3JpdGUpO1xuXHRcdGVsc2Vcblx0XHRcdHdyaXRlQnVmZmVyKHR5cGVkQXJyYXksIGFsbG9jYXRlRm9yV3JpdGUpO1xuXHR9XG59LCB7XG5cdHBhY2soYXJyYXlCdWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcihhcnJheUJ1ZmZlciwgMHgxMSwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIoaGFzTm9kZUJ1ZmZlciQxID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhbGxvY2F0ZUZvcldyaXRlKTtcblx0fVxufSwge1xuXHRwYWNrKGMxLCBhbGxvY2F0ZUZvcldyaXRlKSB7IC8vIHNwZWNpZmljIDB4QzEgb2JqZWN0XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDEpO1xuXHRcdHRhcmdldFtwb3NpdGlvbl0gPSAweGMxO1xuXHR9XG59XTtcblxuZnVuY3Rpb24gd3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZSwgYWxsb2NhdGVGb3JXcml0ZSwgZW5jb2RlKSB7XG5cdGxldCBsZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG5cdGlmIChsZW5ndGggKyAxIDwgMHgxMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKDQgKyBsZW5ndGgpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzc7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICsgMTtcblx0fSBlbHNlIGlmIChsZW5ndGggKyAxIDwgMHgxMDAwMCkge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24gfSA9IGFsbG9jYXRlRm9yV3JpdGUoNSArIGxlbmd0aCk7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjODtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoICsgMSkgPj4gODtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoICsgMSkgJiAweGZmO1xuXHR9IGVsc2Uge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFZpZXcgfSA9IGFsbG9jYXRlRm9yV3JpdGUoNyArIGxlbmd0aCk7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOTtcblx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoICsgMSk7IC8vIHBsdXMgb25lIGZvciB0aGUgdHlwZSBieXRlXG5cdFx0cG9zaXRpb24gKz0gNDtcblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc0OyAvLyBcInRcIiBmb3IgdHlwZWQgYXJyYXlcblx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdHlwZTtcblx0aWYgKCF0eXBlZEFycmF5LmJ1ZmZlcikgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuXHR0YXJnZXQuc2V0KG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCksIHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyKGJ1ZmZlciwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRsZXQgbGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cdHZhciB0YXJnZXQsIHBvc2l0aW9uO1xuXHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDIpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzQ7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoO1xuXHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDMpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzU7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDUpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzY7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCk7XG5cdFx0cG9zaXRpb24gKz0gNDtcblx0fVxuXHR0YXJnZXQuc2V0KGJ1ZmZlciwgcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiB3cml0ZUV4dGVuc2lvbkRhdGEocmVzdWx0LCB0YXJnZXQsIHBvc2l0aW9uLCB0eXBlKSB7XG5cdGxldCBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXHRzd2l0Y2ggKGxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMjpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDU7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgNDpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDY7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgODpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDc7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMTY6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ4O1xuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzc7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM4O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzk7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiAyNDtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiAxNikgJiAweGZmO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoID4+IDgpICYgMHhmZjtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdH1cblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSB0eXBlO1xuXHR0YXJnZXQuc2V0KHJlc3VsdCwgcG9zaXRpb24pO1xuXHRwb3NpdGlvbiArPSBsZW5ndGg7XG5cdHJldHVybiBwb3NpdGlvblxufVxuXG5mdW5jdGlvbiBpbnNlcnRJZHMoc2VyaWFsaXplZCwgaWRzVG9JbnNlcnQpIHtcblx0Ly8gaW5zZXJ0IHRoZSBpZHMgdGhhdCBuZWVkIHRvIGJlIHJlZmVyZW5jZWQgZm9yIHN0cnVjdHVyZWQgY2xvbmVzXG5cdGxldCBuZXh0SWQ7XG5cdGxldCBkaXN0YW5jZVRvTW92ZSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aCAqIDY7XG5cdGxldCBsYXN0RW5kID0gc2VyaWFsaXplZC5sZW5ndGggLSBkaXN0YW5jZVRvTW92ZTtcblx0d2hpbGUgKG5leHRJZCA9IGlkc1RvSW5zZXJ0LnBvcCgpKSB7XG5cdFx0bGV0IG9mZnNldCA9IG5leHRJZC5vZmZzZXQ7XG5cdFx0bGV0IGlkID0gbmV4dElkLmlkO1xuXHRcdHNlcmlhbGl6ZWQuY29weVdpdGhpbihvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZSwgb2Zmc2V0LCBsYXN0RW5kKTtcblx0XHRkaXN0YW5jZVRvTW92ZSAtPSA2O1xuXHRcdGxldCBwb3NpdGlvbiA9IG9mZnNldCArIGRpc3RhbmNlVG9Nb3ZlO1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweGQ2O1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweDY5OyAvLyAnaSdcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgPj4gMjQ7XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiAxNikgJiAweGZmO1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAoaWQgPj4gOCkgJiAweGZmO1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSBpZCAmIDB4ZmY7XG5cdFx0bGFzdEVuZCA9IG9mZnNldDtcblx0fVxuXHRyZXR1cm4gc2VyaWFsaXplZFxufVxuXG5mdW5jdGlvbiB3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIGluY3JlbWVudFBvc2l0aW9uKSB7XG5cdGlmIChidW5kbGVkU3RyaW5ncy5sZW5ndGggPiAwKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24gKyBzdGFydCwgcG9zaXRpb24gKyBpbmNyZW1lbnRQb3NpdGlvbiAtIGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uIC0gc3RhcnQpO1xuXHRcdGJ1bmRsZWRTdHJpbmdzLnN0cmluZ3NQb3NpdGlvbiA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0bGV0IHdyaXRlU3RyaW5ncyA9IGJ1bmRsZWRTdHJpbmdzO1xuXHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcblx0XHRwYWNrKHdyaXRlU3RyaW5nc1swXSk7XG5cdFx0cGFjayh3cml0ZVN0cmluZ3NbMV0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbihleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi5DbGFzcykge1xuXHRcdGlmICghZXh0ZW5zaW9uLnBhY2sgJiYgIWV4dGVuc2lvbi53cml0ZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyBwYWNrIG9yIHdyaXRlIGZ1bmN0aW9uJylcblx0XHRpZiAoZXh0ZW5zaW9uLnBhY2sgJiYgIWV4dGVuc2lvbi50eXBlKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gaGFzIG5vIHR5cGUgKG51bWVyaWMgY29kZSB0byBpZGVudGlmeSB0aGUgZXh0ZW5zaW9uKScpXG5cdFx0ZXh0ZW5zaW9uQ2xhc3Nlcy51bnNoaWZ0KGV4dGVuc2lvbi5DbGFzcyk7XG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KGV4dGVuc2lvbik7XG5cdH1cblx0YWRkRXh0ZW5zaW9uJDEoZXh0ZW5zaW9uKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTdHJ1Y3R1cmVzJDEoc3RydWN0dXJlcywgcGFja3IpIHtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSAoZXhpc3RpbmdTdHJ1Y3R1cmVzKSA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSAhZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8ICgocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSA9PT0gZXhpc3RpbmdTdHJ1Y3R1cmVzLmxlbmd0aCk7XG5cdFx0aWYgKCFjb21wYXRpYmxlKSAvLyB3ZSB3YW50IHRvIG1lcmdlIHRoZXNlIGV4aXN0aW5nIHN0cnVjdHVyZXMgaW1tZWRpYXRlbHkgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIGl0IGFuZCB3ZSBhcmUgaW4gdGhlIHJpZ2h0IHRyYW5zYWN0aW9uXG5cdFx0XHRwYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGV4aXN0aW5nU3RydWN0dXJlcyk7XG5cdFx0cmV0dXJuIGNvbXBhdGlibGU7XG5cdH07XG5cdHJldHVybiBzdHJ1Y3R1cmVzXG59XG5mdW5jdGlvbiBzZXRXcml0ZVN0cnVjdFNsb3RzKHdyaXRlU2xvdHMsIG1ha2VTdHJ1Y3R1cmVzKSB7XG5cdHdyaXRlU3RydWN0U2xvdHMgPSB3cml0ZVNsb3RzO1xuXHRwcmVwYXJlU3RydWN0dXJlcyQxID0gbWFrZVN0cnVjdHVyZXM7XG59XG5cbmxldCBkZWZhdWx0UGFja3IgPSBuZXcgUGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KTtcbmNvbnN0IHBhY2sgPSBkZWZhdWx0UGFja3IucGFjaztcbmNvbnN0IGVuY29kZSA9IGRlZmF1bHRQYWNrci5wYWNrO1xuY29uc3QgRW5jb2RlciA9IFBhY2tyO1xuY29uc3QgeyBORVZFUiwgQUxXQVlTLCBERUNJTUFMX1JPVU5ELCBERUNJTUFMX0ZJVCB9ID0gRkxPQVQzMl9PUFRJT05TO1xuY29uc3QgUkVVU0VfQlVGRkVSX01PREUgPSA1MTI7XG5jb25zdCBSRVNFVF9CVUZGRVJfTU9ERSA9IDEwMjQ7XG5jb25zdCBSRVNFUlZFX1NUQVJUX1NQQUNFID0gMjA0ODtcblxuY29uc3QgQVNDSUkgPSAzOyAvLyB0aGUgTUlCZW51bSBmcm9tIGh0dHBzOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2NoYXJhY3Rlci1zZXRzL2NoYXJhY3Rlci1zZXRzLnhodG1sIChhbmQgb3RoZXIgY2hhcmFjdGVyIGVuY29kaW5ncyBjb3VsZCBiZSByZWZlcmVuY2VkIGJ5IE1JQmVudW0pXG5jb25zdCBOVU1CRVIgPSAwO1xuY29uc3QgVVRGOCA9IDI7XG5jb25zdCBPQkpFQ1RfREFUQSA9IDE7XG5jb25zdCBEQVRFID0gMTY7XG5jb25zdCBUWVBFX05BTUVTID0gWydudW0nLCAnb2JqZWN0JywgJ3N0cmluZycsICdhc2NpaSddO1xuVFlQRV9OQU1FU1tEQVRFXSA9ICdkYXRlJztcbmNvbnN0IGZsb2F0MzJIZWFkZXJzID0gW2ZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWUsIHRydWUsIGZhbHNlXTtcbmxldCBldmFsU3VwcG9ydGVkO1xudHJ5IHtcblx0bmV3IEZ1bmN0aW9uKCcnKTtcblx0ZXZhbFN1cHBvcnRlZCA9IHRydWU7XG59IGNhdGNoKGVycm9yKSB7XG5cdC8vIGlmIGV2YWwgdmFyaWFudHMgYXJlIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdCBjcmVhdGUgaW5saW5lIG9iamVjdCByZWFkZXJzIGV2ZXJcbn1cblxubGV0IHVwZGF0ZWRQb3NpdGlvbjtcbmNvbnN0IGhhc05vZGVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJztcbmxldCB0ZXh0RW5jb2RlciwgY3VycmVudFNvdXJjZTtcbnRyeSB7XG5cdHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG59IGNhdGNoIChlcnJvcikge31cbmNvbnN0IGVuY29kZVV0ZjggPSBoYXNOb2RlQnVmZmVyID8gZnVuY3Rpb24odGFyZ2V0LCBzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdHJldHVybiB0YXJnZXQudXRmOFdyaXRlKHN0cmluZywgcG9zaXRpb24sIHRhcmdldC5ieXRlTGVuZ3RoIC0gcG9zaXRpb24pXG59IDogKHRleHRFbmNvZGVyICYmIHRleHRFbmNvZGVyLmVuY29kZUludG8pID9cblx0ZnVuY3Rpb24odGFyZ2V0LCBzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyaW5nLCB0YXJnZXQuc3ViYXJyYXkocG9zaXRpb24pKS53cml0dGVuXG5cdH0gOiBmYWxzZTtcbnNldFdyaXRlU3RydWN0U2xvdHMod3JpdGVTdHJ1Y3QsIHByZXBhcmVTdHJ1Y3R1cmVzKTtcbmZ1bmN0aW9uIHdyaXRlU3RydWN0KG9iamVjdCwgdGFyZ2V0LCBlbmNvZGluZ1N0YXJ0LCBwb3NpdGlvbiwgc3RydWN0dXJlcywgbWFrZVJvb20sIHBhY2ssIHBhY2tyKSB7XG5cdGxldCB0eXBlZFN0cnVjdHMgPSBwYWNrci50eXBlZFN0cnVjdHMgfHwgKHBhY2tyLnR5cGVkU3RydWN0cyA9IFtdKTtcblx0Ly8gbm90ZSB0aGF0IHdlIHJlbHkgb24gcGFjay5qcyB0byBsb2FkIHN0b3JlZCBzdHJ1Y3R1cmVzIGJlZm9yZSB3ZSBnZXQgdG8gdGhpcyBwb2ludFxuXHRsZXQgdGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0bGV0IHJlZnNTdGFydFBvc2l0aW9uID0gKHR5cGVkU3RydWN0cy5sYXN0U3RyaW5nU3RhcnQgfHwgMTAwKSArIHBvc2l0aW9uO1xuXHRsZXQgc2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0bGV0IHN0YXJ0ID0gcG9zaXRpb247XG5cdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHR9XG5cblx0bGV0IHJlZk9mZnNldCwgcmVmUG9zaXRpb24gPSByZWZzU3RhcnRQb3NpdGlvbjtcblxuXHRsZXQgdHJhbnNpdGlvbiA9IHR5cGVkU3RydWN0cy50cmFuc2l0aW9ucyB8fCAodHlwZWRTdHJ1Y3RzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdGxldCBuZXh0SWQgPSB0eXBlZFN0cnVjdHMubmV4dElkIHx8IHR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdGxldCBoZWFkZXJTaXplID1cblx0XHRuZXh0SWQgPCAweGYgPyAxIDpcblx0XHRcdG5leHRJZCA8IDB4ZjAgPyAyIDpcblx0XHRcdFx0bmV4dElkIDwgMHhmMDAwID8gMyA6XG5cdFx0XHRcdFx0bmV4dElkIDwgMHhmMDAwMDAgPyA0IDogMDtcblx0aWYgKGhlYWRlclNpemUgPT09IDApXG5cdFx0cmV0dXJuIDA7XG5cdHBvc2l0aW9uICs9IGhlYWRlclNpemU7XG5cdGxldCBxdWV1ZWRSZWZlcmVuY2VzID0gW107XG5cdGxldCB1c2VkQXNjaWkwO1xuXHRsZXQga2V5SW5kZXggPSAwO1xuXHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0bGV0IHZhbHVlID0gb2JqZWN0W2tleV07XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IDAsXG5cdFx0XHRcdGFzY2lpMDogbnVsbCxcblx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRzdHJpbmcxNjogbnVsbCxcblx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRmbG9hdDY0OiBudWxsLFxuXHRcdFx0XHRkYXRlNjQ6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uKTtcblx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRyZWZQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdH1cblx0XHRzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuXHRcdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRcdFx0bGV0IG51bWJlciA9IHZhbHVlO1xuXHRcdFx0XHQvLyBmaXJzdCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIHVzaW5nIGEgbG90IG9mIGlkcyBhbmQgc2hvdWxkIGRlZmF1bHQgdG8gd2lkZS9jb21tb24gZm9ybWF0XG5cdFx0XHRcdGlmIChuZXh0SWQgPCAyMDAgfHwgIW5leHRUcmFuc2l0aW9uLm51bTY0KSB7XG5cdFx0XHRcdFx0aWYgKG51bWJlciA+PiAwID09PSBudW1iZXIgJiYgbnVtYmVyIDwgMHgyMDAwMDAwMCAmJiBudW1iZXIgPiAtMHgxZjAwMDAwMCkge1xuXHRcdFx0XHRcdFx0aWYgKG51bWJlciA8IDB4ZjYgJiYgbnVtYmVyID49IDAgJiYgKG5leHRUcmFuc2l0aW9uLm51bTggJiYgIShuZXh0SWQgPiAyMDAgJiYgbmV4dFRyYW5zaXRpb24ubnVtMzIpIHx8IG51bWJlciA8IDB4MjAgJiYgIW5leHRUcmFuc2l0aW9uLm51bTMyKSkge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtOCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCAxKTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbnVtYmVyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDQpO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbnVtYmVyLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAgJiYgbnVtYmVyID49IC0weDgwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0MzIocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoZmxvYXQzMkhlYWRlcnNbdGFyZ2V0W3Bvc2l0aW9uICsgM10gPj4+IDVdKSB7XG5cdFx0XHRcdFx0XHRcdGxldCB4U2hpZnRlZDtcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBjaGVja3MgZm9yIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRpZiAoKCh4U2hpZnRlZCA9IG51bWJlciAqIG11bHQxMFsoKHRhcmdldFtwb3NpdGlvbiArIDNdICYgMHg3ZikgPDwgMSkgfCAodGFyZ2V0W3Bvc2l0aW9uICsgMl0gPj4gNyldKSA+PiAwKSA9PT0geFNoaWZ0ZWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtMzIgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgNCk7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtNjQgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgOCk7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgbnVtYmVyLCB0cnVlKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0XHRsZXQgc3RyTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRyZWZPZmZzZXQgPSByZWZQb3NpdGlvbiAtIHJlZnNTdGFydFBvc2l0aW9uO1xuXHRcdFx0XHRpZiAoKHN0ckxlbmd0aCA8PCAyKSArIHJlZlBvc2l0aW9uID4gc2FmZUVuZCkge1xuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKChzdHJMZW5ndGggPDwgMikgKyByZWZQb3NpdGlvbik7XG5cdFx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRyZWZQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA+ICgoMHhmZjAwICsgcmVmT2Zmc2V0KSA+PiAyKSkge1xuXHRcdFx0XHRcdHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBwb3NpdGlvbiAtIHN0YXJ0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaXNOb3RBc2NpaTtcblx0XHRcdFx0bGV0IHN0clN0YXJ0ID0gcmVmUG9zaXRpb247XG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDQwKSB7XG5cdFx0XHRcdFx0bGV0IGksIGMxLCBjMjtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0XHRcdGlmIChjMSA8IDB4ODApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzE7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMxIDwgMHg4MDApIHtcblx0XHRcdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgfCAweGMwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0KGMxICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG5cdFx0XHRcdFx0XHRcdCgoYzIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweGZjMDApID09PSAweGRjMDBcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRpc05vdEFzY2lpID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxOCB8IDB4ZjA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDEyICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlzTm90QXNjaWkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxMiB8IDB4ZTA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVmUG9zaXRpb24gKz0gZW5jb2RlVXRmOCh0YXJnZXQsIHZhbHVlLCByZWZQb3NpdGlvbik7XG5cdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHJlZlBvc2l0aW9uIC0gc3RyU3RhcnQgPiBzdHJMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlZk9mZnNldCA8IDB4YTAgfHwgKHJlZk9mZnNldCA8IDB4ZjYgJiYgKG5leHRUcmFuc2l0aW9uLmFzY2lpOCB8fCBuZXh0VHJhbnNpdGlvbi5zdHJpbmc4KSkpIHtcblx0XHRcdFx0XHQvLyBzaG9ydCBzdHJpbmdzXG5cdFx0XHRcdFx0aWYgKGlzTm90QXNjaWkpIHtcblx0XHRcdFx0XHRcdGlmICghKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5zdHJpbmc4KSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZWRTdHJ1Y3RzLmxlbmd0aCA+IDEwICYmICh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWk4KSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGNhbiBzYWZlbHkgY2hhbmdlIGFzY2lpIHRvIHV0ZjggaW4gcGxhY2Ugc2luY2UgdGhleSBhcmUgY29tcGF0aWJsZVxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24uX190eXBlID0gVVRGODtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbi5hc2NpaTggPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uLnN0cmluZzggPSB0cmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdHBhY2sobnVsbCwgMCwgdHJ1ZSk7IC8vIHNwZWNpYWwgY2FsbCB0byBub3RpZnkgdGhhdCBzdHJ1Y3R1cmVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBVVEY4LCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmVmT2Zmc2V0ID09PSAwICYmICF1c2VkQXNjaWkwKSB7XG5cdFx0XHRcdFx0XHR1c2VkQXNjaWkwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTAgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIEFTQ0lJLCAwKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBkb24ndCBpbmNyZW1lbnQgcG9zaXRpb25cblx0XHRcdFx0XHR9Ly8gZWxzZSBhc2NpaTpcblx0XHRcdFx0XHRlbHNlIGlmICghKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTgpICYmICEodHlwZWRTdHJ1Y3RzLmxlbmd0aCA+IDEwICYmICh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpKVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMSk7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVmT2Zmc2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFRPRE86IEVuYWJsZSBhc2NpaTE2IGF0IHNvbWUgcG9pbnQsIGJ1dCBnZXQgdGhlIGxvZ2ljIHJpZ2h0XG5cdFx0XHRcdFx0Ly9pZiAoaXNOb3RBc2NpaSlcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5zdHJpbmcxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgVVRGOCwgMik7XG5cdFx0XHRcdFx0Ly9lbHNlXG5cdFx0XHRcdFx0XHQvL3RyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTE2IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMik7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmRhdGU2NCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgREFURSwgOCk7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIHZhbHVlLmdldFRpbWUoKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHsgLy8gbnVsbFxuXHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gYW55VHlwZShuZXh0VHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIC0xMCk7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGlzXG5cdFx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHVwZGF0ZWRQb3NpdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgcXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtOCB8fCBuZXh0VHJhbnNpdGlvbi5hc2NpaTggfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgMSk7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID8gMHhmOSA6IDB4Zjg7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGVzZVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3VuZGVmaW5lZCc6XG5cdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gYW55VHlwZShuZXh0VHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIC05KTsgLy8gbWF0Y2ggQ0JPUiB3aXRoIHRoaXNcblx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdHBvc2l0aW9uID0gdXBkYXRlZFBvc2l0aW9uO1xuXHRcdFx0XHR9IGVsc2UgcXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdH1cblx0XHRrZXlJbmRleCsrO1xuXHR9XG5cblx0Zm9yIChsZXQgaSA9IDAsIGwgPSBxdWV1ZWRSZWZlcmVuY2VzLmxlbmd0aDsgaSA8IGw7KSB7XG5cdFx0bGV0IGtleSA9IHF1ZXVlZFJlZmVyZW5jZXNbaSsrXTtcblx0XHRsZXQgdmFsdWUgPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IHByb3BlcnR5SW5kZXggPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IHByb3BlcnR5SW5kZXggLSBrZXlJbmRleCxcblx0XHRcdFx0YXNjaWkwOiBudWxsLFxuXHRcdFx0XHRhc2NpaTg6IG51bGwsXG5cdFx0XHRcdG51bTg6IG51bGwsXG5cdFx0XHRcdHN0cmluZzE2OiBudWxsLFxuXHRcdFx0XHRvYmplY3QxNjogbnVsbCxcblx0XHRcdFx0bnVtMzI6IG51bGwsXG5cdFx0XHRcdGZsb2F0NjQ6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXHRcdGxldCBuZXdQb3NpdGlvbjtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdC8qaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgLy8gVE9ETzogd2UgY291bGQgcmUtZW5hYmxlIGxvbmcgc3RyaW5nc1xuXHRcdFx0XHRpZiAocG9zaXRpb24gKyB2YWx1ZS5sZW5ndGggKiAzID4gc2FmZUVuZCkge1xuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgdmFsdWUubGVuZ3RoICogMyk7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gc3RhcnQ7XG5cdFx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3UG9zaXRpb24gPSBwb3NpdGlvbiArIHRhcmdldC51dGY4V3JpdGUodmFsdWUsIHBvc2l0aW9uLCAweGZmZmZmZmZmKTtcblx0XHRcdH0gZWxzZSB7ICovXG5cdFx0XHRsZXQgc2l6ZTtcblx0XHRcdHJlZk9mZnNldCA9IHJlZlBvc2l0aW9uIC0gcmVmc1N0YXJ0UG9zaXRpb247XG5cdFx0XHRpZiAocmVmT2Zmc2V0IDwgMHhmZjAwKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QxNjtcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24pXG5cdFx0XHRcdFx0c2l6ZSA9IDI7XG5cdFx0XHRcdGVsc2UgaWYgKCh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MzIpKVxuXHRcdFx0XHRcdHNpemUgPSA0O1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE9CSkVDVF9EQVRBLCAyKTtcblx0XHRcdFx0XHRzaXplID0gMjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgNCk7XG5cdFx0XHRcdHNpemUgPSA0O1xuXHRcdFx0fVxuXHRcdFx0bmV3UG9zaXRpb24gPSBwYWNrKHZhbHVlLCByZWZQb3NpdGlvbik7XG5cdFx0XHQvL31cblx0XHRcdGlmICh0eXBlb2YgbmV3UG9zaXRpb24gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdC8vIHJlLWFsbG9jYXRlZFxuXHRcdFx0XHRyZWZQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uLnBvc2l0aW9uO1xuXHRcdFx0XHR0YXJnZXRWaWV3ID0gbmV3UG9zaXRpb24udGFyZ2V0Vmlldztcblx0XHRcdFx0dGFyZ2V0ID0gbmV3UG9zaXRpb24udGFyZ2V0O1xuXHRcdFx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRyZWZQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdFx0aWYgKHNpemUgPT09IDIpIHtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgcmVmT2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZFxuXHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDE2IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgMik7XG5cdFx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSA9PT0gbnVsbCA/IC0xMCA6IC05LCB0cnVlKTtcblx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0fVxuXHRcdGtleUluZGV4Kys7XG5cdH1cblxuXG5cdGxldCByZWNvcmRJZCA9IHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF07XG5cdGlmIChyZWNvcmRJZCA9PSBudWxsKSB7XG5cdFx0cmVjb3JkSWQgPSBwYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRcdGxldCBzdHJ1Y3R1cmUgPSBbXTtcblx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHRcdGxldCBrZXksIHR5cGU7XG5cdFx0d2hpbGUgKCh0eXBlID0gbmV4dFRyYW5zaXRpb24uX190eXBlKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsZXQgc2l6ZSA9IG5leHRUcmFuc2l0aW9uLl9fc2l6ZTtcblx0XHRcdG5leHRUcmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uX19wYXJlbnQ7XG5cdFx0XHRrZXkgPSBuZXh0VHJhbnNpdGlvbi5rZXk7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSBbdHlwZSwgc2l6ZSwga2V5XTtcblx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbi5lbnVtZXJhdGlvbk9mZnNldClcblx0XHRcdFx0cHJvcGVydHkucHVzaChuZXh0VHJhbnNpdGlvbi5lbnVtZXJhdGlvbk9mZnNldCk7XG5cdFx0XHRzdHJ1Y3R1cmUucHVzaChwcm9wZXJ0eSk7XG5cdFx0XHRuZXh0VHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnBhcmVudDtcblx0XHR9XG5cdFx0c3RydWN0dXJlLnJldmVyc2UoKTtcblx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gcmVjb3JkSWQ7XG5cdFx0cGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXSA9IHN0cnVjdHVyZTtcblx0XHRwYWNrKG51bGwsIDAsIHRydWUpOyAvLyBzcGVjaWFsIGNhbGwgdG8gbm90aWZ5IHRoYXQgc3RydWN0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHR9XG5cblxuXHRzd2l0Y2ggKGhlYWRlclNpemUpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gcmVjb3JkSWQgKyAweDIwO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFtzdGFydF0gPSAweDM4O1xuXHRcdFx0dGFyZ2V0W3N0YXJ0ICsgMV0gPSByZWNvcmRJZDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwMDAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFtzdGFydF0gPSAweDM5O1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYoc3RhcnQgKyAxLCByZWNvcmRJZCwgdHJ1ZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMDAwMDAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHN0YXJ0LCAocmVjb3JkSWQgPDwgOCkgKyAweDNhLCB0cnVlKTtcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0aWYgKHBvc2l0aW9uIDwgcmVmc1N0YXJ0UG9zaXRpb24pIHtcblx0XHRpZiAocmVmc1N0YXJ0UG9zaXRpb24gPT09IHJlZlBvc2l0aW9uKVxuXHRcdFx0cmV0dXJuIHBvc2l0aW9uOyAvLyBubyByZWZzXG5cdFx0Ly8gYWRqdXN0IHBvc2l0aW9uaW5nXG5cdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24sIHJlZnNTdGFydFBvc2l0aW9uLCByZWZQb3NpdGlvbik7XG5cdFx0cmVmUG9zaXRpb24gKz0gcG9zaXRpb24gLSByZWZzU3RhcnRQb3NpdGlvbjtcblx0XHR0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0fSBlbHNlIGlmIChwb3NpdGlvbiA+IHJlZnNTdGFydFBvc2l0aW9uKSB7XG5cdFx0aWYgKHJlZnNTdGFydFBvc2l0aW9uID09PSByZWZQb3NpdGlvbilcblx0XHRcdHJldHVybiBwb3NpdGlvbjsgLy8gbm8gcmVmc1xuXHRcdHR5cGVkU3RydWN0cy5sYXN0U3RyaW5nU3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdHJldHVybiB3cml0ZVN0cnVjdChvYmplY3QsIHRhcmdldCwgZW5jb2RpbmdTdGFydCwgc3RhcnQsIHN0cnVjdHVyZXMsIG1ha2VSb29tLCBwYWNrLCBwYWNrcik7XG5cdH1cblx0cmV0dXJuIHJlZlBvc2l0aW9uO1xufVxuZnVuY3Rpb24gYW55VHlwZSh0cmFuc2l0aW9uLCBwb3NpdGlvbiwgdGFyZ2V0VmlldywgdmFsdWUpIHtcblx0bGV0IG5leHRUcmFuc2l0aW9uO1xuXHRpZiAoKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5hc2NpaTggfHwgdHJhbnNpdGlvbi5udW04KSkge1xuXHRcdHRhcmdldFZpZXcuc2V0SW50OChwb3NpdGlvbiwgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgMTtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0aWYgKChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24uc3RyaW5nMTYgfHwgdHJhbnNpdGlvbi5vYmplY3QxNikpIHtcblx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSwgdHJ1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyAyO1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHRpZiAobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLm51bTMyKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIDB4ZTAwMDAxMDAgKyB2YWx1ZSwgdHJ1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyA0O1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHQvLyB0cmFuc2l0aW9uLmZsb2F0NjRcblx0aWYgKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5udW02NCkge1xuXHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTmFOLCB0cnVlKTtcblx0XHR0YXJnZXRWaWV3LnNldEludDgocG9zaXRpb24sIHZhbHVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDg7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHQvLyBUT0RPOiBjYW4gd2UgZG8gYW4gXCJhbnlcIiB0eXBlIHdoZXJlIHdlIGRlZmVyIHRoZSBkZWNpc2lvbj9cblx0cmV0dXJuO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVRyYW5zaXRpb24odHJhbnNpdGlvbiwgdHlwZSwgc2l6ZSkge1xuXHRsZXQgdHlwZU5hbWUgPSBUWVBFX05BTUVTW3R5cGVdICsgKHNpemUgPDwgMyk7XG5cdGxldCBuZXdUcmFuc2l0aW9uID0gdHJhbnNpdGlvblt0eXBlTmFtZV0gfHwgKHRyYW5zaXRpb25bdHlwZU5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdG5ld1RyYW5zaXRpb24uX190eXBlID0gdHlwZTtcblx0bmV3VHJhbnNpdGlvbi5fX3NpemUgPSBzaXplO1xuXHRuZXdUcmFuc2l0aW9uLl9fcGFyZW50ID0gdHJhbnNpdGlvbjtcblx0cmV0dXJuIG5ld1RyYW5zaXRpb247XG59XG5mdW5jdGlvbiBvbkxvYWRlZFN0cnVjdHVyZXMoc2hhcmVkRGF0YSkge1xuXHRpZiAoIShzaGFyZWREYXRhIGluc3RhbmNlb2YgTWFwKSlcblx0XHRyZXR1cm4gc2hhcmVkRGF0YTtcblx0bGV0IHR5cGVkID0gc2hhcmVkRGF0YS5nZXQoJ3R5cGVkJykgfHwgW107XG5cdGlmIChPYmplY3QuaXNGcm96ZW4odHlwZWQpKVxuXHRcdHR5cGVkID0gdHlwZWQubWFwKHN0cnVjdHVyZSA9PiBzdHJ1Y3R1cmUuc2xpY2UoMCkpO1xuXHRsZXQgbmFtZWQgPSBzaGFyZWREYXRhLmdldCgnbmFtZWQnKTtcblx0bGV0IHRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0eXBlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRsZXQgc3RydWN0dXJlID0gdHlwZWRbaV07XG5cdFx0bGV0IHRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucztcblx0XHRmb3IgKGxldCBbdHlwZSwgc2l6ZSwga2V5XSBvZiBzdHJ1Y3R1cmUpIHtcblx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0dHJhbnNpdGlvbltrZXldID0gbmV4dFRyYW5zaXRpb24gPSB7XG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0XHRlbnVtZXJhdGlvbk9mZnNldDogMCxcblx0XHRcdFx0XHRhc2NpaTA6IG51bGwsXG5cdFx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRcdG51bTg6IG51bGwsXG5cdFx0XHRcdFx0c3RyaW5nMTY6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdFx0bnVtMzI6IG51bGwsXG5cdFx0XHRcdFx0ZmxvYXQ2NDogbnVsbCxcblx0XHRcdFx0XHRkYXRlNjQ6IG51bGwsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIHR5cGUsIHNpemUpO1xuXHRcdH1cblx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gaTtcblx0fVxuXHR0eXBlZC50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuXHR0aGlzLnR5cGVkU3RydWN0cyA9IHR5cGVkO1xuXHR0aGlzLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSB0eXBlZC5sZW5ndGg7XG5cdHJldHVybiBuYW1lZDtcbn1cbnZhciBzb3VyY2VTeW1ib2wgPSBTeW1ib2wuZm9yKCdzb3VyY2UnKTtcbmZ1bmN0aW9uIHJlYWRTdHJ1Y3Qoc3JjLCBwb3NpdGlvbiwgc3JjRW5kLCB1bnBhY2tyKSB7XG5cdGxldCByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSAtIDB4MjA7XG5cdGlmIChyZWNvcmRJZCA+PSAyNCkge1xuXHRcdHN3aXRjaChyZWNvcmRJZCkge1xuXHRcdFx0Y2FzZSAyNDogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK107IGJyZWFrO1xuXHRcdFx0Ly8gbGl0dGxlIGVuZGlhbjpcblx0XHRcdGNhc2UgMjU6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdICsgKHNyY1twb3NpdGlvbisrXSA8PCA4KTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI2OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCkgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDE2KTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI3OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCkgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDE2KSArIChzcmNbcG9zaXRpb24rK10gPDwgMjQpOyBicmVhaztcblx0XHR9XG5cdH1cblx0bGV0IHN0cnVjdHVyZSA9IHVucGFja3IudHlwZWRTdHJ1Y3RzICYmIHVucGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXTtcblx0aWYgKCFzdHJ1Y3R1cmUpIHtcblx0XHQvLyBjb3B5IHNyYyBidWZmZXIgYmVjYXVzZSBnZXRTdHJ1Y3R1cmVzIHdpbGwgb3ZlcnJpZGUgaXRcblx0XHRzcmMgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24sIHNyY0VuZCk7XG5cdFx0c3JjRW5kIC09IHBvc2l0aW9uO1xuXHRcdHBvc2l0aW9uID0gMDtcblx0XHRpZiAoIXVucGFja3IuZ2V0U3RydWN0dXJlcylcblx0XHRcdHRocm93IG5ldyBFcnJvcihgUmVmZXJlbmNlIHRvIHNoYXJlZCBzdHJ1Y3R1cmUgJHtyZWNvcmRJZH0gd2l0aG91dCBnZXRTdHJ1Y3R1cmVzIG1ldGhvZGApO1xuXHRcdHVucGFja3IuX21lcmdlU3RydWN0dXJlcyh1bnBhY2tyLmdldFN0cnVjdHVyZXMoKSk7XG5cdFx0aWYgKCF1bnBhY2tyLnR5cGVkU3RydWN0cylcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYW55IHNoYXJlZCB0eXBlZCBzdHJ1Y3R1cmVzJyk7XG5cdFx0dW5wYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gdW5wYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRcdHN0cnVjdHVyZSA9IHVucGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXTtcblx0XHRpZiAoIXN0cnVjdHVyZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdHlwZWQgc3RydWN0dXJlICcgKyByZWNvcmRJZCk7XG5cdH1cblx0dmFyIGNvbnN0cnVjdCA9IHN0cnVjdHVyZS5jb25zdHJ1Y3Q7XG5cdHZhciBmdWxsQ29uc3RydWN0ID0gc3RydWN0dXJlLmZ1bGxDb25zdHJ1Y3Q7XG5cdGlmICghY29uc3RydWN0KSB7XG5cdFx0Y29uc3RydWN0ID0gc3RydWN0dXJlLmNvbnN0cnVjdCA9IGZ1bmN0aW9uIExhenlPYmplY3QoKSB7XG5cdFx0fTtcblx0XHRmdWxsQ29uc3RydWN0ID0gc3RydWN0dXJlLmZ1bGxDb25zdHJ1Y3QgPSBmdW5jdGlvbiBMb2FkZWRPYmplY3QoKSB7XG5cdFx0fTtcblx0XHRmdWxsQ29uc3RydWN0LnByb3RvdHlwZSA9IHVucGFja3Iuc3RydWN0UHJvdG90eXBlIHx8IHt9O1xuXHRcdHZhciBwcm90b3R5cGUgPSBjb25zdHJ1Y3QucHJvdG90eXBlID0gdW5wYWNrci5zdHJ1Y3RQcm90b3R5cGUgPyBPYmplY3QuY3JlYXRlKHVucGFja3Iuc3RydWN0UHJvdG90eXBlKSA6IHt9O1xuXHRcdGxldCBwcm9wZXJ0aWVzID0gW107XG5cdFx0bGV0IGN1cnJlbnRPZmZzZXQgPSAwO1xuXHRcdGxldCBsYXN0UmVmUHJvcGVydHk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBzdHJ1Y3R1cmUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgZGVmaW5pdGlvbiA9IHN0cnVjdHVyZVtpXTtcblx0XHRcdGxldCBbIHR5cGUsIHNpemUsIGtleSwgZW51bWVyYXRpb25PZmZzZXQgXSA9IGRlZmluaXRpb247XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdGxldCBwcm9wZXJ0eSA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRvZmZzZXQ6IGN1cnJlbnRPZmZzZXQsXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGVudW1lcmF0aW9uT2Zmc2V0KVxuXHRcdFx0XHRwcm9wZXJ0aWVzLnNwbGljZShpICsgZW51bWVyYXRpb25PZmZzZXQsIDAsIHByb3BlcnR5KTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblx0XHRcdGxldCBnZXRSZWY7XG5cdFx0XHRzd2l0Y2goc2l6ZSkgeyAvLyBUT0RPOiBNb3ZlIGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvblxuXHRcdFx0XHRjYXNlIDA6IGdldFJlZiA9ICgpID0+IDA7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0Z2V0UmVmID0gKHNvdXJjZSwgcG9zaXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBzb3VyY2UuYnl0ZXNbcG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZiA+PSAweGY2ID8gdG9Db25zdGFudChyZWYpIDogcmVmO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRnZXRSZWYgPSAoc291cmNlLCBwb3NpdGlvbikgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmID49IDB4ZmYwMCA/IHRvQ29uc3RhbnQocmVmICYgMHhmZikgOiByZWY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdGdldFJlZiA9IChzb3VyY2UsIHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdHJldHVybiByZWYgPj0gMHhmZmZmZmYwMCA/IHRvQ29uc3RhbnQocmVmICYgMHhmZikgOiByZWY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHByb3BlcnR5LmdldFJlZiA9IGdldFJlZjtcblx0XHRcdGN1cnJlbnRPZmZzZXQgKz0gc2l6ZTtcblx0XHRcdGxldCBnZXQ7XG5cdFx0XHRzd2l0Y2godHlwZSkge1xuXHRcdFx0XHRjYXNlIEFTQ0lJOlxuXHRcdFx0XHRcdGlmIChsYXN0UmVmUHJvcGVydHkgJiYgIWxhc3RSZWZQcm9wZXJ0eS5uZXh0KVxuXHRcdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5Lm5leHQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRwcm9wZXJ0eS5tdWx0aUdldENvdW50ID0gMDtcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgcG9zaXRpb24gPSBzb3VyY2UucG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmU3RhcnQgPSBjdXJyZW50T2Zmc2V0ICsgcG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiByZWYgIT09ICdudW1iZXInKSByZXR1cm4gcmVmO1xuXG5cdFx0XHRcdFx0XHRsZXQgZW5kLCBuZXh0ID0gcHJvcGVydHkubmV4dDtcblx0XHRcdFx0XHRcdHdoaWxlKG5leHQpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gbmV4dC5nZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJylcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSBuZXh0Lm5leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZW5kID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdGVuZCA9IHNvdXJjZS5ieXRlc0VuZCAtIHJlZlN0YXJ0O1xuXHRcdFx0XHRcdFx0aWYgKHNvdXJjZS5zcmNTdHJpbmcpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNvdXJjZS5zcmNTdHJpbmcuc2xpY2UocmVmLCBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0LyppZiAocHJvcGVydHkubXVsdGlHZXRDb3VudCA+IDApIHtcblx0XHRcdFx0XHRcdFx0bGV0IGFzY2lpRW5kO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gZmlyc3RSZWZQcm9wZXJ0eTtcblx0XHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0XHRhc2NpaUVuZCA9IGRhdGFWaWV3LmdldFVpbnQxNihzb3VyY2UucG9zaXRpb24gKyBuZXh0Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGFzY2lpRW5kIDwgMHhmZjAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdFx0YXNjaWlFbmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9IHdoaWxlKChuZXh0ID0gbmV4dC5uZXh0KSk7XG5cdFx0XHRcdFx0XHRcdGlmIChhc2NpaUVuZCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGFzY2lpRW5kID0gc291cmNlLmJ5dGVzRW5kIC0gcmVmU3RhcnRcblx0XHRcdFx0XHRcdFx0c291cmNlLnNyY1N0cmluZyA9IHNyYy50b1N0cmluZygnbGF0aW4xJywgcmVmU3RhcnQsIHJlZlN0YXJ0ICsgYXNjaWlFbmQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc291cmNlLnNyY1N0cmluZy5zbGljZShyZWYsIGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoc291cmNlLnByZXZTdHJpbmdHZXQpIHtcblx0XHRcdFx0XHRcdFx0c291cmNlLnByZXZTdHJpbmdHZXQubXVsdGlHZXRDb3VudCArPSAyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c291cmNlLnByZXZTdHJpbmdHZXQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHkubXVsdGlHZXRDb3VudC0tO1xuXHRcdFx0XHRcdFx0fSovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZyhzcmMsIHJlZiArIHJlZlN0YXJ0LCBlbmQgLSByZWYpO1xuXHRcdFx0XHRcdFx0Ly9yZXR1cm4gc3JjLnRvU3RyaW5nKCdsYXRpbjEnLCByZWYgKyByZWZTdGFydCwgZW5kICsgcmVmU3RhcnQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgVVRGODogY2FzZSBPQkpFQ1RfREFUQTpcblx0XHRcdFx0XHRpZiAobGFzdFJlZlByb3BlcnR5ICYmICFsYXN0UmVmUHJvcGVydHkubmV4dClcblx0XHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eS5uZXh0ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRcdFx0XHRsZXQgcG9zaXRpb24gPSBzb3VyY2UucG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmU3RhcnQgPSBjdXJyZW50T2Zmc2V0ICsgcG9zaXRpb247XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiByZWYgIT09ICdudW1iZXInKSByZXR1cm4gcmVmO1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBlbmQsIG5leHQgPSBwcm9wZXJ0eS5uZXh0O1xuXHRcdFx0XHRcdFx0d2hpbGUobmV4dCkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBuZXh0LmdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0ZW5kID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IG5leHQubmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbmQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0ZW5kID0gc291cmNlLmJ5dGVzRW5kIC0gcmVmU3RhcnQ7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gVVRGOCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc3JjLnRvU3RyaW5nKCd1dGY4JywgcmVmICsgcmVmU3RhcnQsIGVuZCArIHJlZlN0YXJ0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRTb3VyY2UgPSBzb3VyY2U7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVucGFja3IudW5wYWNrKHNyYywgeyBzdGFydDogcmVmICsgcmVmU3RhcnQsIGVuZDogZW5kICsgcmVmU3RhcnQgfSk7XG5cdFx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudFNvdXJjZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIE5VTUJFUjpcblx0XHRcdFx0XHRzd2l0Y2goc2l6ZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0XHRsZXQgcG9zaXRpb24gPSBzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQ7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA8IDB4MjAwMDAwMDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA+IC0weDFmMDAwMDAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPiAtMHgyMDAwMDAwMClcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvQ29uc3RhbnQodmFsdWUgJiAweGZmKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGZWYWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0MzIocG9zaXRpb24sIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMgZG9lcyByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRcdFx0XHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHNyY1twb3NpdGlvbiArIDNdICYgMHg3ZikgPDwgMSkgfCAoc3JjW3Bvc2l0aW9uICsgMl0gPj4gNyldO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAoKG11bHRpcGxpZXIgKiBmVmFsdWUgKyAoZlZhbHVlID4gMCA/IDAuNSA6IC0wLjUpKSA+PiAwKSAvIG11bHRpcGxpZXI7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KHNvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IGJ5dGUgPSBzcmNbc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0XTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChieXRlID49IDB4ZjYpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0b0NvbnN0YW50KGJ5dGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSBzcmNbc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0XTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPCAweGY2ID8gdmFsdWUgOiB0b0NvbnN0YW50KHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIERBVEU6XG5cdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBEYXRlKGRhdGFWaWV3LmdldEZsb2F0NjQoc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXHRcdFx0cHJvcGVydHkuZ2V0ID0gZ2V0O1xuXHRcdH1cblx0XHQvLyBUT0RPOiBsb2FkIHRoZSBzcmNTdHJpbmcgZm9yIGZhc3RlciBzdHJpbmcgZGVjb2Rpbmcgb24gdG9KU09OXG5cdFx0aWYgKGV2YWxTdXBwb3J0ZWQpIHtcblx0XHRcdGxldCBvYmplY3RMaXRlcmFsUHJvcGVydGllcyA9IFtdO1xuXHRcdFx0bGV0IGFyZ3MgPSBbXTtcblx0XHRcdGxldCBpID0gMDtcblx0XHRcdGxldCBoYXNJbmhlcml0ZWRQcm9wZXJ0aWVzO1xuXHRcdFx0Zm9yIChsZXQgcHJvcGVydHkgb2YgcHJvcGVydGllcykgeyAvLyBhc3NpZ24gaW4gZW51bWVyYXRpb24gb3JkZXJcblx0XHRcdFx0aWYgKHVucGFja3IuYWx3YXlzTGF6eVByb3BlcnR5ICYmIHVucGFja3IuYWx3YXlzTGF6eVByb3BlcnR5KHByb3BlcnR5LmtleSkpIHtcblx0XHRcdFx0XHQvLyB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgZWFnZXJseSBldmFsdWF0ZWQgYW5kIHRoaXMgY2FuIGJlIHVzZWQgZm9yIGNyZWF0aW5nIHByb3BlcnRpZXNcblx0XHRcdFx0XHQvLyB0aGF0IGFyZSBub3Qgc2VyaWFsaXplZCBhcyBKU09OXG5cdFx0XHRcdFx0aGFzSW5oZXJpdGVkUHJvcGVydGllcyA9IHRydWU7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcGVydHkua2V5LCB7IGdldDogd2l0aFNvdXJjZShwcm9wZXJ0eS5nZXQpLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0XHRsZXQgdmFsdWVGdW5jdGlvbiA9ICd2JyArIGkrKztcblx0XHRcdFx0YXJncy5wdXNoKHZhbHVlRnVuY3Rpb24pO1xuXHRcdFx0XHRvYmplY3RMaXRlcmFsUHJvcGVydGllcy5wdXNoKCdvWycgKyBKU09OLnN0cmluZ2lmeShwcm9wZXJ0eS5rZXkpICsgJ109JyArIHZhbHVlRnVuY3Rpb24gKyAnKHMpJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzSW5oZXJpdGVkUHJvcGVydGllcykge1xuXHRcdFx0XHRvYmplY3RMaXRlcmFsUHJvcGVydGllcy5wdXNoKCdfX3Byb3RvX186dGhpcycpO1xuXHRcdFx0fVxuXHRcdFx0bGV0IHRvT2JqZWN0ID0gKG5ldyBGdW5jdGlvbiguLi5hcmdzLCAndmFyIGM9dGhpcztyZXR1cm4gZnVuY3Rpb24ocyl7dmFyIG89bmV3IGMoKTsnICsgb2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMuam9pbignOycpICsgJztyZXR1cm4gbzt9JykpLmFwcGx5KGZ1bGxDb25zdHJ1Y3QsIHByb3BlcnRpZXMubWFwKHByb3AgPT4gcHJvcC5nZXQpKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd0b0pTT04nLCB7XG5cdFx0XHRcdHZhbHVlKG9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9PYmplY3QuY2FsbCh0aGlzLCB0aGlzW3NvdXJjZVN5bWJvbF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ3RvSlNPTicsIHtcblx0XHRcdFx0dmFsdWUob21pdFVuZGVyc2NvcmVkUHJvcGVydGllcykge1xuXHRcdFx0XHRcdC8vIHJldHVybiBhbiBlbnVtZXJhYmxlIG9iamVjdCB3aXRoIG93biBwcm9wZXJ0aWVzIHRvIEpTT04gc3RyaW5naWZ5XG5cdFx0XHRcdFx0bGV0IHJlc29sdmVkID0ge307XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogY2hlY2sgYWx3YXlzTGF6eVByb3BlcnR5XG5cdFx0XHRcdFx0XHRsZXQga2V5ID0gcHJvcGVydGllc1tpXS5rZXk7XG5cblx0XHRcdFx0XHRcdHJlc29sdmVkW2tleV0gPSB0aGlzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlZDtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gbm90IGVudW1lcmFibGUgb3IgYW55dGhpbmdcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHR2YXIgaW5zdGFuY2UgPSBuZXcgY29uc3RydWN0KCk7XG5cdGluc3RhbmNlW3NvdXJjZVN5bWJvbF0gPSB7XG5cdFx0Ynl0ZXM6IHNyYyxcblx0XHRwb3NpdGlvbixcblx0XHRzcmNTdHJpbmc6ICcnLFxuXHRcdGJ5dGVzRW5kOiBzcmNFbmRcblx0fTtcblx0cmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdG9Db25zdGFudChjb2RlKSB7XG5cdHN3aXRjaChjb2RlKSB7XG5cdFx0Y2FzZSAweGY2OiByZXR1cm4gbnVsbDtcblx0XHRjYXNlIDB4Zjc6IHJldHVybiB1bmRlZmluZWQ7XG5cdFx0Y2FzZSAweGY4OiByZXR1cm4gZmFsc2U7XG5cdFx0Y2FzZSAweGY5OiByZXR1cm4gdHJ1ZTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29uc3RhbnQnKTtcbn1cbmZ1bmN0aW9uIHdpdGhTb3VyY2UoZ2V0KSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0KHRoaXNbc291cmNlU3ltYm9sXSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKCkge1xuXHRpZiAoY3VycmVudFNvdXJjZSkge1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXMgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1cnJlbnRTb3VyY2UuYnl0ZXMsIGN1cnJlbnRTb3VyY2UucG9zaXRpb24sIGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQpO1xuXHRcdGN1cnJlbnRTb3VyY2UucG9zaXRpb24gPSAwO1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQgPSBjdXJyZW50U291cmNlLmJ5dGVzLmxlbmd0aDtcblx0fVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpIHtcblx0aWYgKHBhY2tyLnR5cGVkU3RydWN0cykge1xuXHRcdGxldCBzdHJ1Y3RNYXAgPSBuZXcgTWFwKCk7XG5cdFx0c3RydWN0TWFwLnNldCgnbmFtZWQnLCBzdHJ1Y3R1cmVzKTtcblx0XHRzdHJ1Y3RNYXAuc2V0KCd0eXBlZCcsIHBhY2tyLnR5cGVkU3RydWN0cyk7XG5cdFx0c3RydWN0dXJlcyA9IHN0cnVjdE1hcDtcblx0fVxuXHRsZXQgbGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHBhY2tyLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggfHwgMDtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSBleGlzdGluZyA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSB0cnVlO1xuXHRcdGlmIChleGlzdGluZyBpbnN0YW5jZW9mIE1hcCkge1xuXHRcdFx0bGV0IG5hbWVkID0gZXhpc3RpbmcuZ2V0KCduYW1lZCcpIHx8IFtdO1xuXHRcdFx0aWYgKG5hbWVkLmxlbmd0aCAhPT0gKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHRcdGxldCB0eXBlZCA9IGV4aXN0aW5nLmdldCgndHlwZWQnKSB8fCBbXTtcblx0XHRcdGlmICh0eXBlZC5sZW5ndGggIT09IGxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGgpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcblx0XHRcdGlmIChleGlzdGluZy5sZW5ndGggIT09IChwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDApKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghY29tcGF0aWJsZSlcblx0XHRcdHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMoZXhpc3RpbmcpO1xuXHRcdHJldHVybiBjb21wYXRpYmxlO1xuXHR9O1xuXHRwYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gcGFja3IudHlwZWRTdHJ1Y3RzICYmIHBhY2tyLnR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdHJldHVybiBzdHJ1Y3R1cmVzO1xufVxuXG5zZXRSZWFkU3RydWN0KHJlYWRTdHJ1Y3QsIG9uTG9hZGVkU3RydWN0dXJlcywgc2F2ZVN0YXRlKTtcblxuY2xhc3MgUGFja3JTdHJlYW0gZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSA9IHRydWU7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0b3B0aW9ucy5zZXF1ZW50aWFsID0gdHJ1ZTtcblx0XHR0aGlzLnBhY2tyID0gb3B0aW9ucy5wYWNrciB8fCBuZXcgUGFja3Iob3B0aW9ucyk7XG5cdH1cblx0X3RyYW5zZm9ybSh2YWx1ZSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5wdXNoKHRoaXMucGFja3IucGFjayh2YWx1ZSkpO1xuXHRcdGNhbGxiYWNrKCk7XG5cdH1cbn1cblxuY2xhc3MgVW5wYWNrclN0cmVhbSBleHRlbmRzIHN0cmVhbS5UcmFuc2Zvcm0ge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdG9wdGlvbnMub2JqZWN0TW9kZSA9IHRydWU7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0dGhpcy51bnBhY2tyID0gb3B0aW9ucy51bnBhY2tyIHx8IG5ldyBVbnBhY2tyKG9wdGlvbnMpO1xuXHR9XG5cdF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdGlmICh0aGlzLmluY29tcGxldGVCdWZmZXIpIHtcblx0XHRcdGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpcy5pbmNvbXBsZXRlQnVmZmVyLCBjaHVua10pO1xuXHRcdFx0dGhpcy5pbmNvbXBsZXRlQnVmZmVyID0gbnVsbDtcblx0XHR9XG5cdFx0bGV0IHZhbHVlcztcblx0XHR0cnkge1xuXHRcdFx0dmFsdWVzID0gdGhpcy51bnBhY2tyLnVucGFja011bHRpcGxlKGNodW5rKTtcblx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRpZiAoZXJyb3IuaW5jb21wbGV0ZSkge1xuXHRcdFx0XHR0aGlzLmluY29tcGxldGVCdWZmZXIgPSBjaHVuay5zbGljZShlcnJvci5sYXN0UG9zaXRpb24pO1xuXHRcdFx0XHR2YWx1ZXMgPSBlcnJvci52YWx1ZXM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcyB8fCBbXSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpXG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldE51bGxWYWx1ZSgpO1xuXHRcdFx0XHR0aGlzLnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG5cdH1cblx0Z2V0TnVsbFZhbHVlKCkge1xuXHRcdHJldHVybiBTeW1ib2wuZm9yKG51bGwpXG5cdH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZSBmaXJzdCBhcmd1bWVudCwgcmV0dXJucyBhbiBJdGVyYWJsZSB3aGVyZSBlYWNoIHZhbHVlIGlzIHBhY2tlZCBhcyBhIEJ1ZmZlclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG9ubHkgQXN5bmMgSXRlcmFibGUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbiBBc3luYyBJdGVyYWJsZS5cbiAqIEBwYXJhbSB7SXRlcmFibGV8SXRlcmF0b3J8QXN5bmNJdGVyYWJsZXxBc3luY0l0ZXJhdG9yfSBvYmplY3RJdGVyYXRvciAtIGl0ZXJhYmxlIHNvdXJjZSwgbGlrZSBhIFJlYWRhYmxlIG9iamVjdCBzdHJlYW0sIGFuIGFycmF5LCBTZXQsIG9yIGN1c3RvbSBvYmplY3RcbiAqIEBwYXJhbSB7b3B0aW9uc30gW29wdGlvbnNdIC0gbXNncGFja3IgcGFjayBvcHRpb25zXG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcnxQcm9taXNlLjxBc3luY0l0ZXJhYmxlSXRlcmF0b3I+fVxuICovXG5mdW5jdGlvbiBwYWNrSXRlciAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIW9iamVjdEl0ZXJhdG9yIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBvciBhIFByb21pc2UgZm9yIGFuIEFzeW5jIEl0ZXJhYmxlJylcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0SXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlclN5bmMob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yLnRoZW4gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlckFzeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBQcm9taXNlJylcbiAgfVxufVxuXG5mdW5jdGlvbiAqIHBhY2tJdGVyU3luYyAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFja3IgPSBuZXcgUGFja3Iob3B0aW9ucyk7XG4gIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqZWN0SXRlcmF0b3IpIHtcbiAgICB5aWVsZCBwYWNrci5wYWNrKHZhbHVlKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiAqIHBhY2tJdGVyQXN5bmMgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKG9wdGlvbnMpO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIG9iamVjdEl0ZXJhdG9yKSB7XG4gICAgeWllbGQgcGFja3IucGFjayh2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZS9JdGVyYXRvciBpbnB1dCB3aGljaCB5aWVsZHMgYnVmZmVycywgcmV0dXJucyBhbiBJdGVyYWJsZUl0ZXJhdG9yIHdoaWNoIHlpZWxkcyBzeW5jIGRlY29kZWQgb2JqZWN0c1xuICogT3IsIGdpdmVuIGFuIEFzeW5jIEl0ZXJhYmxlL0l0ZXJhdG9yIHdoaWNoIHlpZWxkcyBwcm9taXNlcyByZXNvbHZpbmcgaW4gYnVmZmVycywgcmV0dXJucyBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3IuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfEl0ZXJhdG9yfEFzeW5jSXRlcmFibGV8QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfSBidWZmZXJJdGVyYXRvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIHVucGFja3Igb3B0aW9uc1xuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J8UHJvbWlzZS48QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiB1bnBhY2tJdGVyIChidWZmZXJJdGVyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghYnVmZmVySXRlcmF0b3IgfHwgdHlwZW9mIGJ1ZmZlckl0ZXJhdG9yICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBwcm9taXNlJylcbiAgfVxuXG4gIGNvbnN0IHVucGFja3IgPSBuZXcgVW5wYWNrcihvcHRpb25zKTtcbiAgbGV0IGluY29tcGxldGU7XG4gIGNvbnN0IHBhcnNlciA9IChjaHVuaykgPT4ge1xuICAgIGxldCB5aWVsZHM7XG4gICAgLy8gaWYgdGhlcmUncyBpbmNvbXBsZXRlIGRhdGEgZnJvbSBwcmV2aW91cyBjaHVuaywgY29uY2F0aW5hdGUgYW5kIHRyeSBhZ2FpblxuICAgIGlmIChpbmNvbXBsZXRlKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5jb25jYXQoW2luY29tcGxldGUsIGNodW5rXSk7XG4gICAgICBpbmNvbXBsZXRlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB5aWVsZHMgPSB1bnBhY2tyLnVucGFja011bHRpcGxlKGNodW5rKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuaW5jb21wbGV0ZSkge1xuICAgICAgICBpbmNvbXBsZXRlID0gY2h1bmsuc2xpY2UoZXJyLmxhc3RQb3NpdGlvbik7XG4gICAgICAgIHlpZWxkcyA9IGVyci52YWx1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHlpZWxkc1xuICB9O1xuXG4gIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKiBpdGVyICgpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYnVmZmVySXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgKiBwYXJzZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0pKClcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAqIGl0ZXIgKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBidWZmZXJJdGVyYXRvcikge1xuICAgICAgICB5aWVsZCAqIHBhcnNlcih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSkoKVxuICB9XG59XG5jb25zdCBkZWNvZGVJdGVyID0gdW5wYWNrSXRlcjtcbmNvbnN0IGVuY29kZUl0ZXIgPSBwYWNrSXRlcjtcblxuY29uc3QgdXNlUmVjb3JkcyA9IGZhbHNlO1xuY29uc3QgbWFwc0FzT2JqZWN0cyA9IHRydWU7XG5cbmNvbnN0IG5hdGl2ZUFjY2VsZXJhdGlvbkRpc2FibGVkID0gcHJvY2Vzcy5lbnYuTVNHUEFDS1JfTkFUSVZFX0FDQ0VMRVJBVElPTl9ESVNBQkxFRCAhPT0gdW5kZWZpbmVkICYmIHByb2Nlc3MuZW52Lk1TR1BBQ0tSX05BVElWRV9BQ0NFTEVSQVRJT05fRElTQUJMRUQudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuXG5pZiAoIW5hdGl2ZUFjY2VsZXJhdGlvbkRpc2FibGVkKSB7XG5cdGxldCBleHRyYWN0b3I7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZXF1aXJlID09ICdmdW5jdGlvbicpXG5cdFx0XHRleHRyYWN0b3IgPSByZXF1aXJlKCdtc2dwYWNrci1leHRyYWN0Jyk7XG5cdFx0ZWxzZVxuXHRcdFx0ZXh0cmFjdG9yID0gbW9kdWxlJDEuY3JlYXRlUmVxdWlyZSgodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IG5ldyAocmVxdWlyZSgndScgKyAncmwnKS5VUkwpKCdmaWxlOicgKyBfX2ZpbGVuYW1lKS5ocmVmIDogKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgfHwgbmV3IFVSTCgnbm9kZS5janMnLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmKSkpKCdtc2dwYWNrci1leHRyYWN0Jyk7XG5cdFx0aWYgKGV4dHJhY3Rvcilcblx0XHRcdHNldEV4dHJhY3RvcihleHRyYWN0b3IuZXh0cmFjdFN0cmluZ3MpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIG5hdGl2ZSBtb2R1bGUgaXMgb3B0aW9uYWxcblx0fVxufVxuXG5leHBvcnRzLkFMV0FZUyA9IEFMV0FZUztcbmV4cG9ydHMuQzEgPSBDMTtcbmV4cG9ydHMuREVDSU1BTF9GSVQgPSBERUNJTUFMX0ZJVDtcbmV4cG9ydHMuREVDSU1BTF9ST1VORCA9IERFQ0lNQUxfUk9VTkQ7XG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuZXhwb3J0cy5EZWNvZGVyU3RyZWFtID0gVW5wYWNrclN0cmVhbTtcbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5leHBvcnRzLkVuY29kZXJTdHJlYW0gPSBQYWNrclN0cmVhbTtcbmV4cG9ydHMuRkxPQVQzMl9PUFRJT05TID0gRkxPQVQzMl9PUFRJT05TO1xuZXhwb3J0cy5ORVZFUiA9IE5FVkVSO1xuZXhwb3J0cy5QYWNrciA9IFBhY2tyO1xuZXhwb3J0cy5QYWNrclN0cmVhbSA9IFBhY2tyU3RyZWFtO1xuZXhwb3J0cy5VbnBhY2tyID0gVW5wYWNrcjtcbmV4cG9ydHMuVW5wYWNrclN0cmVhbSA9IFVucGFja3JTdHJlYW07XG5leHBvcnRzLmFkZEV4dGVuc2lvbiA9IGFkZEV4dGVuc2lvbjtcbmV4cG9ydHMuY2xlYXJTb3VyY2UgPSBjbGVhclNvdXJjZTtcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZXhwb3J0cy5kZWNvZGVJdGVyID0gZGVjb2RlSXRlcjtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5lbmNvZGVJdGVyID0gZW5jb2RlSXRlcjtcbmV4cG9ydHMubWFwc0FzT2JqZWN0cyA9IG1hcHNBc09iamVjdHM7XG5leHBvcnRzLnBhY2sgPSBwYWNrO1xuZXhwb3J0cy5yb3VuZEZsb2F0MzIgPSByb3VuZEZsb2F0MzI7XG5leHBvcnRzLnVucGFjayA9IHVucGFjaztcbmV4cG9ydHMudW5wYWNrTXVsdGlwbGUgPSB1bnBhY2tNdWx0aXBsZTtcbmV4cG9ydHMudXNlUmVjb3JkcyA9IHVzZVJlY29yZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLmNqcy5tYXBcbiJdLCJuYW1lcyI6WyJzdHJlYW0iLCJyZXF1aXJlIiwibW9kdWxlJDEiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJlcnJvciIsInNyYyIsInNyY0VuZCIsInBvc2l0aW9uJDEiLCJFTVBUWV9BUlJBWSIsInN0cmluZ3MiLCJzdHJpbmdQb3NpdGlvbiIsImN1cnJlbnRVbnBhY2tyIiwiY3VycmVudFN0cnVjdHVyZXMiLCJzcmNTdHJpbmciLCJzcmNTdHJpbmdTdGFydCIsInNyY1N0cmluZ0VuZCIsImJ1bmRsZWRTdHJpbmdzJDEiLCJyZWZlcmVuY2VNYXAiLCJjdXJyZW50RXh0ZW5zaW9ucyIsImRhdGFWaWV3IiwiZGVmYXVsdE9wdGlvbnMiLCJ1c2VSZWNvcmRzIiwibWFwc0FzT2JqZWN0cyIsIkMxVHlwZSIsIkMxIiwibmFtZSIsInNlcXVlbnRpYWxNb2RlIiwiaW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCIsInJlYWRTdHJ1Y3QkMSIsIm9uTG9hZGVkU3RydWN0dXJlcyQxIiwib25TYXZlU3RhdGUiLCJGdW5jdGlvbiIsIkluZmluaXR5IiwiVW5wYWNrciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInVuZGVmaW5lZCIsInNlcXVlbnRpYWwiLCJ0cnVzdGVkIiwic3RydWN0dXJlcyIsIm1heFNoYXJlZFN0cnVjdHVyZXMiLCJzaGFyZWRMZW5ndGgiLCJsZW5ndGgiLCJnZXRTdHJ1Y3R1cmVzIiwidW5pbml0aWFsaXplZCIsImludDY0QXNOdW1iZXIiLCJpbnQ2NEFzVHlwZSIsIk9iamVjdCIsImFzc2lnbiIsInVucGFjayIsInNvdXJjZSIsInNhdmVTdGF0ZSQxIiwiY2xlYXJTb3VyY2UiLCJwcm90b3R5cGUiLCJjYWxsIiwiYnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiVWludDhBcnJheSIsImVuZCIsInN0YXJ0IiwiRGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkVycm9yIiwiY2hlY2tlZFJlYWQiLCJ1bnBhY2tNdWx0aXBsZSIsImZvckVhY2giLCJ2YWx1ZXMiLCJsYXN0UG9zaXRpb24iLCJzaXplIiwidmFsdWUiLCJkZWZhdWx0VW5wYWNrciIsInB1c2giLCJfbWVyZ2VTdHJ1Y3R1cmVzIiwibG9hZGVkU3RydWN0dXJlcyIsImV4aXN0aW5nU3RydWN0dXJlcyIsImlzRnJvemVuIiwibWFwIiwic3RydWN0dXJlIiwic2xpY2UiLCJpIiwibCIsImlzU2hhcmVkIiwiaGlnaEJ5dGUiLCJpZCIsImV4aXN0aW5nIiwicmVzdG9yZVN0cnVjdHVyZXMiLCJkZWNvZGUiLCJyZXN1bHQiLCJyYW5kb21BY2Nlc3NTdHJ1Y3R1cmUiLCJsYXp5IiwidG9KU09OIiwicmVhZCIsInBvc3RCdW5kbGVQb3NpdGlvbiIsImpzb25WaWV3IiwiSlNPTiIsInN0cmluZ2lmeSIsIl8iLCJSYW5nZUVycm9yIiwibWVzc2FnZSIsInN0YXJ0c1dpdGgiLCJpbmNvbXBsZXRlIiwidG9rZW4iLCJsb2FkU3RydWN0dXJlcyIsImNyZWF0ZVN0cnVjdHVyZVJlYWRlciIsIm9iamVjdCIsImtleSIsInJlYWRLZXkiLCJNYXAiLCJzZXQiLCJhcnJheSIsIkFycmF5IiwiZnJlZXplRGF0YSIsImZyZWV6ZSIsInN0cmluZyIsInNob3J0U3RyaW5nSW5KUyIsImxvbmdTdHJpbmdJbkpTIiwicmVhZEZpeGVkU3RyaW5nIiwicG9zaXRpb24xIiwicG9zaXRpb24wIiwicmVhZEJpbiIsImdldFVpbnQxNiIsImdldFVpbnQzMiIsInJlYWRFeHQiLCJnZXRGbG9hdDMyIiwidXNlRmxvYXQzMiIsIm11bHRpcGxpZXIiLCJtdWx0MTAiLCJnZXRGbG9hdDY0IiwiZ2V0QmlnVWludDY0IiwidG9TdHJpbmciLCJCaWdJbnQiLCJOdW1iZXIiLCJnZXRJbnQ4IiwiZ2V0SW50MTYiLCJnZXRJbnQzMiIsImdldEJpZ0ludDY0IiwicmVjb3JkRGVmaW5pdGlvbiIsImV4dGVuc2lvbiIsIm5vQnVmZmVyIiwic3ViYXJyYXkiLCJyZWFkU3RyaW5nOCIsInJlYWRTdHJpbmcxNiIsInJlYWRTdHJpbmczMiIsInJlYWRBcnJheSIsInJlYWRNYXAiLCJ2YWxpZE5hbWUiLCJmaXJzdElkIiwicmVhZE9iamVjdCIsImNvdW50IiwidGVzdCIsImpvaW4iLCJjcmVhdGVTZWNvbmRCeXRlUmVhZGVyIiwicmVhZDAiLCJyZWFkU3RyaW5nSlMiLCJleHBvcnRzIiwiaXNOYXRpdmVBY2NlbGVyYXRpb25FbmFibGVkIiwic2V0RXh0cmFjdG9yIiwiZXh0cmFjdFN0cmluZ3MiLCJyZWFkU3RyaW5nIiwiaGVhZGVyTGVuZ3RoIiwiZXh0cmFjdGlvbiIsInNyY1N0cmluZ0xlbmd0aCIsInVuaXRzIiwiYnl0ZTEiLCJieXRlMiIsImJ5dGUzIiwiYnl0ZTQiLCJ1bml0IiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJTdHJpbmciLCJleGlzdGluZ1NyYyIsImJ5dGVzIiwiYnl0ZSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaiIsImsiLCJtIiwibiIsIm8iLCJyZWFkT25seUpTU3RyaW5nIiwiY29weUJ1ZmZlcnMiLCJ0eXBlIiwicmVhZFBvc2l0aW9uIiwia2V5Q2FjaGUiLCJhc1NhZmVTdHJpbmciLCJlbnRyeSIsImNoZWNrUG9zaXRpb24iLCJjaHVuayIsInByb3BlcnR5IiwiYWxsb3dBcnJheXNJbk1hcEtleXMiLCJpc0FycmF5IiwiZmxhdCIsImV2ZXJ5IiwiaXRlbSIsImluY2x1ZGVzIiwiZmlyc3RCeXRlIiwiZXhpc3RpbmdTdHJ1Y3R1cmUiLCJkYXRhIiwiaGVhZExlbmd0aCIsImhlYWQiLCJ2aWV3Iiwib3V0IiwibWlkZGxlIiwibGVmdCIsInJpZ2h0IiwiZXJyb3JzIiwiRXZhbEVycm9yIiwiUmVmZXJlbmNlRXJyb3IiLCJTeW50YXhFcnJvciIsIlR5cGVFcnJvciIsIlVSSUVycm9yIiwiQWdncmVnYXRlRXJyb3IiLCJjYXVzZSIsInN0cnVjdHVyZWRDbG9uZSIsInRhcmdldCIsIlNldCIsInJlZkVudHJ5IiwidGFyZ2V0UHJvcGVydGllcyIsInVzZWQiLCJ2IiwiZW50cmllcyIsImFkZCIsImdldCIsInR5cGVkQXJyYXlzIiwiZ2xibCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJ0eXBlQ29kZSIsInR5cGVkQXJyYXlOYW1lIiwiUmVnRXhwIiwiVEVNUF9CVU5ETEUiLCJkYXRhU2l6ZSIsImRhdGFQb3NpdGlvbiIsIkRhdGUiLCJjYWxsYmFjayIsInNhdmVkU3JjRW5kIiwic2F2ZWRQb3NpdGlvbiIsInNhdmVkU3RyaW5nUG9zaXRpb24iLCJzYXZlZFNyY1N0cmluZ1N0YXJ0Iiwic2F2ZWRTcmNTdHJpbmdFbmQiLCJzYXZlZFNyY1N0cmluZyIsInNhdmVkU3RyaW5ncyIsInNhdmVkUmVmZXJlbmNlTWFwIiwic2F2ZWRCdW5kbGVkU3RyaW5ncyIsInNhdmVkU3JjIiwic2F2ZWRTdHJ1Y3R1cmVzIiwic2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMiLCJzYXZlZFBhY2tyIiwic2F2ZWRTZXF1ZW50aWFsTW9kZSIsInNwbGljZSIsImFkZEV4dGVuc2lvbiQxIiwiTWF0aCIsImZsb29yIiwiRGVjb2RlciIsIkZMT0FUMzJfT1BUSU9OUyIsIk5FVkVSIiwiQUxXQVlTIiwiREVDSU1BTF9ST1VORCIsIkRFQ0lNQUxfRklUIiwiZjMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ1OEFycmF5Iiwicm91bmRGbG9hdDMyIiwiZmxvYXQzMk51bWJlciIsInNldFJlYWRTdHJ1Y3QiLCJ1cGRhdGVkUmVhZFN0cnVjdCIsImxvYWRlZFN0cnVjdHMiLCJzYXZlU3RhdGUiLCJ0ZXh0RW5jb2RlciQxIiwiVGV4dEVuY29kZXIiLCJleHRlbnNpb25zIiwiZXh0ZW5zaW9uQ2xhc3NlcyIsImhhc05vZGVCdWZmZXIkMSIsIkJ5dGVBcnJheUFsbG9jYXRlIiwiYWxsb2NVbnNhZmVTbG93IiwiQnl0ZUFycmF5IiwiTUFYX0JVRkZFUl9TSVpFIiwia2V5c1RhcmdldCIsInRhcmdldFZpZXciLCJwb3NpdGlvbiIsInNhZmVFbmQiLCJidW5kbGVkU3RyaW5ncyIsIndyaXRlU3RydWN0U2xvdHMiLCJNQVhfQlVORExFX1NJWkUiLCJoYXNOb25MYXRpbiIsIlJFQ09SRF9TWU1CT0wiLCJTeW1ib2wiLCJQYWNrciIsIm9mZnNldCIsImhhc1NoYXJlZFVwZGF0ZSIsImVuY29kZVV0ZjgiLCJ1dGY4V3JpdGUiLCJlbmNvZGVJbnRvIiwid3JpdHRlbiIsInBhY2tyIiwiaXNTZXF1ZW50aWFsIiwiaGFzU2hhcmVkU3RydWN0dXJlcyIsInNhdmVTdHJ1Y3R1cmVzIiwibW9yZVR5cGVzIiwibWF4T3duU3RydWN0dXJlcyIsInVzZVR3b0J5dGVSZWNvcmRzIiwic2hhcmVkTGltaXRJZCIsIm1heFN0cnVjdHVyZUlkIiwicmVjb3JkSWRzVG9SZW1vdmUiLCJ0cmFuc2l0aW9uc0NvdW50Iiwic2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkIiwicGFjayIsImVuY29kZSIsImVuY29kZU9wdGlvbnMiLCJSRVNFUlZFX1NUQVJUX1NQQUNFIiwiYnVuZGxlU3RyaW5ncyIsInRyYW5zaXRpb25zIiwiY3JlYXRlIiwia2V5cyIsIm5leHRUcmFuc2l0aW9uIiwidHJhbnNpdGlvbiIsImxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGgiLCJuZXh0SWQiLCJlbmNvZGluZ0Vycm9yIiwid3JpdGVTdHJ1Y3QiLCJsYXN0QnVuZGxlIiwid3JpdGVCdW5kbGVzIiwiaWRzVG9JbnNlcnQiLCJzb3J0IiwiaW5jcmVtZW50UG9zaXRpb24iLCJpbnNlcnRpb25Qb2ludCIsInN0cmluZ3NQb3NpdGlvbiIsInNldFVpbnQzMiIsInByZXZpb3VzIiwibWFrZVJvb20iLCJzZXJpYWxpemVkIiwiaW5zZXJ0SWRzIiwiUkVVU0VfQlVGRkVSX01PREUiLCJyZXNldFN0cnVjdHVyZXMiLCJyZXR1cm5CdWZmZXIiLCJuZXdTaGFyZWREYXRhIiwicHJlcGFyZVN0cnVjdHVyZXMkMSIsImlzQ29tcGF0aWJsZSIsIlJFU0VUX0JVRkZFUl9NT0RFIiwicGFja0FycmF5Iiwic3RyTGVuZ3RoIiwiZXh0U3RhcnQiLCJtYXhCeXRlcyIsInNldFVpbnQxNiIsInR3b0J5dGUiLCJoZWFkZXJTaXplIiwiYzEiLCJjMiIsInN0clBvc2l0aW9uIiwiY2hhckNvZGVBdCIsImNvcHlXaXRoaW4iLCJzZXRJbnQxNiIsInNldEludDMyIiwic2V0RmxvYXQzMiIsInhTaGlmdGVkIiwic2V0RmxvYXQ2NCIsInJlZmVyZWUiLCJ3cml0ZU9iamVjdCIsIm1hcEFzRW1wdHlPYmplY3QiLCJlbnRyeVZhbHVlIiwiZXh0ZW5zaW9uQ2xhc3MiLCJ3cml0ZSIsIndyaXRlUmVzdWx0IiwiY3VycmVudFRhcmdldCIsImN1cnJlbnRUYXJnZXRWaWV3IiwiY3VycmVudFBvc2l0aW9uIiwid3JpdGVFeHRlbnNpb25EYXRhIiwianNvbiIsIndyaXRlRnVuY3Rpb24iLCJzZXRCaWdJbnQ2NCIsInNldEJpZ1VpbnQ2NCIsImxhcmdlQmlnSW50VG9GbG9hdCIsImxhcmdlQmlnSW50VG9TdHJpbmciLCJ1c2VCaWdJbnRFeHRlbnNpb24iLCJlbXB0eSIsIm1hc2siLCJjaHVua3MiLCJCaWdVaW50NjRBcnJheSIsInJldmVyc2UiLCJpbnZlcnQiLCJwYXJzZUludCIsImNoYXJBdCIsImVuY29kZVVuZGVmaW5lZEFzTmlsIiwid3JpdGVQbGFpbk9iamVjdCIsInZhcmlhYmxlTWFwU2l6ZSIsImNvZXJjaWJsZUtleUFzTnVtYmVyIiwic2tpcFZhbHVlcyIsImhhc093blByb3BlcnR5IiwibnVtIiwiaXNOYU4iLCJvYmplY3RPZmZzZXQiLCJ3cml0ZVJlY29yZCIsInByb2dyZXNzaXZlUmVjb3JkcyIsIndyb3RlS2V5cyIsImxhc3RUcmFuc2l0aW9uIiwibmV3VHJhbnNpdGlvbnMiLCJuZXdSZWNvcmQiLCJpbnNlcnROZXdSZWNvcmQiLCJyZWNvcmRJZCIsIl9fa2V5c19fIiwiY2hlY2tVc2VSZWNvcmRzIiwibmV3U2l6ZSIsIm1pbiIsInJvdW5kIiwibWF4IiwibmV3QnVmZmVyIiwiY29weSIsInNob3VsZFNoYXJlU3RydWN0dXJlIiwibmV4dE93bklkIiwic2hpZnQiLCJpbnNlcnRpb25PZmZzZXQiLCJtYWluVGFyZ2V0IiwibWFpblBvc2l0aW9uIiwibWFpblNhZmVFbmQiLCJtYWluU3RhcnQiLCJrZXlzUG9zaXRpb24iLCJuZXdFbmQiLCJpbnNlcnRpb25Qb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwibm90aWZ5U2hhcmVkVXBkYXRlIiwic3RhcnRUYXJnZXQiLCJ1c2VCdWZmZXIiLCJjbGVhclNoYXJlZERhdGEiLCJ0eXBlZFN0cnVjdHMiLCJnZXRQcm90b3R5cGVPZiIsImRhdGUiLCJhbGxvY2F0ZUZvcldyaXRlIiwic2Vjb25kcyIsImdldFRpbWUiLCJ1c2VUaW1lc3RhbXAzMiIsImdldE1pbGxpc2Vjb25kcyIsIm9uSW52YWxpZERhdGUiLCJzZXRBc0VtcHR5T2JqZWN0IiwicmVnZXgiLCJmbGFncyIsImFycmF5QnVmZmVyIiwid3JpdGVFeHRCdWZmZXIiLCJ3cml0ZUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJpbmRleE9mIiwiZGlzdGFuY2VUb01vdmUiLCJsYXN0RW5kIiwicG9wIiwid3JpdGVTdHJpbmdzIiwiYWRkRXh0ZW5zaW9uIiwiQ2xhc3MiLCJ1bnNoaWZ0IiwiY29tcGF0aWJsZSIsInNldFdyaXRlU3RydWN0U2xvdHMiLCJ3cml0ZVNsb3RzIiwibWFrZVN0cnVjdHVyZXMiLCJkZWZhdWx0UGFja3IiLCJFbmNvZGVyIiwiQVNDSUkiLCJOVU1CRVIiLCJVVEY4IiwiT0JKRUNUX0RBVEEiLCJEQVRFIiwiVFlQRV9OQU1FUyIsImZsb2F0MzJIZWFkZXJzIiwiZXZhbFN1cHBvcnRlZCIsInVwZGF0ZWRQb3NpdGlvbiIsImhhc05vZGVCdWZmZXIiLCJ0ZXh0RW5jb2RlciIsImN1cnJlbnRTb3VyY2UiLCJwcmVwYXJlU3RydWN0dXJlcyIsImVuY29kaW5nU3RhcnQiLCJyZWZzU3RhcnRQb3NpdGlvbiIsImxhc3RTdHJpbmdTdGFydCIsInJlZk9mZnNldCIsInJlZlBvc2l0aW9uIiwicXVldWVkUmVmZXJlbmNlcyIsInVzZWRBc2NpaTAiLCJrZXlJbmRleCIsInBhcmVudCIsImVudW1lcmF0aW9uT2Zmc2V0IiwiYXNjaWkwIiwiYXNjaWk4IiwibnVtOCIsInN0cmluZzE2Iiwib2JqZWN0MTYiLCJudW0zMiIsImZsb2F0NjQiLCJkYXRlNjQiLCJudW1iZXIiLCJudW02NCIsImNyZWF0ZVR5cGVUcmFuc2l0aW9uIiwiaXNOb3RBc2NpaSIsInN0clN0YXJ0Iiwic3RyaW5nOCIsIl9fdHlwZSIsImFueVR5cGUiLCJwcm9wZXJ0eUluZGV4Iiwib2JqZWN0MzIiLCJfX3NpemUiLCJfX3BhcmVudCIsInNldEludDgiLCJOYU4iLCJ0eXBlTmFtZSIsIm5ld1RyYW5zaXRpb24iLCJvbkxvYWRlZFN0cnVjdHVyZXMiLCJzaGFyZWREYXRhIiwidHlwZWQiLCJuYW1lZCIsImxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGgiLCJzb3VyY2VTeW1ib2wiLCJmb3IiLCJyZWFkU3RydWN0IiwidW5wYWNrciIsImNvbnN0cnVjdCIsImZ1bGxDb25zdHJ1Y3QiLCJMYXp5T2JqZWN0IiwiTG9hZGVkT2JqZWN0Iiwic3RydWN0UHJvdG90eXBlIiwicHJvcGVydGllcyIsImN1cnJlbnRPZmZzZXQiLCJsYXN0UmVmUHJvcGVydHkiLCJkZWZpbml0aW9uIiwiZ2V0UmVmIiwicmVmIiwidG9Db25zdGFudCIsIm5leHQiLCJtdWx0aUdldENvdW50IiwicmVmU3RhcnQiLCJieXRlc0VuZCIsImZWYWx1ZSIsIm9iamVjdExpdGVyYWxQcm9wZXJ0aWVzIiwiYXJncyIsImhhc0luaGVyaXRlZFByb3BlcnRpZXMiLCJhbHdheXNMYXp5UHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsIndpdGhTb3VyY2UiLCJlbnVtZXJhYmxlIiwidmFsdWVGdW5jdGlvbiIsInRvT2JqZWN0IiwicHJvcCIsIm9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMiLCJyZXNvbHZlZCIsImluc3RhbmNlIiwiY29kZSIsInN0cnVjdE1hcCIsIlBhY2tyU3RyZWFtIiwiVHJhbnNmb3JtIiwid3JpdGFibGVPYmplY3RNb2RlIiwiX3RyYW5zZm9ybSIsImVuY29kaW5nIiwiVW5wYWNrclN0cmVhbSIsIm9iamVjdE1vZGUiLCJpbmNvbXBsZXRlQnVmZmVyIiwiY29uY2F0IiwiZ2V0TnVsbFZhbHVlIiwicGFja0l0ZXIiLCJvYmplY3RJdGVyYXRvciIsIml0ZXJhdG9yIiwicGFja0l0ZXJTeW5jIiwidGhlbiIsImFzeW5jSXRlcmF0b3IiLCJwYWNrSXRlckFzeW5jIiwidW5wYWNrSXRlciIsImJ1ZmZlckl0ZXJhdG9yIiwicGFyc2VyIiwieWllbGRzIiwiZXJyIiwiaXRlciIsImRlY29kZUl0ZXIiLCJlbmNvZGVJdGVyIiwibmF0aXZlQWNjZWxlcmF0aW9uRGlzYWJsZWQiLCJwcm9jZXNzIiwiZW52IiwiTVNHUEFDS1JfTkFUSVZFX0FDQ0VMRVJBVElPTl9ESVNBQkxFRCIsInRvTG93ZXJDYXNlIiwiZXh0cmFjdG9yIiwiY3JlYXRlUmVxdWlyZSIsImRvY3VtZW50IiwiVVJMIiwiX19maWxlbmFtZSIsImhyZWYiLCJjdXJyZW50U2NyaXB0IiwiYmFzZVVSSSIsIkRlY29kZXJTdHJlYW0iLCJFbmNvZGVyU3RyZWFtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/dist/node.cjs\n");

/***/ })

};
;