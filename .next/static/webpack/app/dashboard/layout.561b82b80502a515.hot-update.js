"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/layout",{

/***/ "(app-pages-browser)/./src/app/utils/api.ts":
/*!******************************!*\
  !*** ./src/app/utils/api.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeImageMultipart: function() { return /* binding */ analyzeImageMultipart; },\n/* harmony export */   checkUserPackage: function() { return /* binding */ checkUserPackage; },\n/* harmony export */   coachChat: function() { return /* binding */ coachChat; },\n/* harmony export */   createEmptyConversation: function() { return /* binding */ createEmptyConversation; },\n/* harmony export */   deleteAnalysisResult: function() { return /* binding */ deleteAnalysisResult; },\n/* harmony export */   deleteConversation: function() { return /* binding */ deleteConversation; },\n/* harmony export */   fetchAnalysisHistory: function() { return /* binding */ fetchAnalysisHistory; },\n/* harmony export */   fetchCoachChatPrompts: function() { return /* binding */ fetchCoachChatPrompts; },\n/* harmony export */   fetchConversation: function() { return /* binding */ fetchConversation; },\n/* harmony export */   fetchConversations: function() { return /* binding */ fetchConversations; },\n/* harmony export */   generateConversationTitle: function() { return /* binding */ generateConversationTitle; },\n/* harmony export */   getAnalysisById: function() { return /* binding */ getAnalysisById; },\n/* harmony export */   getClientEmail: function() { return /* binding */ getClientEmail; },\n/* harmony export */   purchasePackage: function() { return /* binding */ purchasePackage; },\n/* harmony export */   sendFeedback: function() { return /* binding */ sendFeedback; },\n/* harmony export */   startCheckout: function() { return /* binding */ startCheckout; },\n/* harmony export */   updateAnalysisById: function() { return /* binding */ updateAnalysisById; },\n/* harmony export */   verifySession: function() { return /* binding */ verifySession; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// src/app/utils/api.ts\nconst BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:5001\";\nvar _process_env_NEXT_PUBLIC_LEGACY_EMAIL_PARAM;\nconst LEGACY_EMAIL = ((_process_env_NEXT_PUBLIC_LEGACY_EMAIL_PARAM = process.env.NEXT_PUBLIC_LEGACY_EMAIL_PARAM) !== null && _process_env_NEXT_PUBLIC_LEGACY_EMAIL_PARAM !== void 0 ? _process_env_NEXT_PUBLIC_LEGACY_EMAIL_PARAM : \"1\") !== \"0\";\nfunction readCookie(name) {\n    if (typeof document === \"undefined\") return null;\n    const m = document.cookie.match(new RegExp(\"(?:^|; )\" + name.replace(/([.$?*|{}()\\[\\]\\\\\\/\\+^])/g, \"\\\\$1\") + \"=([^;]*)\"));\n    return m ? decodeURIComponent(m[1]) : null;\n}\nfunction getAuthTokenFromCookies() {\n    if (typeof document === \"undefined\") return null;\n    const m = document.cookie.match(/(?:^|; )(session|auth_token)=([^;]+)/);\n    return m ? decodeURIComponent(m[2]) : null;\n}\nfunction authHeaders() {\n    let base = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const token = getAuthTokenFromCookies();\n    return token ? {\n        ...base,\n        Authorization: \"Bearer \".concat(token)\n    } : base;\n}\n// -------------------------------\n// Small helpers\n// -------------------------------\nfunction getClientEmail() {\n    if (false) {}\n    // Prefer cookie or JWT payload; fallback retained for legacy only\n    const cookie = readCookie(\"userEmail\");\n    if (cookie) return cookie;\n    const token = getAuthTokenFromCookies();\n    if (token) {\n        try {\n            var _payload_user;\n            const payload = JSON.parse(atob(token.split(\".\")[1]));\n            const email = (payload === null || payload === void 0 ? void 0 : payload.email) || (payload === null || payload === void 0 ? void 0 : (_payload_user = payload.user) === null || _payload_user === void 0 ? void 0 : _payload_user.email);\n            if (typeof email === \"string\") return email;\n        } catch (e) {}\n    }\n    return localStorage.getItem(\"userEmail\") || \"\";\n}\nasync function readJsonOrText(res) {\n    const text = await res.text();\n    try {\n        return {\n            ok: res.ok,\n            status: res.status,\n            data: JSON.parse(text)\n        };\n    } catch (e) {\n        return {\n            ok: res.ok,\n            status: res.status,\n            data: text\n        };\n    }\n}\nfunction ensureOk(r, what) {\n    if (!r.ok) {\n        const msg = typeof r.data === \"string\" ? r.data : JSON.stringify(r.data, null, 2);\n        throw new Error(\"\".concat(what, \" failed (\").concat(r.status, \") - \").concat(msg));\n    }\n    return r.data;\n}\n// -------------------------------\n/** Analysis history */ async function fetchAnalysisHistory(email) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    const params = new URLSearchParams({\n        email,\n        page: String(page),\n        limit: String(limit),\n        ts: String(Date.now())\n    });\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/analyze?\").concat(params.toString()), {\n        method: \"GET\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        cache: \"no-store\",\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Fetch analysis history\");\n}\nasync function deleteAnalysisResult(id) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/analyze/\").concat(id), {\n        method: \"DELETE\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Delete analysis result\");\n}\n// -------------------------------\n/** Stripe (unchanged) */ async function startCheckout(email, packageId) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/checkout/create-checkout-session\"), {\n        method: \"POST\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        credentials: \"include\",\n        body: JSON.stringify(LEGACY_EMAIL ? {\n            email,\n            packageId\n        } : {\n            packageId\n        })\n    });\n    const { ok, data } = await readJsonOrText(res);\n    if (!ok) throw new Error(typeof data === \"string\" ? data : (data === null || data === void 0 ? void 0 : data.error) || \"Failed to start checkout\");\n    if (!(data === null || data === void 0 ? void 0 : data.url)) throw new Error(\"No checkout URL returned\");\n    window.location.href = data.url;\n}\nasync function verifySession(sessionId) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/checkout/verify-session?session_id=\").concat(encodeURIComponent(sessionId)));\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Verify session\");\n}\nasync function purchasePackage(email, packageId) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/purchase\"), {\n        method: \"POST\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        credentials: \"include\",\n        body: JSON.stringify(LEGACY_EMAIL ? {\n            email,\n            packageId\n        } : {\n            packageId\n        })\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Purchase package\");\n}\nasync function checkUserPackage(email) {\n    const url = LEGACY_EMAIL ? \"\".concat(BASE_URL, \"/api/user/check-package?email=\").concat(encodeURIComponent(email)) : \"\".concat(BASE_URL, \"/api/user/check-package\");\n    const res = await fetch(url, {\n        headers: authHeaders(),\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Check user package\");\n}\n// -------------------------------\n/** Coach chat + conversations */ async function coachChat(param) {\n    let { question, latestContentInfo, conversationId, title } = param;\n    try {\n        const res = await fetch(\"\".concat(BASE_URL, \"/api/coach-chat\"), {\n            method: \"POST\",\n            headers: authHeaders({\n                \"Content-Type\": \"application/json\"\n            }),\n            credentials: \"include\",\n            body: JSON.stringify(LEGACY_EMAIL ? {\n                question,\n                latestContentInfo,\n                conversationId,\n                title,\n                email: getClientEmail()\n            } : {\n                question,\n                latestContentInfo,\n                conversationId,\n                title\n            })\n        });\n        const parsed = await readJsonOrText(res);\n        if (res.status === 200) return {\n            status: 200,\n            data: parsed.data\n        };\n        if (res.status === 402) return {\n            status: 402,\n            data: parsed.data\n        };\n        if (res.status === 429) return {\n            status: 429,\n            data: parsed.data\n        };\n        return {\n            status: res.status,\n            data: parsed.data\n        };\n    } catch (e) {\n        return {\n            status: 0,\n            data: {\n                error: \"Network error\"\n            }\n        };\n    }\n}\nasync function fetchConversation(id) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/conversations/\").concat(id), {\n        method: \"GET\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        cache: \"no-store\",\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Fetch conversation\");\n}\nasync function deleteConversation(conversationId) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/conversations/\").concat(conversationId), {\n        method: \"DELETE\",\n        headers: authHeaders(),\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Delete conversation\");\n}\nasync function createEmptyConversation(email) {\n    try {\n        const res = await fetch(\"\".concat(BASE_URL, \"/api/conversations\"), {\n            method: \"POST\",\n            headers: authHeaders({\n                \"Content-Type\": \"application/json\"\n            }),\n            credentials: \"include\",\n            body: JSON.stringify(LEGACY_EMAIL ? {\n                email\n            } : {})\n        });\n        const parsed = await readJsonOrText(res);\n        const data = ensureOk(parsed, \"Create conversation\");\n        var _data__id, _ref;\n        return (_ref = (_data__id = data._id) !== null && _data__id !== void 0 ? _data__id : data.id) !== null && _ref !== void 0 ? _ref : null;\n    } catch (error) {\n        console.error(\"Error creating new conversation:\", error);\n        return null;\n    }\n}\nasync function generateConversationTitle(conversationId, firstUserMessage) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/conversations/\").concat(conversationId, \"/generate-title\"), {\n        method: \"POST\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        credentials: \"include\",\n        body: JSON.stringify({\n            firstUserMessage\n        }),\n        cache: \"no-store\"\n    });\n    const parsed = await readJsonOrText(res);\n    const data = ensureOk(parsed, \"Generate title\");\n    return data.title || null;\n}\nasync function fetchConversations(email) {\n    const url = LEGACY_EMAIL ? \"\".concat(BASE_URL, \"/api/conversations?email=\").concat(encodeURIComponent(email), \"&ts=\").concat(Date.now()) : \"\".concat(BASE_URL, \"/api/conversations?ts=\").concat(Date.now());\n    const res = await fetch(url, {\n        method: \"GET\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        cache: \"no-store\",\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Fetch conversations\");\n}\n// -------------------------------\n/** Feedback */ async function sendFeedback(message, email) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/feedback\"), {\n        method: \"POST\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        credentials: \"include\",\n        body: JSON.stringify(LEGACY_EMAIL ? {\n            message,\n            email\n        } : {\n            message\n        })\n    });\n    const parsed = await readJsonOrText(res);\n    if (!parsed.ok) {\n        var _parsed_data;\n        throw new Error(typeof parsed.data === \"string\" ? parsed.data : ((_parsed_data = parsed.data) === null || _parsed_data === void 0 ? void 0 : _parsed_data.error) || \"Failed to send feedback (\".concat(parsed.status, \")\"));\n    }\n    return parsed.data;\n}\nfunction analyzeImageMultipart(opts) {\n    const { file, email, goal, linkBase, onProgress, captions = true } = opts;\n    const form = new FormData();\n    form.append(\"image\", file);\n    form.append(\"email\", email);\n    if (goal) form.append(\"goal\", goal);\n    if (linkBase) form.append(\"linkBase\", linkBase);\n    // Include browser timezone so backend returns local windows\n    try {\n        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        if (timezone) form.append(\"timezone\", timezone);\n    } catch (e) {}\n    const url = \"\".concat(BASE_URL, \"/api/analyze\") + (captions === false ? \"?captions=false\" : \"\");\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", url, true);\n        xhr.withCredentials = true;\n        xhr.onreadystatechange = ()=>{\n            if (xhr.readyState !== 4) return;\n            if (xhr.status >= 200 && xhr.status < 300) {\n                try {\n                    const json = JSON.parse(xhr.responseText);\n                    resolve(json);\n                } catch (e) {\n                    reject(new Error(\"Invalid JSON from server.\"));\n                }\n            } else {\n                try {\n                    const err = JSON.parse(xhr.responseText);\n                    reject(new Error((err === null || err === void 0 ? void 0 : err.error) || \"Upload failed (\".concat(xhr.status, \")\")));\n                } catch (e) {\n                    reject(new Error(\"Upload failed (\".concat(xhr.status, \")\")));\n                }\n            }\n        };\n        if (xhr.upload && typeof onProgress === \"function\") {\n            xhr.upload.onprogress = (evt)=>{\n                if (!evt.lengthComputable) return;\n                onProgress(Math.round(evt.loaded / evt.total * 100));\n            };\n        }\n        xhr.onerror = ()=>reject(new Error(\"Network error\"));\n        xhr.send(form);\n    });\n}\nasync function getAnalysisById(id) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/analyze/\").concat(id), {\n        cache: \"no-store\",\n        headers: authHeaders(),\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Fetch result by id\");\n}\nasync function updateAnalysisById(id, patch) {\n    const res = await fetch(\"\".concat(BASE_URL, \"/api/analyze/\").concat(id), {\n        method: \"PATCH\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        credentials: \"include\",\n        body: JSON.stringify(patch)\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Update analysis\");\n}\n// --- Quick Prompts API ---\nasync function fetchCoachChatPrompts(email) {\n    const url = LEGACY_EMAIL ? \"\".concat(BASE_URL, \"/api/coach-chat/prompts?email=\").concat(encodeURIComponent(email), \"&ts=\").concat(Date.now()) : \"\".concat(BASE_URL, \"/api/coach-chat/prompts?ts=\").concat(Date.now());\n    const res = await fetch(url, {\n        method: \"GET\",\n        headers: authHeaders({\n            \"Content-Type\": \"application/json\"\n        }),\n        cache: \"no-store\",\n        credentials: \"include\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Fetch coach prompts\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbHMvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1QkFBdUI7QUFHdkIsTUFBTUEsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtJQUM5QkY7QUFBdEIsTUFBTUcsZUFBZSxDQUFDSCxDQUFBQSw4Q0FBQUEsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyw4QkFBOEIsY0FBMUNKLHlEQUFBQSw4Q0FBOEMsR0FBRSxNQUFPO0FBRTdFLFNBQVNLLFdBQVdDLElBQVk7SUFDOUIsSUFBSSxPQUFPQyxhQUFhLGFBQWEsT0FBTztJQUM1QyxNQUFNQyxJQUFJRCxTQUFTRSxNQUFNLENBQUNDLEtBQUssQ0FBQyxJQUFJQyxPQUFPLGFBQWFMLEtBQUtNLE9BQU8sQ0FBQyw2QkFBNkIsVUFBVTtJQUM1RyxPQUFPSixJQUFJSyxtQkFBbUJMLENBQUMsQ0FBQyxFQUFFLElBQUk7QUFDeEM7QUFFQSxTQUFTTTtJQUNQLElBQUksT0FBT1AsYUFBYSxhQUFhLE9BQU87SUFDNUMsTUFBTUMsSUFBSUQsU0FBU0UsTUFBTSxDQUFDQyxLQUFLLENBQUM7SUFDaEMsT0FBT0YsSUFBSUssbUJBQW1CTCxDQUFDLENBQUMsRUFBRSxJQUFJO0FBQ3hDO0FBRUEsU0FBU087UUFBWUMsT0FBQUEsaUVBQW9CLENBQUM7SUFDeEMsTUFBTUMsUUFBUUg7SUFDZCxPQUFPRyxRQUFRO1FBQUUsR0FBR0QsSUFBSTtRQUFFRSxlQUFlLFVBQWdCLE9BQU5EO0lBQVEsSUFBSUQ7QUFDakU7QUFFQSxrQ0FBa0M7QUFDbEMsZ0JBQWdCO0FBQ2hCLGtDQUFrQztBQUMzQixTQUFTRztJQUNkLElBQUksS0FBNkIsRUFBRSxFQUFVO0lBQzdDLGtFQUFrRTtJQUNsRSxNQUFNVixTQUFTSixXQUFXO0lBQzFCLElBQUlJLFFBQVEsT0FBT0E7SUFDbkIsTUFBTVEsUUFBUUg7SUFDZCxJQUFJRyxPQUFPO1FB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QXlCO0lBRXpCLE1BQU1oRyxNQUFNLE1BQU1vQixNQUFNLEdBQTJCUSxPQUF4QjNELFVBQVMsaUJBQWtCLE9BQUgyRCxLQUFNO1FBQ3ZETixRQUFRO1FBQ1JDLFNBQVN0QyxZQUFZO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQzFEd0MsYUFBYTtRQUNiTSxNQUFNeEMsS0FBS2tCLFNBQVMsQ0FBQ3VGO0lBQ3ZCO0lBQ0EsTUFBTXRFLFNBQVMsTUFBTTNCLGVBQWVDO0lBQ3BDLE9BQU9LLFNBQW9CcUIsUUFBUTtBQUNyQztBQU9BLDRCQUE0QjtBQUNyQixlQUFldUUsc0JBQ3BCdEcsS0FBYTtJQUViLE1BQU1zQyxNQUFNNUQsZUFDUixHQUE0Q2tFLE9BQXpDdEUsVUFBUyxrQ0FBZ0VpRCxPQUFoQ3FCLG1CQUFtQjVDLFFBQU8sUUFBaUIsT0FBWHVCLEtBQUtDLEdBQUcsTUFDcEYsR0FBeUNELE9BQXRDakQsVUFBUywrQkFBd0MsT0FBWGlELEtBQUtDLEdBQUc7SUFDckQsTUFBTW5CLE1BQU0sTUFBTW9CLE1BQU1hLEtBQUs7UUFDM0JYLFFBQVE7UUFDUkMsU0FBU3RDLFlBQVk7WUFBRSxnQkFBZ0I7UUFBbUI7UUFDMUR1QyxPQUFPO1FBQ1BDLGFBQWE7SUFDZjtJQUNBLE1BQU1DLFNBQVMsTUFBTTNCLGVBQWVDO0lBQ3BDLE9BQU9LLFNBQWlDcUIsUUFBUTtBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3V0aWxzL2FwaS50cz85MzczIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9hcHAvdXRpbHMvYXBpLnRzXHJcbmltcG9ydCB0eXBlIHsgUmVzdWx0RG9jIH0gZnJvbSBcIkAvYXBwL3R5cGVzL2FuYWx5c2lzXCI7XHJcblxyXG5jb25zdCBCQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDFcIjtcbmNvbnN0IExFR0FDWV9FTUFJTCA9IChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19MRUdBQ1lfRU1BSUxfUEFSQU0gPz8gXCIxXCIpICE9PSBcIjBcIjtcblxuZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG0gPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cChcIig/Ol58OyApXCIgKyBuYW1lLnJlcGxhY2UoLyhbLiQ/Knx7fSgpXFxbXFxdXFxcXFxcL1xcK15dKS9nLCBcIlxcXFwkMVwiKSArIFwiPShbXjtdKilcIikpO1xuICByZXR1cm4gbSA/IGRlY29kZVVSSUNvbXBvbmVudChtWzFdKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEF1dGhUb2tlbkZyb21Db29raWVzKCk6IHN0cmluZyB8IG51bGwge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbSA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvKD86Xnw7ICkoc2Vzc2lvbnxhdXRoX3Rva2VuKT0oW147XSspLyk7XG4gIHJldHVybiBtID8gZGVjb2RlVVJJQ29tcG9uZW50KG1bMl0pIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gYXV0aEhlYWRlcnMoYmFzZTogSGVhZGVyc0luaXQgPSB7fSk6IEhlYWRlcnNJbml0IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRBdXRoVG9rZW5Gcm9tQ29va2llcygpO1xuICByZXR1cm4gdG9rZW4gPyB7IC4uLmJhc2UsIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gIH0gOiBiYXNlO1xufVxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gU21hbGwgaGVscGVyc1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRFbWFpbCgpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFwiXCI7XG4gIC8vIFByZWZlciBjb29raWUgb3IgSldUIHBheWxvYWQ7IGZhbGxiYWNrIHJldGFpbmVkIGZvciBsZWdhY3kgb25seVxuICBjb25zdCBjb29raWUgPSByZWFkQ29va2llKFwidXNlckVtYWlsXCIpO1xuICBpZiAoY29va2llKSByZXR1cm4gY29va2llO1xuICBjb25zdCB0b2tlbiA9IGdldEF1dGhUb2tlbkZyb21Db29raWVzKCk7XG4gIGlmICh0b2tlbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhdG9iKHRva2VuLnNwbGl0KFwiLlwiKVsxXSkpO1xuICAgICAgY29uc3QgZW1haWwgPSBwYXlsb2FkPy5lbWFpbCB8fCBwYXlsb2FkPy51c2VyPy5lbWFpbDtcbiAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09IFwic3RyaW5nXCIpIHJldHVybiBlbWFpbDtcbiAgICB9IGNhdGNoIHt9XG4gIH1cbiAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlckVtYWlsXCIpIHx8IFwiXCI7XG59XG5cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEpzb25PclRleHQocmVzOiBSZXNwb25zZSkge1xyXG4gIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4geyBvazogcmVzLm9rLCBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IEpTT04ucGFyc2UodGV4dCkgfTtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiB7IG9rOiByZXMub2ssIHN0YXR1czogcmVzLnN0YXR1cywgZGF0YTogdGV4dCB9O1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5zdXJlT2s8VCA9IHVua25vd24+KFxyXG4gIHI6IHsgb2s6IGJvb2xlYW47IHN0YXR1czogbnVtYmVyOyBkYXRhOiB1bmtub3duIH0sXHJcbiAgd2hhdDogc3RyaW5nXHJcbik6IFQge1xyXG4gIGlmICghci5vaykge1xyXG4gICAgY29uc3QgbXNnID1cclxuICAgICAgdHlwZW9mIHIuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IHIuZGF0YSA6IEpTT04uc3RyaW5naWZ5KHIuZGF0YSwgbnVsbCwgMik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7d2hhdH0gZmFpbGVkICgke3Iuc3RhdHVzfSkgLSAke21zZ31gKTtcclxuICB9XHJcbiAgcmV0dXJuIHIuZGF0YSBhcyBUO1xyXG59XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qKiBBbmFseXNpcyBoaXN0b3J5ICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFuYWx5c2lzSGlzdG9yeShcclxuICBlbWFpbDogc3RyaW5nLFxyXG4gIHBhZ2UgPSAxLFxyXG4gIGxpbWl0ID0gMTBcclxuKTogUHJvbWlzZTx7IHJlc3VsdHM6IFJlc3VsdERvY1tdOyB0b3RhbDogbnVtYmVyIH0+IHtcclxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgIGVtYWlsLFxyXG4gICAgcGFnZTogU3RyaW5nKHBhZ2UpLFxyXG4gICAgbGltaXQ6IFN0cmluZyhsaW1pdCksXHJcbiAgICB0czogU3RyaW5nKERhdGUubm93KCkpLFxyXG4gIH0pO1xyXG5cclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtCQVNFX1VSTH0vYXBpL2FuYWx5emU/JHtwYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSksXG4gICAgY2FjaGU6IFwibm8tc3RvcmVcIixcbiAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gIH0pO1xuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIHJldHVybiBlbnN1cmVPazx7IHJlc3VsdHM6IFJlc3VsdERvY1tdOyB0b3RhbDogbnVtYmVyIH0+KFxyXG4gICAgcGFyc2VkLFxyXG4gICAgXCJGZXRjaCBhbmFseXNpcyBoaXN0b3J5XCJcclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQW5hbHlzaXNSZXN1bHQoaWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvYW5hbHl6ZS8ke2lkfWAsIHtcbiAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgaGVhZGVyczogYXV0aEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSxcbiAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gIH0pO1xuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIHJldHVybiBlbnN1cmVPazx7IG1lc3NhZ2U6IHN0cmluZyB9PihwYXJzZWQsIFwiRGVsZXRlIGFuYWx5c2lzIHJlc3VsdFwiKTtcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKiogU3RyaXBlICh1bmNoYW5nZWQpICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydENoZWNrb3V0KGVtYWlsOiBzdHJpbmcsIHBhY2thZ2VJZDogc3RyaW5nKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvY2hlY2tvdXQvY3JlYXRlLWNoZWNrb3V0LXNlc3Npb25gLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0pLFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShMRUdBQ1lfRU1BSUwgPyB7IGVtYWlsLCBwYWNrYWdlSWQgfSA6IHsgcGFja2FnZUlkIH0pLFxuICB9KTtcbiAgY29uc3QgeyBvaywgZGF0YSB9ID0gYXdhaXQgcmVhZEpzb25PclRleHQocmVzKTtcclxuICBpZiAoIW9rKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBkYXRhPy5lcnJvciB8fCBcIkZhaWxlZCB0byBzdGFydCBjaGVja291dFwiXHJcbiAgICApO1xyXG4gIGlmICghZGF0YT8udXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGVja291dCBVUkwgcmV0dXJuZWRcIik7XHJcbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkYXRhLnVybDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNlc3Npb24oc2Vzc2lvbklkOiBzdHJpbmcpIHtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcclxuICAgIGAke0JBU0VfVVJMfS9hcGkvY2hlY2tvdXQvdmVyaWZ5LXNlc3Npb24/c2Vzc2lvbl9pZD0ke2VuY29kZVVSSUNvbXBvbmVudChcclxuICAgICAgc2Vzc2lvbklkXHJcbiAgICApfWBcclxuICApO1xyXG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rPHsgc3RhdHVzOiBzdHJpbmc7IGVtYWlsPzogc3RyaW5nOyBwYWNrYWdlSWQ/OiBzdHJpbmcgfT4oXHJcbiAgICBwYXJzZWQsXHJcbiAgICBcIlZlcmlmeSBzZXNzaW9uXCJcclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQdXJjaGFzZVJlc3BvbnNlID0geyBtZXNzYWdlOiBzdHJpbmcgfTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXJjaGFzZVBhY2thZ2UoZW1haWw6IHN0cmluZywgcGFja2FnZUlkOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS9wdXJjaGFzZWAsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSksXG4gICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KExFR0FDWV9FTUFJTCA/IHsgZW1haWwsIHBhY2thZ2VJZCB9IDogeyBwYWNrYWdlSWQgfSksXG4gIH0pO1xuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIHJldHVybiBlbnN1cmVPazxQdXJjaGFzZVJlc3BvbnNlPihwYXJzZWQsIFwiUHVyY2hhc2UgcGFja2FnZVwiKTtcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKiogVXNlci9wYWNrYWdlICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlclBhY2thZ2VSZXNwb25zZSB7XHJcbiAgaGFzQWNjZXNzOiBib29sZWFuO1xyXG4gIHBhY2thZ2U/OiBzdHJpbmc7XHJcbiAgdXBsb2Fkc1JlbWFpbmluZz86IG51bWJlcjtcclxuICBleHBpcmVzQXQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1VzZXJQYWNrYWdlKFxuICBlbWFpbDogc3RyaW5nXG4pOiBQcm9taXNlPFVzZXJQYWNrYWdlUmVzcG9uc2U+IHtcbiAgY29uc3QgdXJsID0gTEVHQUNZX0VNQUlMXG4gICAgPyBgJHtCQVNFX1VSTH0vYXBpL3VzZXIvY2hlY2stcGFja2FnZT9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9YFxuICAgIDogYCR7QkFTRV9VUkx9L2FwaS91c2VyL2NoZWNrLXBhY2thZ2VgO1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHsgaGVhZGVyczogYXV0aEhlYWRlcnMoKSwgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiIH0pO1xuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xuICByZXR1cm4gZW5zdXJlT2s8VXNlclBhY2thZ2VSZXNwb25zZT4ocGFyc2VkLCBcIkNoZWNrIHVzZXIgcGFja2FnZVwiKTtcbn1cblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENoYXQgdHlwZXMgKGlubGluZSlcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRNZXRhIHtcclxuICB1c2VkQ29udGV4dElkcz86IHN0cmluZ1tdO1xyXG4gIHJlcXVlc3RJZD86IHN0cmluZztcclxuICBsYXRlbmN5TXM/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdE1lc3NhZ2Uge1xyXG4gIHJvbGU6IFwidXNlclwiIHwgXCJhc3Npc3RhbnRcIjtcclxuICBjb250ZW50OiBzdHJpbmc7XHJcbiAgX2lkPzogc3RyaW5nO1xyXG4gIG1ldGE/OiBDaGF0TWV0YTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29udmVyc2F0aW9uIHtcclxuICBfaWQ6IHN0cmluZztcclxuICB0aXRsZT86IHN0cmluZztcclxuICBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXTtcclxuICB1cGRhdGVkQXQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uU3VtbWFyeSB7XHJcbiAgX2lkOiBzdHJpbmc7XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgdXBkYXRlZEF0Pzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbiB7XHJcbiAgX2lkOiBzdHJpbmc7XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgbWVzc2FnZXM6IENoYXRNZXNzYWdlW107XHJcbiAgdXBkYXRlZEF0Pzogc3RyaW5nO1xyXG59XHJcblxyXG4vLyAyMDAgT0sgcGF5bG9hZFxyXG5leHBvcnQgaW50ZXJmYWNlIENvYWNoQ2hhdFJlc3BvbnNlIHtcclxuICBhaTogc3RyaW5nO1xyXG4gIGNvbnZlcnNhdGlvbjogQ2hhdENvbnZlcnNhdGlvbjtcclxuICB1c2VkQ29udGV4dElkcz86IHN0cmluZ1tdO1xyXG4gIHJlcXVlc3RJZD86IHN0cmluZztcclxuICBsYXRlbmN5TXM/OiBudW1iZXI7XHJcbiAgcXVvdGE/OiB7IHVzZWQ6IG51bWJlcjsgbGltaXQ6IG51bWJlciB9OyAvLyBvcHRpb25hbFxyXG59XHJcblxyXG4vLyBub24tMjAwIHBheWxvYWRzXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29hY2hDaGF0TGltaXREYXRhIHtcclxuICBlcnJvcjogc3RyaW5nO1xyXG4gIGFjdGlvbj86IFwidXBncmFkZVwiO1xyXG4gIHF1b3RhPzogeyB1c2VkOiBudW1iZXI7IGxpbWl0OiBudW1iZXIgfTtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIENvYWNoQ2hhdFJhdGVMaW1pdERhdGEge1xyXG4gIGVycm9yPzogc3RyaW5nO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBDb2FjaENoYXROZXR3b3JrRXJyb3Ige1xyXG4gIGVycm9yOiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBDb2FjaENoYXRHZW5lcmljRXJyb3Ige1xyXG4gIGVycm9yPzogc3RyaW5nO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIERpc2NyaW1pbmF0ZWQgdW5pb24gKG5vIGBhbnlgKVxyXG5leHBvcnQgdHlwZSBDb2FjaENoYXRSZXN1bHQgPVxyXG4gIHwgeyBzdGF0dXM6IDIwMDsgZGF0YTogQ29hY2hDaGF0UmVzcG9uc2UgfVxyXG4gIHwgeyBzdGF0dXM6IDQwMjsgZGF0YTogQ29hY2hDaGF0TGltaXREYXRhIH1cclxuICB8IHsgc3RhdHVzOiA0Mjk7IGRhdGE6IENvYWNoQ2hhdFJhdGVMaW1pdERhdGEgfVxyXG4gIHwgeyBzdGF0dXM6IDA7IGRhdGE6IENvYWNoQ2hhdE5ldHdvcmtFcnJvciB9XHJcbiAgfCB7IHN0YXR1czogbnVtYmVyOyBkYXRhOiBDb2FjaENoYXRHZW5lcmljRXJyb3IgfTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqIENvYWNoIGNoYXQgKyBjb252ZXJzYXRpb25zICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2FjaENoYXQoe1xuICBxdWVzdGlvbixcbiAgbGF0ZXN0Q29udGVudEluZm8sXG4gIGNvbnZlcnNhdGlvbklkLFxuICB0aXRsZSxcbn06IHtcbiAgcXVlc3Rpb246IHN0cmluZztcbiAgbGF0ZXN0Q29udGVudEluZm8/OiBzdHJpbmc7XG4gIGNvbnZlcnNhdGlvbklkPzogc3RyaW5nO1xuICB0aXRsZT86IHN0cmluZztcbn0pOiBQcm9taXNlPENvYWNoQ2hhdFJlc3VsdD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvY29hY2gtY2hhdGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0pLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIExFR0FDWV9FTUFJTFxuICAgICAgICAgID8geyBxdWVzdGlvbiwgbGF0ZXN0Q29udGVudEluZm8sIGNvbnZlcnNhdGlvbklkLCB0aXRsZSwgZW1haWw6IGdldENsaWVudEVtYWlsKCkgfVxuICAgICAgICAgIDogeyBxdWVzdGlvbiwgbGF0ZXN0Q29udGVudEluZm8sIGNvbnZlcnNhdGlvbklkLCB0aXRsZSB9XG4gICAgICApLFxuICAgIH0pO1xuXHJcbiAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMClcclxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAsIGRhdGE6IHBhcnNlZC5kYXRhIGFzIENvYWNoQ2hhdFJlc3BvbnNlIH07XHJcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAyKVxyXG4gICAgICByZXR1cm4geyBzdGF0dXM6IDQwMiwgZGF0YTogcGFyc2VkLmRhdGEgYXMgQ29hY2hDaGF0TGltaXREYXRhIH07XHJcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDI5KVxyXG4gICAgICByZXR1cm4geyBzdGF0dXM6IDQyOSwgZGF0YTogcGFyc2VkLmRhdGEgYXMgQ29hY2hDaGF0UmF0ZUxpbWl0RGF0YSB9O1xyXG4gICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBkYXRhOiBwYXJzZWQuZGF0YSBhcyBDb2FjaENoYXRHZW5lcmljRXJyb3IgfTtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiB7IHN0YXR1czogMCwgZGF0YTogeyBlcnJvcjogXCJOZXR3b3JrIGVycm9yXCIgfSB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29udmVyc2F0aW9uKGlkOiBzdHJpbmcpOiBQcm9taXNlPENvbnZlcnNhdGlvbj4ge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvY29udmVyc2F0aW9ucy8ke2lkfWAsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczogYXV0aEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSxcbiAgICBjYWNoZTogXCJuby1zdG9yZVwiLFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgfSk7XG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rPENvbnZlcnNhdGlvbj4ocGFyc2VkLCBcIkZldGNoIGNvbnZlcnNhdGlvblwiKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUNvbnZlcnNhdGlvbihjb252ZXJzYXRpb25JZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9YCwge1xuICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgfSk7XG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rKHBhcnNlZCwgXCJEZWxldGUgY29udmVyc2F0aW9uXCIpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRW1wdHlDb252ZXJzYXRpb24oXG4gIGVtYWlsOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvY29udmVyc2F0aW9uc2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0pLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoTEVHQUNZX0VNQUlMID8geyBlbWFpbCB9IDoge30pLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgICBjb25zdCBkYXRhID0gZW5zdXJlT2s8eyBfaWQ/OiBzdHJpbmc7IGlkPzogc3RyaW5nIH0+KFxyXG4gICAgICBwYXJzZWQsXHJcbiAgICAgIFwiQ3JlYXRlIGNvbnZlcnNhdGlvblwiXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGRhdGEuX2lkID8/IGRhdGEuaWQgPz8gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIG5ldyBjb252ZXJzYXRpb246XCIsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ29udmVyc2F0aW9uVGl0bGUoXHJcbiAgY29udmVyc2F0aW9uSWQ6IHN0cmluZyxcclxuICBmaXJzdFVzZXJNZXNzYWdlOiBzdHJpbmdcclxuKSB7XHJcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG4gICAgYCR7QkFTRV9VUkx9L2FwaS9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9L2dlbmVyYXRlLXRpdGxlYCxcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSxcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZmlyc3RVc2VyTWVzc2FnZSB9KSxcbiAgICAgIGNhY2hlOiBcIm5vLXN0b3JlXCIsXG4gICAgfVxuICApO1xuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIGNvbnN0IGRhdGEgPSBlbnN1cmVPazx7IHRpdGxlOiBzdHJpbmcgfCBudWxsIH0+KHBhcnNlZCwgXCJHZW5lcmF0ZSB0aXRsZVwiKTtcclxuICByZXR1cm4gZGF0YS50aXRsZSB8fCBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb252ZXJzYXRpb25zKFxuICBlbWFpbDogc3RyaW5nXG4pOiBQcm9taXNlPENvbnZlcnNhdGlvblN1bW1hcnlbXT4ge1xuICBjb25zdCB1cmwgPSBMRUdBQ1lfRU1BSUxcbiAgICA/IGAke0JBU0VfVVJMfS9hcGkvY29udmVyc2F0aW9ucz9lbWFpbD0ke2VuY29kZVVSSUNvbXBvbmVudChlbWFpbCl9JnRzPSR7RGF0ZS5ub3coKX1gXG4gICAgOiBgJHtCQVNFX1VSTH0vYXBpL2NvbnZlcnNhdGlvbnM/dHM9JHtEYXRlLm5vdygpfWA7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiBhdXRoSGVhZGVycyh7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0pLFxuICAgIGNhY2hlOiBcIm5vLXN0b3JlXCIsXG4gICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICB9KTtcbiAgY29uc3QgcGFyc2VkID0gYXdhaXQgcmVhZEpzb25PclRleHQocmVzKTtcclxuICByZXR1cm4gZW5zdXJlT2s8Q29udmVyc2F0aW9uU3VtbWFyeVtdPihwYXJzZWQsIFwiRmV0Y2ggY29udmVyc2F0aW9uc1wiKTtcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKiogRmVlZGJhY2sgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRGZWVkYmFjayhcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBlbWFpbD86IHN0cmluZ1xuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4gfT4ge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtCQVNFX1VSTH0vYXBpL2ZlZWRiYWNrYCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczogYXV0aEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSxcbiAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoTEVHQUNZX0VNQUlMID8geyBtZXNzYWdlLCBlbWFpbCB9IDogeyBtZXNzYWdlIH0pLFxuICB9KTtcblxyXG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgaWYgKCFwYXJzZWQub2spIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgdHlwZW9mIHBhcnNlZC5kYXRhID09PSBcInN0cmluZ1wiXHJcbiAgICAgICAgPyBwYXJzZWQuZGF0YVxyXG4gICAgICAgIDogcGFyc2VkLmRhdGE/LmVycm9yIHx8IGBGYWlsZWQgdG8gc2VuZCBmZWVkYmFjayAoJHtwYXJzZWQuc3RhdHVzfSlgXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gcGFyc2VkLmRhdGEgYXMgeyBzdWNjZXNzOiBib29sZWFuIH07XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqIEFuYWx5emUgKHVwbG9hZCArIGdldC91cGRhdGUpICovXHJcbmV4cG9ydCB0eXBlIEFuYWx5emVSZXNwb25zZSA9IHtcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG4gIHJlcXVlc3RJZD86IHN0cmluZztcclxuICBpbnNpZ2h0czogUmVzdWx0RG9jO1xyXG4gIGR1cmF0aW9ucz86IHtcclxuICAgIHRvdGFsX21zOiBudW1iZXI7XHJcbiAgICB2aXNpb25fbXM6IG51bWJlcjtcclxuICAgIGNhcHRpb25zX21zOiBudW1iZXI7XHJcbiAgfTtcclxuICBkdXBsaWNhdGU/OiBib29sZWFuO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVJbWFnZU11bHRpcGFydChvcHRzOiB7XHJcbiAgZmlsZTogRmlsZTtcclxuICBlbWFpbDogc3RyaW5nO1xyXG4gIGdvYWw/OiBcInN1YnNcIiB8IFwicHB2XCIgfCBcImN1c3RvbXNcIjtcclxuICBsaW5rQmFzZT86IHN0cmluZztcclxuICBjYXB0aW9ucz86IGJvb2xlYW47IC8vIGRlZmF1bHQgdHJ1ZVxyXG4gIG9uUHJvZ3Jlc3M/OiAocGN0OiBudW1iZXIpID0+IHZvaWQ7XHJcbn0pOiBQcm9taXNlPEFuYWx5emVSZXNwb25zZT4ge1xyXG4gIGNvbnN0IHsgZmlsZSwgZW1haWwsIGdvYWwsIGxpbmtCYXNlLCBvblByb2dyZXNzLCBjYXB0aW9ucyA9IHRydWUgfSA9IG9wdHM7XHJcblxyXG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcclxuICBmb3JtLmFwcGVuZChcImltYWdlXCIsIGZpbGUpO1xyXG4gIGZvcm0uYXBwZW5kKFwiZW1haWxcIiwgZW1haWwpO1xyXG4gIGlmIChnb2FsKSBmb3JtLmFwcGVuZChcImdvYWxcIiwgZ29hbCk7XHJcbiAgaWYgKGxpbmtCYXNlKSBmb3JtLmFwcGVuZChcImxpbmtCYXNlXCIsIGxpbmtCYXNlKTtcclxuXHJcbiAgLy8gSW5jbHVkZSBicm93c2VyIHRpbWV6b25lIHNvIGJhY2tlbmQgcmV0dXJucyBsb2NhbCB3aW5kb3dzXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHRpbWV6b25lID0gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xyXG4gICAgaWYgKHRpbWV6b25lKSBmb3JtLmFwcGVuZChcInRpbWV6b25lXCIsIHRpbWV6b25lKTtcclxuICB9IGNhdGNoIHt9XHJcblxyXG4gIGNvbnN0IHVybCA9IGAke0JBU0VfVVJMfS9hcGkvYW5hbHl6ZWAgKyAoY2FwdGlvbnMgPT09IGZhbHNlID8gYD9jYXB0aW9ucz1mYWxzZWAgOiBcIlwiKTtcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHhoci5vcGVuKFwiUE9TVFwiLCB1cmwsIHRydWUpO1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHJcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkgYXMgQW5hbHl6ZVJlc3BvbnNlO1xyXG4gICAgICAgIHJlc29sdmUoanNvbik7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBKU09OIGZyb20gc2VydmVyLlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBlcnIgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnI/LmVycm9yIHx8IGBVcGxvYWQgZmFpbGVkICgke3hoci5zdGF0dXN9KWApKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFVwbG9hZCBmYWlsZWQgKCR7eGhyLnN0YXR1c30pYCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoeGhyLnVwbG9hZCAmJiB0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IChldnQpID0+IHtcclxuICAgICAgICBpZiAoIWV2dC5sZW5ndGhDb21wdXRhYmxlKSByZXR1cm47XHJcbiAgICAgICAgb25Qcm9ncmVzcyhNYXRoLnJvdW5kKChldnQubG9hZGVkIC8gZXZ0LnRvdGFsKSAqIDEwMCkpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHhoci5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihcIk5ldHdvcmsgZXJyb3JcIikpO1xyXG4gICAgeGhyLnNlbmQoZm9ybSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbmFseXNpc0J5SWQoaWQ6IHN0cmluZykge1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtCQVNFX1VSTH0vYXBpL2FuYWx5emUvJHtpZH1gLCB7XG4gICAgY2FjaGU6IFwibm8tc3RvcmVcIixcbiAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgfSk7XG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rPFJlc3VsdERvYz4ocGFyc2VkLCBcIkZldGNoIHJlc3VsdCBieSBpZFwiKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFuYWx5c2lzQnlJZChcbiAgaWQ6IHN0cmluZyxcbiAgcGF0Y2g6IFBhcnRpYWw8UmVzdWx0RG9jPlxuKTogUHJvbWlzZTxSZXN1bHREb2M+IHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS9hbmFseXplLyR7aWR9YCwge1xuICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSksXG4gICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhdGNoKSxcbiAgfSk7XG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rPFJlc3VsdERvYz4ocGFyc2VkLCBcIlVwZGF0ZSBhbmFseXNpc1wiKTtcclxufVxyXG4vLyAtLS0gUXVpY2sgUHJvbXB0cyB0eXBlcyAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0UHJvbXB0c1Jlc3BvbnNlIHtcclxuICBwcm9tcHRzOiBzdHJpbmdbXTtcclxuICBtZXRhOiB7IHBsYW46IHN0cmluZzsgbmljaGU6IHN0cmluZzsgdHo6IHN0cmluZyB9O1xyXG59XHJcblxyXG4vLyAtLS0gUXVpY2sgUHJvbXB0cyBBUEkgLS0tXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaENvYWNoQ2hhdFByb21wdHMoXG4gIGVtYWlsOiBzdHJpbmdcbik6IFByb21pc2U8U3VnZ2VzdFByb21wdHNSZXNwb25zZT4ge1xuICBjb25zdCB1cmwgPSBMRUdBQ1lfRU1BSUxcbiAgICA/IGAke0JBU0VfVVJMfS9hcGkvY29hY2gtY2hhdC9wcm9tcHRzP2VtYWlsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGVtYWlsKX0mdHM9JHtEYXRlLm5vdygpfWBcbiAgICA6IGAke0JBU0VfVVJMfS9hcGkvY29hY2gtY2hhdC9wcm9tcHRzP3RzPSR7RGF0ZS5ub3coKX1gO1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczogYXV0aEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSxcbiAgICBjYWNoZTogXCJuby1zdG9yZVwiLFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgfSk7XG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rPFN1Z2dlc3RQcm9tcHRzUmVzcG9uc2U+KHBhcnNlZCwgXCJGZXRjaCBjb2FjaCBwcm9tcHRzXCIpO1xyXG59XG4iXSwibmFtZXMiOlsiQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkxFR0FDWV9FTUFJTCIsIk5FWFRfUFVCTElDX0xFR0FDWV9FTUFJTF9QQVJBTSIsInJlYWRDb29raWUiLCJuYW1lIiwiZG9jdW1lbnQiLCJtIiwiY29va2llIiwibWF0Y2giLCJSZWdFeHAiLCJyZXBsYWNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZ2V0QXV0aFRva2VuRnJvbUNvb2tpZXMiLCJhdXRoSGVhZGVycyIsImJhc2UiLCJ0b2tlbiIsIkF1dGhvcml6YXRpb24iLCJnZXRDbGllbnRFbWFpbCIsInBheWxvYWQiLCJKU09OIiwicGFyc2UiLCJhdG9iIiwic3BsaXQiLCJlbWFpbCIsInVzZXIiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicmVhZEpzb25PclRleHQiLCJyZXMiLCJ0ZXh0Iiwib2siLCJzdGF0dXMiLCJkYXRhIiwiZW5zdXJlT2siLCJyIiwid2hhdCIsIm1zZyIsInN0cmluZ2lmeSIsIkVycm9yIiwiZmV0Y2hBbmFseXNpc0hpc3RvcnkiLCJwYWdlIiwibGltaXQiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJTdHJpbmciLCJ0cyIsIkRhdGUiLCJub3ciLCJmZXRjaCIsInRvU3RyaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsImNhY2hlIiwiY3JlZGVudGlhbHMiLCJwYXJzZWQiLCJkZWxldGVBbmFseXNpc1Jlc3VsdCIsImlkIiwic3RhcnRDaGVja291dCIsInBhY2thZ2VJZCIsImJvZHkiLCJlcnJvciIsInVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsInZlcmlmeVNlc3Npb24iLCJzZXNzaW9uSWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJwdXJjaGFzZVBhY2thZ2UiLCJjaGVja1VzZXJQYWNrYWdlIiwiY29hY2hDaGF0IiwicXVlc3Rpb24iLCJsYXRlc3RDb250ZW50SW5mbyIsImNvbnZlcnNhdGlvbklkIiwidGl0bGUiLCJmZXRjaENvbnZlcnNhdGlvbiIsImRlbGV0ZUNvbnZlcnNhdGlvbiIsImNyZWF0ZUVtcHR5Q29udmVyc2F0aW9uIiwiX2lkIiwiY29uc29sZSIsImdlbmVyYXRlQ29udmVyc2F0aW9uVGl0bGUiLCJmaXJzdFVzZXJNZXNzYWdlIiwiZmV0Y2hDb252ZXJzYXRpb25zIiwic2VuZEZlZWRiYWNrIiwibWVzc2FnZSIsImFuYWx5emVJbWFnZU11bHRpcGFydCIsIm9wdHMiLCJmaWxlIiwiZ29hbCIsImxpbmtCYXNlIiwib25Qcm9ncmVzcyIsImNhcHRpb25zIiwiZm9ybSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwidGltZXpvbmUiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJyZXNvbHZlZE9wdGlvbnMiLCJ0aW1lWm9uZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwid2l0aENyZWRlbnRpYWxzIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsImpzb24iLCJyZXNwb25zZVRleHQiLCJlcnIiLCJ1cGxvYWQiLCJvbnByb2dyZXNzIiwiZXZ0IiwibGVuZ3RoQ29tcHV0YWJsZSIsIk1hdGgiLCJyb3VuZCIsImxvYWRlZCIsInRvdGFsIiwib25lcnJvciIsInNlbmQiLCJnZXRBbmFseXNpc0J5SWQiLCJ1cGRhdGVBbmFseXNpc0J5SWQiLCJwYXRjaCIsImZldGNoQ29hY2hDaGF0UHJvbXB0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/utils/api.ts\n"));

/***/ })

});