"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/account/page",{

/***/ "(app-pages-browser)/./src/app/hooks/useUser.ts":
/*!**********************************!*\
  !*** ./src/app/hooks/useUser.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearUserCache: function() { return /* binding */ clearUserCache; },\n/* harmony export */   useUser: function() { return /* binding */ useUser; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _app_utils_fetcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/app/utils/fetcher */ \"(app-pages-browser)/./src/app/utils/fetcher.ts\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/navigation.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_navigation__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ useUser,clearUserCache auto */ \n\n\n// Simple in-memory cache to avoid duplicate /me calls across components\nlet cachedUser = undefined; // undefined = unknown, null = unauthenticated\nlet inFlight = null;\nlet lastFetched = 0;\nconst STALE_TTL_MS = 5000;\nasync function fetchUserOnce() {\n    if (inFlight) return inFlight;\n    inFlight = (async ()=>{\n        try {\n            const r = await (0,_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_1__.fetchJson)(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_1__.BASE_URL, \"/api/auth/me\"), {\n                method: \"GET\",\n                cache: \"no-store\"\n            });\n            cachedUser = r.ok ? r.data : null;\n        } catch (e) {\n            cachedUser = null;\n        } finally{\n            lastFetched = Date.now();\n            const val = cachedUser !== null && cachedUser !== void 0 ? cachedUser : null;\n            inFlight = null;\n            return val;\n        }\n    })();\n    return inFlight;\n}\nfunction useUser() {\n    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const { redirectTo = \"/login\", required = true, initialUser } = opts;\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let cancelled = false;\n        (async ()=>{\n            try {\n                // If the server already provided the user, use it immediately when truthy.\n                // If it's explicitly null but a client token exists (testing header auth),\n                // allow a client-side revalidation before redirecting.\n                if (typeof initialUser !== \"undefined\") {\n                    var _window_localStorage_getItem, _window_localStorage;\n                    const hasClientToken =  true && !!((_window_localStorage = window.localStorage) === null || _window_localStorage === void 0 ? void 0 : (_window_localStorage_getItem = _window_localStorage.getItem) === null || _window_localStorage_getItem === void 0 ? void 0 : _window_localStorage_getItem.call(_window_localStorage, \"ai_token\"));\n                    if (initialUser) {\n                        cachedUser = initialUser;\n                        lastFetched = Date.now();\n                        setUser(initialUser);\n                        setLoading(false);\n                        return;\n                    } else if (!initialUser && required && !hasClientToken) {\n                        // No server user and no client token â†’ redirect now.\n                        router.replace(redirectTo);\n                        setUser(null);\n                        setLoading(false);\n                        return;\n                    }\n                // else: initialUser is null but we have a client token; fall through to fetch\n                }\n                // Serve instantly from cache if fresh; revalidate in background if stale\n                const now = Date.now();\n                const fresh = cachedUser !== undefined && now - lastFetched < STALE_TTL_MS;\n                // For protected pages (required=true), bypass fresh cache to avoid\n                // letting a stale authenticated user slip through after logout.\n                if (fresh && !required) {\n                    setUser(cachedUser !== null && cachedUser !== void 0 ? cachedUser : null);\n                    setLoading(false);\n                    return;\n                }\n                const u = await fetchUserOnce();\n                if (cancelled) return;\n                setUser(u);\n                if (!u && required) router.replace(redirectTo);\n            } catch (e) {\n                if (cancelled) return;\n                setError(e);\n                setUser(null);\n                if (required) router.replace(redirectTo);\n            } finally{\n                if (!cancelled) setLoading(false);\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        redirectTo,\n        required,\n        router,\n        initialUser\n    ]);\n    return {\n        user,\n        loading,\n        error,\n        refresh: async ()=>{\n            setLoading(true);\n            try {\n                const u = await fetchUserOnce();\n                setUser(u);\n            } catch (e) {\n                setUser(null);\n                setError(e);\n            } finally{\n                setLoading(false);\n            }\n        }\n    };\n}\n// Allow callers (logout) to reset the in-memory user cache so the app\n// behaves like a fresh visit.\nfunction clearUserCache() {\n    cachedUser = undefined;\n    inFlight = null;\n    lastFetched = 0;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvaG9va3MvdXNlVXNlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OzRFQUU0QztBQUNjO0FBQ2Q7QUFJNUMsd0VBQXdFO0FBQ3hFLElBQUlLLGFBQStCQyxXQUFXLDhDQUE4QztBQUM1RixJQUFJQyxXQUFpQztBQUNyQyxJQUFJQyxjQUFjO0FBQ2xCLE1BQU1DLGVBQWU7QUFFckIsZUFBZUM7SUFDYixJQUFJSCxVQUFVLE9BQU9BO0lBQ3JCQSxXQUFXLENBQUM7UUFDVixJQUFJO1lBQ0YsTUFBTUksSUFBSSxNQUFNUiw2REFBU0EsQ0FBQyxHQUFZLE9BQVRELHdEQUFRQSxFQUFDLGlCQUFlO2dCQUFFVSxRQUFRO2dCQUFPQyxPQUFPO1lBQVc7WUFDeEZSLGFBQWFNLEVBQUVHLEVBQUUsR0FBSUgsRUFBRUksSUFBSSxHQUFZO1FBQ3pDLEVBQUUsVUFBTTtZQUNOVixhQUFhO1FBQ2YsU0FBVTtZQUNSRyxjQUFjUSxLQUFLQyxHQUFHO1lBQ3RCLE1BQU1DLE1BQU1iLHVCQUFBQSx3QkFBQUEsYUFBYztZQUMxQkUsV0FBVztZQUNYLE9BQU9XO1FBQ1Q7SUFDRjtJQUNBLE9BQU9YO0FBQ1Q7QUFFTyxTQUFTWTtRQUFRQyxPQUFBQSxpRUFBd0UsQ0FBQztJQUMvRixNQUFNLEVBQUVDLGFBQWEsUUFBUSxFQUFFQyxXQUFXLElBQUksRUFBRUMsV0FBVyxFQUFFLEdBQUdIO0lBQ2hFLE1BQU0sQ0FBQ0ksTUFBTUMsUUFBUSxHQUFHeEIsK0NBQVFBLENBQU87SUFDdkMsTUFBTSxDQUFDeUIsU0FBU0MsV0FBVyxHQUFHMUIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDMkIsT0FBT0MsU0FBUyxHQUFHNUIsK0NBQVFBLENBQVU7SUFDNUMsTUFBTTZCLFNBQVMxQiwwREFBU0E7SUFFeEJKLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSStCLFlBQVk7UUFDZjtZQUNDLElBQUk7Z0JBQ0YsMkVBQTJFO2dCQUMzRSwyRUFBMkU7Z0JBQzNFLHVEQUF1RDtnQkFDdkQsSUFBSSxPQUFPUixnQkFBZ0IsYUFBYTt3QkFFRFMsOEJBQUFBO29CQURyQyxNQUFNQyxpQkFDSixLQUE2QixJQUFJLENBQUMsR0FBQ0QsdUJBQUFBLE9BQU9FLFlBQVksY0FBbkJGLDRDQUFBQSwrQkFBQUEscUJBQXFCRyxPQUFPLGNBQTVCSCxtREFBQUEsa0NBQUFBLHNCQUErQjtvQkFDcEUsSUFBSVQsYUFBYTt3QkFDZmxCLGFBQWFrQjt3QkFDYmYsY0FBY1EsS0FBS0MsR0FBRzt3QkFDdEJRLFFBQVFGO3dCQUNSSSxXQUFXO3dCQUNYO29CQUNGLE9BQU8sSUFBSSxDQUFDSixlQUFlRCxZQUFZLENBQUNXLGdCQUFnQjt3QkFDdEQscURBQXFEO3dCQUNyREgsT0FBT00sT0FBTyxDQUFDZjt3QkFDZkksUUFBUTt3QkFDUkUsV0FBVzt3QkFDWDtvQkFDRjtnQkFDQSw4RUFBOEU7Z0JBQ2hGO2dCQUVBLHlFQUF5RTtnQkFDekUsTUFBTVYsTUFBTUQsS0FBS0MsR0FBRztnQkFDcEIsTUFBTW9CLFFBQVFoQyxlQUFlQyxhQUFhVyxNQUFNVCxjQUFjQztnQkFDOUQsbUVBQW1FO2dCQUNuRSxnRUFBZ0U7Z0JBQ2hFLElBQUk0QixTQUFTLENBQUNmLFVBQVU7b0JBQ3RCRyxRQUFRcEIsdUJBQUFBLHdCQUFBQSxhQUFjO29CQUN0QnNCLFdBQVc7b0JBQ1g7Z0JBQ0Y7Z0JBRUEsTUFBTVcsSUFBSSxNQUFNNUI7Z0JBQ2hCLElBQUlxQixXQUFXO2dCQUNmTixRQUFRYTtnQkFDUixJQUFJLENBQUNBLEtBQUtoQixVQUFVUSxPQUFPTSxPQUFPLENBQUNmO1lBQ3JDLEVBQUUsT0FBT2tCLEdBQUc7Z0JBQ1YsSUFBSVIsV0FBVztnQkFDZkYsU0FBU1U7Z0JBQ1RkLFFBQVE7Z0JBQ1IsSUFBSUgsVUFBVVEsT0FBT00sT0FBTyxDQUFDZjtZQUMvQixTQUFVO2dCQUNSLElBQUksQ0FBQ1UsV0FBV0osV0FBVztZQUM3QjtRQUNGO1FBQ0EsT0FBTztZQUFRSSxZQUFZO1FBQU07SUFDbkMsR0FBRztRQUFDVjtRQUFZQztRQUFVUTtRQUFRUDtLQUFZO0lBRTlDLE9BQU87UUFBRUM7UUFBTUU7UUFBU0U7UUFBT1ksU0FBUztZQUN0Q2IsV0FBVztZQUNYLElBQUk7Z0JBQ0YsTUFBTVcsSUFBSSxNQUFNNUI7Z0JBQ2hCZSxRQUFRYTtZQUNWLEVBQUUsT0FBT0MsR0FBRztnQkFDVmQsUUFBUTtnQkFDUkksU0FBU1U7WUFDWCxTQUFVO2dCQUNSWixXQUFXO1lBQ2I7UUFDRjtJQUFDO0FBQ0g7QUFFQSxzRUFBc0U7QUFDdEUsOEJBQThCO0FBQ3ZCLFNBQVNjO0lBQ2RwQyxhQUFhQztJQUNiQyxXQUFXO0lBQ1hDLGNBQWM7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9ob29rcy91c2VVc2VyLnRzPzE0N2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEJBU0VfVVJMLCBmZXRjaEpzb24gfSBmcm9tIFwiQC9hcHAvdXRpbHMvZmV0Y2hlclwiO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuXG50eXBlIFVzZXIgPSB7IGlkOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmc7IHBsYW4/OiBzdHJpbmcgfCBudWxsIH0gfCBudWxsO1xuXG4vLyBTaW1wbGUgaW4tbWVtb3J5IGNhY2hlIHRvIGF2b2lkIGR1cGxpY2F0ZSAvbWUgY2FsbHMgYWNyb3NzIGNvbXBvbmVudHNcbmxldCBjYWNoZWRVc2VyOiBVc2VyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkOyAvLyB1bmRlZmluZWQgPSB1bmtub3duLCBudWxsID0gdW5hdXRoZW50aWNhdGVkXG5sZXQgaW5GbGlnaHQ6IFByb21pc2U8VXNlcj4gfCBudWxsID0gbnVsbDtcbmxldCBsYXN0RmV0Y2hlZCA9IDA7XG5jb25zdCBTVEFMRV9UVExfTVMgPSA1MDAwO1xuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFVzZXJPbmNlKCk6IFByb21pc2U8VXNlcj4ge1xuICBpZiAoaW5GbGlnaHQpIHJldHVybiBpbkZsaWdodDtcbiAgaW5GbGlnaHQgPSAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gYXdhaXQgZmV0Y2hKc29uKGAke0JBU0VfVVJMfS9hcGkvYXV0aC9tZWAsIHsgbWV0aG9kOiBcIkdFVFwiLCBjYWNoZTogXCJuby1zdG9yZVwiIH0pO1xuICAgICAgY2FjaGVkVXNlciA9IHIub2sgPyAoci5kYXRhIGFzIFVzZXIpIDogbnVsbDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGNhY2hlZFVzZXIgPSBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsYXN0RmV0Y2hlZCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCB2YWwgPSBjYWNoZWRVc2VyID8/IG51bGw7XG4gICAgICBpbkZsaWdodCA9IG51bGw7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIGluRmxpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVXNlcihvcHRzOiB7IHJlZGlyZWN0VG8/OiBzdHJpbmc7IHJlcXVpcmVkPzogYm9vbGVhbjsgaW5pdGlhbFVzZXI/OiBVc2VyIH0gPSB7fSkge1xuICBjb25zdCB7IHJlZGlyZWN0VG8gPSBcIi9sb2dpblwiLCByZXF1aXJlZCA9IHRydWUsIGluaXRpYWxVc2VyIH0gPSBvcHRzO1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8dW5rbm93bj4obnVsbCk7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGFscmVhZHkgcHJvdmlkZWQgdGhlIHVzZXIsIHVzZSBpdCBpbW1lZGlhdGVseSB3aGVuIHRydXRoeS5cbiAgICAgICAgLy8gSWYgaXQncyBleHBsaWNpdGx5IG51bGwgYnV0IGEgY2xpZW50IHRva2VuIGV4aXN0cyAodGVzdGluZyBoZWFkZXIgYXV0aCksXG4gICAgICAgIC8vIGFsbG93IGEgY2xpZW50LXNpZGUgcmV2YWxpZGF0aW9uIGJlZm9yZSByZWRpcmVjdGluZy5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsVXNlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGNvbnN0IGhhc0NsaWVudFRva2VuID1cbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgISF3aW5kb3cubG9jYWxTdG9yYWdlPy5nZXRJdGVtPy4oXCJhaV90b2tlblwiKTtcbiAgICAgICAgICBpZiAoaW5pdGlhbFVzZXIpIHtcbiAgICAgICAgICAgIGNhY2hlZFVzZXIgPSBpbml0aWFsVXNlcjtcbiAgICAgICAgICAgIGxhc3RGZXRjaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHNldFVzZXIoaW5pdGlhbFVzZXIpO1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICghaW5pdGlhbFVzZXIgJiYgcmVxdWlyZWQgJiYgIWhhc0NsaWVudFRva2VuKSB7XG4gICAgICAgICAgICAvLyBObyBzZXJ2ZXIgdXNlciBhbmQgbm8gY2xpZW50IHRva2VuIOKGkiByZWRpcmVjdCBub3cuXG4gICAgICAgICAgICByb3V0ZXIucmVwbGFjZShyZWRpcmVjdFRvKTtcbiAgICAgICAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWxzZTogaW5pdGlhbFVzZXIgaXMgbnVsbCBidXQgd2UgaGF2ZSBhIGNsaWVudCB0b2tlbjsgZmFsbCB0aHJvdWdoIHRvIGZldGNoXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXJ2ZSBpbnN0YW50bHkgZnJvbSBjYWNoZSBpZiBmcmVzaDsgcmV2YWxpZGF0ZSBpbiBiYWNrZ3JvdW5kIGlmIHN0YWxlXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZyZXNoID0gY2FjaGVkVXNlciAhPT0gdW5kZWZpbmVkICYmIG5vdyAtIGxhc3RGZXRjaGVkIDwgU1RBTEVfVFRMX01TO1xuICAgICAgICAvLyBGb3IgcHJvdGVjdGVkIHBhZ2VzIChyZXF1aXJlZD10cnVlKSwgYnlwYXNzIGZyZXNoIGNhY2hlIHRvIGF2b2lkXG4gICAgICAgIC8vIGxldHRpbmcgYSBzdGFsZSBhdXRoZW50aWNhdGVkIHVzZXIgc2xpcCB0aHJvdWdoIGFmdGVyIGxvZ291dC5cbiAgICAgICAgaWYgKGZyZXNoICYmICFyZXF1aXJlZCkge1xuICAgICAgICAgIHNldFVzZXIoY2FjaGVkVXNlciA/PyBudWxsKTtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1ID0gYXdhaXQgZmV0Y2hVc2VyT25jZSgpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHNldFVzZXIodSk7XG4gICAgICAgIGlmICghdSAmJiByZXF1aXJlZCkgcm91dGVyLnJlcGxhY2UocmVkaXJlY3RUbyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc2V0RXJyb3IoZSk7XG4gICAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgICAgIGlmIChyZXF1aXJlZCkgcm91dGVyLnJlcGxhY2UocmVkaXJlY3RUbyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoIWNhbmNlbGxlZCkgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgICByZXR1cm4gKCkgPT4geyBjYW5jZWxsZWQgPSB0cnVlOyB9O1xuICB9LCBbcmVkaXJlY3RUbywgcmVxdWlyZWQsIHJvdXRlciwgaW5pdGlhbFVzZXJdKTtcblxuICByZXR1cm4geyB1c2VyLCBsb2FkaW5nLCBlcnJvciwgcmVmcmVzaDogYXN5bmMgKCkgPT4ge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHUgPSBhd2FpdCBmZXRjaFVzZXJPbmNlKCk7XG4gICAgICBzZXRVc2VyKHUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgICBzZXRFcnJvcihlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9fTtcbn1cblxuLy8gQWxsb3cgY2FsbGVycyAobG9nb3V0KSB0byByZXNldCB0aGUgaW4tbWVtb3J5IHVzZXIgY2FjaGUgc28gdGhlIGFwcFxuLy8gYmVoYXZlcyBsaWtlIGEgZnJlc2ggdmlzaXQuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJVc2VyQ2FjaGUoKSB7XG4gIGNhY2hlZFVzZXIgPSB1bmRlZmluZWQ7XG4gIGluRmxpZ2h0ID0gbnVsbDtcbiAgbGFzdEZldGNoZWQgPSAwO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiQkFTRV9VUkwiLCJmZXRjaEpzb24iLCJ1c2VSb3V0ZXIiLCJjYWNoZWRVc2VyIiwidW5kZWZpbmVkIiwiaW5GbGlnaHQiLCJsYXN0RmV0Y2hlZCIsIlNUQUxFX1RUTF9NUyIsImZldGNoVXNlck9uY2UiLCJyIiwibWV0aG9kIiwiY2FjaGUiLCJvayIsImRhdGEiLCJEYXRlIiwibm93IiwidmFsIiwidXNlVXNlciIsIm9wdHMiLCJyZWRpcmVjdFRvIiwicmVxdWlyZWQiLCJpbml0aWFsVXNlciIsInVzZXIiLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicm91dGVyIiwiY2FuY2VsbGVkIiwid2luZG93IiwiaGFzQ2xpZW50VG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicmVwbGFjZSIsImZyZXNoIiwidSIsImUiLCJyZWZyZXNoIiwiY2xlYXJVc2VyQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/hooks/useUser.ts\n"));

/***/ })

});