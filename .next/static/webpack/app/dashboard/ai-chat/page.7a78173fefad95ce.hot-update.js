"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/ai-chat/page",{

/***/ "(app-pages-browser)/./src/app/utils/api.ts":
/*!******************************!*\
  !*** ./src/app/utils/api.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeImageMultipart: function() { return /* binding */ analyzeImageMultipart; },\n/* harmony export */   checkUserPackage: function() { return /* binding */ checkUserPackage; },\n/* harmony export */   coachChat: function() { return /* binding */ coachChat; },\n/* harmony export */   createEmptyConversation: function() { return /* binding */ createEmptyConversation; },\n/* harmony export */   deleteAnalysisResult: function() { return /* binding */ deleteAnalysisResult; },\n/* harmony export */   deleteConversation: function() { return /* binding */ deleteConversation; },\n/* harmony export */   fetchAnalysisHistory: function() { return /* binding */ fetchAnalysisHistory; },\n/* harmony export */   fetchCoachChatPrompts: function() { return /* binding */ fetchCoachChatPrompts; },\n/* harmony export */   fetchConversation: function() { return /* binding */ fetchConversation; },\n/* harmony export */   fetchConversations: function() { return /* binding */ fetchConversations; },\n/* harmony export */   generateConversationTitle: function() { return /* binding */ generateConversationTitle; },\n/* harmony export */   getAnalysisById: function() { return /* binding */ getAnalysisById; },\n/* harmony export */   purchasePackage: function() { return /* binding */ purchasePackage; },\n/* harmony export */   sendFeedback: function() { return /* binding */ sendFeedback; },\n/* harmony export */   startCheckout: function() { return /* binding */ startCheckout; },\n/* harmony export */   updateAnalysisById: function() { return /* binding */ updateAnalysisById; },\n/* harmony export */   verifySession: function() { return /* binding */ verifySession; }\n/* harmony export */ });\n/* harmony import */ var _app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/app/utils/fetcher */ \"(app-pages-browser)/./src/app/utils/fetcher.ts\");\n// src/app/utils/api.ts\n\n// -------------------------------\n// Small helpers\n// -------------------------------\nasync function readJsonOrText(res) {\n    const text = await res.text();\n    try {\n        return {\n            ok: res.ok,\n            status: res.status,\n            data: JSON.parse(text)\n        };\n    } catch (e) {\n        return {\n            ok: res.ok,\n            status: res.status,\n            data: text\n        };\n    }\n}\nfunction ensureOk(r, what) {\n    if (!r.ok) {\n        const msg = typeof r.data === \"string\" ? r.data : JSON.stringify(r.data, null, 2);\n        throw new Error(\"\".concat(what, \" failed (\").concat(r.status, \") - \").concat(msg));\n    }\n    return r.data;\n}\n// -------------------------------\n/** Analysis history */ async function fetchAnalysisHistory() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    const url = \"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/analyze?page=\").concat(page, \"&limit=\").concat(limit, \"&ts=\").concat(Date.now());\n    const r = await (0,_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(url, {\n        method: \"GET\",\n        cache: \"no-store\"\n    });\n    if (!r.ok) throw new Error(\"Fetch analysis history failed\");\n    return r.data;\n}\nasync function deleteAnalysisResult(id) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/analyze/\").concat(id), {\n        method: \"DELETE\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        }\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Delete analysis result\");\n}\n// -------------------------------\n/** Stripe (unchanged) */ async function startCheckout(packageId) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/checkout/create-checkout-session\"), {\n        method: \"POST\",\n        credentials: \"include\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            packageId\n        })\n    });\n    const { ok, data } = await readJsonOrText(res);\n    if (!ok) throw new Error(typeof data === \"string\" ? data : (data === null || data === void 0 ? void 0 : data.error) || \"Failed to start checkout\");\n    if (!(data === null || data === void 0 ? void 0 : data.url)) throw new Error(\"No checkout URL returned\");\n    window.location.href = data.url;\n}\nasync function verifySession(sessionId) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/checkout/verify-session?session_id=\").concat(encodeURIComponent(sessionId)));\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Verify session\");\n}\nasync function purchasePackage(packageId) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/user/purchase\"), {\n        method: \"POST\",\n        credentials: \"include\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            packageId\n        })\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Purchase package\");\n}\nasync function checkUserPackage() {\n    const r = await (0,_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/user/check-package\"), {\n        method: \"GET\"\n    });\n    if (!r.ok) throw new Error(\"Check user package failed\");\n    return r.data;\n}\n// -------------------------------\n/** Coach chat + conversations */ async function coachChat(param) {\n    let { question, latestContentInfo, conversationId, title } = param;\n    try {\n        const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/coach-chat\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            credentials: \"include\",\n            body: JSON.stringify({\n                question,\n                latestContentInfo,\n                conversationId,\n                title\n            })\n        });\n        const parsed = await readJsonOrText(res);\n        if (res.status === 200) return {\n            status: 200,\n            data: parsed.data\n        };\n        if (res.status === 402) return {\n            status: 402,\n            data: parsed.data\n        };\n        if (res.status === 429) return {\n            status: 429,\n            data: parsed.data\n        };\n        return {\n            status: res.status,\n            data: parsed.data\n        };\n    } catch (e) {\n        return {\n            status: 0,\n            data: {\n                error: \"Network error\"\n            }\n        };\n    }\n}\nasync function fetchConversation(id) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/conversations/\").concat(id), {\n        method: \"GET\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        cache: \"no-store\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Fetch conversation\");\n}\nasync function deleteConversation(conversationId) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/conversations/\").concat(conversationId), {\n        method: \"DELETE\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Delete conversation\");\n}\nasync function createEmptyConversation() {\n    try {\n        const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/conversations\"), {\n            method: \"POST\",\n            credentials: \"include\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({})\n        });\n        const parsed = await readJsonOrText(res);\n        const data = ensureOk(parsed, \"Create conversation\");\n        var _data__id, _ref;\n        return (_ref = (_data__id = data._id) !== null && _data__id !== void 0 ? _data__id : data.id) !== null && _ref !== void 0 ? _ref : null;\n    } catch (error) {\n        console.error(\"Error creating new conversation:\", error);\n        return null;\n    }\n}\nasync function generateConversationTitle(conversationId, firstUserMessage) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/conversations/\").concat(conversationId, \"/generate-title\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            firstUserMessage\n        }),\n        cache: \"no-store\"\n    });\n    const parsed = await readJsonOrText(res);\n    const data = ensureOk(parsed, \"Generate title\");\n    return data.title || null;\n}\nasync function fetchConversations() {\n    const url = \"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/conversations?ts=\").concat(Date.now());\n    const r = await (0,_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(url, {\n        method: \"GET\",\n        cache: \"no-store\"\n    });\n    if (!r.ok) throw new Error(\"Fetch conversations failed\");\n    return r.data;\n}\n// -------------------------------\n/** Feedback */ async function sendFeedback(message) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/feedback\"), {\n        method: \"POST\",\n        credentials: \"include\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            message\n        })\n    });\n    const parsed = await readJsonOrText(res);\n    if (!parsed.ok) {\n        var _parsed_data;\n        throw new Error(typeof parsed.data === \"string\" ? parsed.data : ((_parsed_data = parsed.data) === null || _parsed_data === void 0 ? void 0 : _parsed_data.error) || \"Failed to send feedback (\".concat(parsed.status, \")\"));\n    }\n    return parsed.data;\n}\nfunction analyzeImageMultipart(opts) {\n    const { file, goal, linkBase, onProgress, captions = true } = opts;\n    const form = new FormData();\n    form.append(\"image\", file);\n    if (goal) form.append(\"goal\", goal);\n    if (linkBase) form.append(\"linkBase\", linkBase);\n    // Include browser timezone so backend returns local windows\n    try {\n        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        if (timezone) form.append(\"timezone\", timezone);\n    } catch (e) {}\n    const url = \"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/analyze\") + (captions === false ? \"?captions=false\" : \"\");\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", url, true);\n        xhr.withCredentials = true;\n        xhr.onreadystatechange = ()=>{\n            if (xhr.readyState !== 4) return;\n            if (xhr.status >= 200 && xhr.status < 300) {\n                try {\n                    const json = JSON.parse(xhr.responseText);\n                    resolve(json);\n                } catch (e) {\n                    reject(new Error(\"Invalid JSON from server.\"));\n                }\n            } else {\n                try {\n                    const err = JSON.parse(xhr.responseText);\n                    reject(new Error((err === null || err === void 0 ? void 0 : err.error) || \"Upload failed (\".concat(xhr.status, \")\")));\n                } catch (e) {\n                    reject(new Error(\"Upload failed (\".concat(xhr.status, \")\")));\n                }\n            }\n        };\n        if (xhr.upload && typeof onProgress === \"function\") {\n            xhr.upload.onprogress = (evt)=>{\n                if (!evt.lengthComputable) return;\n                onProgress(Math.round(evt.loaded / evt.total * 100));\n            };\n        }\n        xhr.onerror = ()=>reject(new Error(\"Network error\"));\n        xhr.send(form);\n    });\n}\nasync function getAnalysisById(id) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/analyze/\").concat(id), {\n        cache: \"no-store\"\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Fetch result by id\");\n}\nasync function updateAnalysisById(id, patch) {\n    const res = await fetch(\"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/analyze/\").concat(id), {\n        method: \"PATCH\",\n        credentials: \"include\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(patch)\n    });\n    const parsed = await readJsonOrText(res);\n    return ensureOk(parsed, \"Update analysis\");\n}\n// --- Quick Prompts API ---\nasync function fetchCoachChatPrompts() {\n    const url = \"\".concat(_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.BASE_URL, \"/api/coach-chat/prompts?ts=\").concat(Date.now());\n    const r = await (0,_app_utils_fetcher__WEBPACK_IMPORTED_MODULE_0__.fetchJson)(url, {\n        method: \"GET\",\n        cache: \"no-store\"\n    });\n    if (!r.ok) throw new Error(\"Fetch coach prompts failed\");\n    return r.data;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbHMvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHVCQUF1QjtBQUVtQztBQUUxRCxrQ0FBa0M7QUFDbEMsZ0JBQWdCO0FBQ2hCLGtDQUFrQztBQUNsQyxlQUFlRSxlQUFlQyxHQUFhO0lBQ3pDLE1BQU1DLE9BQU8sTUFBTUQsSUFBSUMsSUFBSTtJQUMzQixJQUFJO1FBQ0YsT0FBTztZQUFFQyxJQUFJRixJQUFJRSxFQUFFO1lBQUVDLFFBQVFILElBQUlHLE1BQU07WUFBRUMsTUFBTUMsS0FBS0MsS0FBSyxDQUFDTDtRQUFNO0lBQ2xFLEVBQUUsVUFBTTtRQUNOLE9BQU87WUFBRUMsSUFBSUYsSUFBSUUsRUFBRTtZQUFFQyxRQUFRSCxJQUFJRyxNQUFNO1lBQUVDLE1BQU1IO1FBQUs7SUFDdEQ7QUFDRjtBQUVBLFNBQVNNLFNBQ1BDLENBQWlELEVBQ2pEQyxJQUFZO0lBRVosSUFBSSxDQUFDRCxFQUFFTixFQUFFLEVBQUU7UUFDVCxNQUFNUSxNQUNKLE9BQU9GLEVBQUVKLElBQUksS0FBSyxXQUFXSSxFQUFFSixJQUFJLEdBQUdDLEtBQUtNLFNBQVMsQ0FBQ0gsRUFBRUosSUFBSSxFQUFFLE1BQU07UUFDckUsTUFBTSxJQUFJUSxNQUFNLEdBQW1CSixPQUFoQkMsTUFBSyxhQUEwQkMsT0FBZkYsRUFBRUwsTUFBTSxFQUFDLFFBQVUsT0FBSk87SUFDcEQ7SUFDQSxPQUFPRixFQUFFSixJQUFJO0FBQ2Y7QUFFQSxrQ0FBa0M7QUFDbEMscUJBQXFCLEdBQ2QsZUFBZVM7UUFBcUJDLE9BQUFBLGlFQUFPLEdBQUdDLFFBQUFBLGlFQUFRO0lBQzNELE1BQU1DLE1BQU0sR0FBZ0NGLE9BQTdCakIsd0RBQVFBLEVBQUMsc0JBQWtDa0IsT0FBZEQsTUFBSyxXQUFxQkcsT0FBWkYsT0FBTSxRQUFpQixPQUFYRSxLQUFLQyxHQUFHO0lBQzlFLE1BQU1WLElBQUksTUFBTVYsNkRBQVNB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LE9BQUh5QixLQUFNO1FBQ3ZERixPQUFPO0lBQ1Q7SUFDQSxNQUFNSyxTQUFTLE1BQU0xQixlQUFlQztJQUNwQyxPQUFPTyxTQUFvQmtCLFFBQVE7QUFDckM7QUFFTyxlQUFlbUUsbUJBQ3BCdEUsRUFBVSxFQUNWdUUsS0FBeUI7SUFFekIsTUFBTTdGLE1BQU0sTUFBTXVCLE1BQU0sR0FBMkJELE9BQXhCekIsd0RBQVFBLEVBQUMsaUJBQWtCLE9BQUh5QixLQUFNO1FBQ3ZESCxRQUFRO1FBQ1JTLGFBQWE7UUFDYkosU0FBUztZQUFFLGdCQUFnQjtRQUFtQjtRQUM5Q0ssTUFBTXhCLEtBQUtNLFNBQVMsQ0FBQ2tGO0lBQ3ZCO0lBQ0EsTUFBTXBFLFNBQVMsTUFBTTFCLGVBQWVDO0lBQ3BDLE9BQU9PLFNBQW9Ca0IsUUFBUTtBQUNyQztBQU9BLDRCQUE0QjtBQUNyQixlQUFlcUU7SUFDcEIsTUFBTTlFLE1BQU0sR0FBeUNDLE9BQXRDcEIsd0RBQVFBLEVBQUMsK0JBQXdDLE9BQVhvQixLQUFLQyxHQUFHO0lBQzdELE1BQU1WLElBQUksTUFBTVYsNkRBQVNBLENBQUNrQixLQUFLO1FBQUVHLFFBQVE7UUFBT0MsT0FBTztJQUFXO0lBQ2xFLElBQUksQ0FBQ1osRUFBRU4sRUFBRSxFQUFFLE1BQU0sSUFBSVUsTUFBTTtJQUMzQixPQUFPSixFQUFFSixJQUFJO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC91dGlscy9hcGkudHM/OTM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYXBwL3V0aWxzL2FwaS50c1xyXG5pbXBvcnQgdHlwZSB7IFJlc3VsdERvYyB9IGZyb20gXCJAL2FwcC90eXBlcy9hbmFseXNpc1wiO1xuaW1wb3J0IHsgQkFTRV9VUkwsIGZldGNoSnNvbiB9IGZyb20gXCJAL2FwcC91dGlscy9mZXRjaGVyXCI7XG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTbWFsbCBoZWxwZXJzXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEpzb25PclRleHQocmVzOiBSZXNwb25zZSkge1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBvazogcmVzLm9rLCBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IEpTT04ucGFyc2UodGV4dCkgfTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHsgb2s6IHJlcy5vaywgc3RhdHVzOiByZXMuc3RhdHVzLCBkYXRhOiB0ZXh0IH07XG4gIH1cbn1cblxyXG5mdW5jdGlvbiBlbnN1cmVPazxUID0gdW5rbm93bj4oXHJcbiAgcjogeyBvazogYm9vbGVhbjsgc3RhdHVzOiBudW1iZXI7IGRhdGE6IHVua25vd24gfSxcclxuICB3aGF0OiBzdHJpbmdcclxuKTogVCB7XHJcbiAgaWYgKCFyLm9rKSB7XHJcbiAgICBjb25zdCBtc2cgPVxyXG4gICAgICB0eXBlb2Ygci5kYXRhID09PSBcInN0cmluZ1wiID8gci5kYXRhIDogSlNPTi5zdHJpbmdpZnkoci5kYXRhLCBudWxsLCAyKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgJHt3aGF0fSBmYWlsZWQgKCR7ci5zdGF0dXN9KSAtICR7bXNnfWApO1xyXG4gIH1cclxuICByZXR1cm4gci5kYXRhIGFzIFQ7XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqIEFuYWx5c2lzIGhpc3RvcnkgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQW5hbHlzaXNIaXN0b3J5KHBhZ2UgPSAxLCBsaW1pdCA9IDEwKTogUHJvbWlzZTx7IHJlc3VsdHM6IFJlc3VsdERvY1tdOyB0b3RhbDogbnVtYmVyIH0+IHtcbiAgY29uc3QgdXJsID0gYCR7QkFTRV9VUkx9L2FwaS9hbmFseXplP3BhZ2U9JHtwYWdlfSZsaW1pdD0ke2xpbWl0fSZ0cz0ke0RhdGUubm93KCl9YDtcbiAgY29uc3QgciA9IGF3YWl0IGZldGNoSnNvbih1cmwsIHsgbWV0aG9kOiBcIkdFVFwiLCBjYWNoZTogXCJuby1zdG9yZVwiIH0pO1xuICBpZiAoIXIub2spIHRocm93IG5ldyBFcnJvcihcIkZldGNoIGFuYWx5c2lzIGhpc3RvcnkgZmFpbGVkXCIpO1xuICByZXR1cm4gci5kYXRhIGFzIGFueTtcbn1cblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQW5hbHlzaXNSZXN1bHQoaWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvYW5hbHl6ZS8ke2lkfWAsIHtcclxuICAgIG1ldGhvZDogXCJERUxFVEVcIixcclxuICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICB9KTtcclxuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIHJldHVybiBlbnN1cmVPazx7IG1lc3NhZ2U6IHN0cmluZyB9PihwYXJzZWQsIFwiRGVsZXRlIGFuYWx5c2lzIHJlc3VsdFwiKTtcclxufVxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKiogU3RyaXBlICh1bmNoYW5nZWQpICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydENoZWNrb3V0KHBhY2thZ2VJZDogc3RyaW5nKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvY2hlY2tvdXQvY3JlYXRlLWNoZWNrb3V0LXNlc3Npb25gLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGFja2FnZUlkIH0pLFxuICB9KTtcbiAgY29uc3QgeyBvaywgZGF0YSB9ID0gYXdhaXQgcmVhZEpzb25PclRleHQocmVzKTtcclxuICBpZiAoIW9rKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBkYXRhPy5lcnJvciB8fCBcIkZhaWxlZCB0byBzdGFydCBjaGVja291dFwiXHJcbiAgICApO1xyXG4gIGlmICghZGF0YT8udXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGVja291dCBVUkwgcmV0dXJuZWRcIik7XHJcbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkYXRhLnVybDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNlc3Npb24oc2Vzc2lvbklkOiBzdHJpbmcpIHtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcclxuICAgIGAke0JBU0VfVVJMfS9hcGkvY2hlY2tvdXQvdmVyaWZ5LXNlc3Npb24/c2Vzc2lvbl9pZD0ke2VuY29kZVVSSUNvbXBvbmVudChcclxuICAgICAgc2Vzc2lvbklkXHJcbiAgICApfWBcclxuICApO1xyXG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rPHsgc3RhdHVzOiBzdHJpbmc7IGVtYWlsPzogc3RyaW5nOyBwYWNrYWdlSWQ/OiBzdHJpbmcgfT4oXHJcbiAgICBwYXJzZWQsXHJcbiAgICBcIlZlcmlmeSBzZXNzaW9uXCJcclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQdXJjaGFzZVJlc3BvbnNlID0geyBtZXNzYWdlOiBzdHJpbmcgfTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXJjaGFzZVBhY2thZ2UocGFja2FnZUlkOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS91c2VyL3B1cmNoYXNlYCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHBhY2thZ2VJZCB9KSxcbiAgfSk7XG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XG4gIHJldHVybiBlbnN1cmVPazxQdXJjaGFzZVJlc3BvbnNlPihwYXJzZWQsIFwiUHVyY2hhc2UgcGFja2FnZVwiKTtcbn1cblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qKiBVc2VyL3BhY2thZ2UgKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VyUGFja2FnZVJlc3BvbnNlIHtcclxuICBoYXNBY2Nlc3M6IGJvb2xlYW47XHJcbiAgcGFja2FnZT86IHN0cmluZztcclxuICB1cGxvYWRzUmVtYWluaW5nPzogbnVtYmVyO1xyXG4gIGV4cGlyZXNBdD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrVXNlclBhY2thZ2UoKTogUHJvbWlzZTxVc2VyUGFja2FnZVJlc3BvbnNlPiB7XG4gIGNvbnN0IHIgPSBhd2FpdCBmZXRjaEpzb24oYCR7QkFTRV9VUkx9L2FwaS91c2VyL2NoZWNrLXBhY2thZ2VgLCB7IG1ldGhvZDogXCJHRVRcIiB9KTtcbiAgaWYgKCFyLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGVjayB1c2VyIHBhY2thZ2UgZmFpbGVkXCIpO1xuICByZXR1cm4gci5kYXRhIGFzIGFueTtcbn1cblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENoYXQgdHlwZXMgKGlubGluZSlcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXRNZXRhIHtcclxuICB1c2VkQ29udGV4dElkcz86IHN0cmluZ1tdO1xyXG4gIHJlcXVlc3RJZD86IHN0cmluZztcclxuICBsYXRlbmN5TXM/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdE1lc3NhZ2Uge1xyXG4gIHJvbGU6IFwidXNlclwiIHwgXCJhc3Npc3RhbnRcIjtcclxuICBjb250ZW50OiBzdHJpbmc7XHJcbiAgX2lkPzogc3RyaW5nO1xyXG4gIG1ldGE/OiBDaGF0TWV0YTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29udmVyc2F0aW9uIHtcclxuICBfaWQ6IHN0cmluZztcclxuICB0aXRsZT86IHN0cmluZztcclxuICBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXTtcclxuICB1cGRhdGVkQXQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uU3VtbWFyeSB7XHJcbiAgX2lkOiBzdHJpbmc7XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgdXBkYXRlZEF0Pzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvbiB7XHJcbiAgX2lkOiBzdHJpbmc7XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgbWVzc2FnZXM6IENoYXRNZXNzYWdlW107XHJcbiAgdXBkYXRlZEF0Pzogc3RyaW5nO1xyXG59XHJcblxyXG4vLyAyMDAgT0sgcGF5bG9hZFxyXG5leHBvcnQgaW50ZXJmYWNlIENvYWNoQ2hhdFJlc3BvbnNlIHtcclxuICBhaTogc3RyaW5nO1xyXG4gIGNvbnZlcnNhdGlvbjogQ2hhdENvbnZlcnNhdGlvbjtcclxuICB1c2VkQ29udGV4dElkcz86IHN0cmluZ1tdO1xyXG4gIHJlcXVlc3RJZD86IHN0cmluZztcclxuICBsYXRlbmN5TXM/OiBudW1iZXI7XHJcbiAgcXVvdGE/OiB7IHVzZWQ6IG51bWJlcjsgbGltaXQ6IG51bWJlciB9OyAvLyBvcHRpb25hbFxyXG59XHJcblxyXG4vLyBub24tMjAwIHBheWxvYWRzXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29hY2hDaGF0TGltaXREYXRhIHtcclxuICBlcnJvcjogc3RyaW5nO1xyXG4gIGFjdGlvbj86IFwidXBncmFkZVwiO1xyXG4gIHF1b3RhPzogeyB1c2VkOiBudW1iZXI7IGxpbWl0OiBudW1iZXIgfTtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIENvYWNoQ2hhdFJhdGVMaW1pdERhdGEge1xyXG4gIGVycm9yPzogc3RyaW5nO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBDb2FjaENoYXROZXR3b3JrRXJyb3Ige1xyXG4gIGVycm9yOiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBDb2FjaENoYXRHZW5lcmljRXJyb3Ige1xyXG4gIGVycm9yPzogc3RyaW5nO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIERpc2NyaW1pbmF0ZWQgdW5pb24gKG5vIGBhbnlgKVxyXG5leHBvcnQgdHlwZSBDb2FjaENoYXRSZXN1bHQgPVxyXG4gIHwgeyBzdGF0dXM6IDIwMDsgZGF0YTogQ29hY2hDaGF0UmVzcG9uc2UgfVxyXG4gIHwgeyBzdGF0dXM6IDQwMjsgZGF0YTogQ29hY2hDaGF0TGltaXREYXRhIH1cclxuICB8IHsgc3RhdHVzOiA0Mjk7IGRhdGE6IENvYWNoQ2hhdFJhdGVMaW1pdERhdGEgfVxyXG4gIHwgeyBzdGF0dXM6IDA7IGRhdGE6IENvYWNoQ2hhdE5ldHdvcmtFcnJvciB9XHJcbiAgfCB7IHN0YXR1czogbnVtYmVyOyBkYXRhOiBDb2FjaENoYXRHZW5lcmljRXJyb3IgfTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqIENvYWNoIGNoYXQgKyBjb252ZXJzYXRpb25zICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2FjaENoYXQoe1xuICBxdWVzdGlvbixcbiAgbGF0ZXN0Q29udGVudEluZm8sXG4gIGNvbnZlcnNhdGlvbklkLFxuICB0aXRsZSxcbn06IHtcbiAgcXVlc3Rpb246IHN0cmluZztcbiAgbGF0ZXN0Q29udGVudEluZm8/OiBzdHJpbmc7XG4gIGNvbnZlcnNhdGlvbklkPzogc3RyaW5nO1xuICB0aXRsZT86IHN0cmluZztcbn0pOiBQcm9taXNlPENvYWNoQ2hhdFJlc3VsdD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvY29hY2gtY2hhdGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHF1ZXN0aW9uLFxuICAgICAgICBsYXRlc3RDb250ZW50SW5mbyxcbiAgICAgICAgY29udmVyc2F0aW9uSWQsXG4gICAgICAgIHRpdGxlLFxuICAgICAgfSksXG4gICAgfSk7XG5cclxuICAgIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gMjAwKVxyXG4gICAgICByZXR1cm4geyBzdGF0dXM6IDIwMCwgZGF0YTogcGFyc2VkLmRhdGEgYXMgQ29hY2hDaGF0UmVzcG9uc2UgfTtcclxuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDIpXHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogNDAyLCBkYXRhOiBwYXJzZWQuZGF0YSBhcyBDb2FjaENoYXRMaW1pdERhdGEgfTtcclxuICAgIGlmIChyZXMuc3RhdHVzID09PSA0MjkpXHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogNDI5LCBkYXRhOiBwYXJzZWQuZGF0YSBhcyBDb2FjaENoYXRSYXRlTGltaXREYXRhIH07XHJcbiAgICByZXR1cm4geyBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGE6IHBhcnNlZC5kYXRhIGFzIENvYWNoQ2hhdEdlbmVyaWNFcnJvciB9O1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIHsgc3RhdHVzOiAwLCBkYXRhOiB7IGVycm9yOiBcIk5ldHdvcmsgZXJyb3JcIiB9IH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb252ZXJzYXRpb24oaWQ6IHN0cmluZyk6IFByb21pc2U8Q29udmVyc2F0aW9uPiB7XHJcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS9jb252ZXJzYXRpb25zLyR7aWR9YCwge1xyXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgY2FjaGU6IFwibm8tc3RvcmVcIixcclxuICB9KTtcclxuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIHJldHVybiBlbnN1cmVPazxDb252ZXJzYXRpb24+KHBhcnNlZCwgXCJGZXRjaCBjb252ZXJzYXRpb25cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uSWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvY29udmVyc2F0aW9ucy8ke2NvbnZlcnNhdGlvbklkfWAsIHtcclxuICAgIG1ldGhvZDogXCJERUxFVEVcIixcclxuICB9KTtcclxuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIHJldHVybiBlbnN1cmVPayhwYXJzZWQsIFwiRGVsZXRlIGNvbnZlcnNhdGlvblwiKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUVtcHR5Q29udmVyc2F0aW9uKFxuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS9jb252ZXJzYXRpb25zYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt9KSxcbiAgICB9KTtcbiAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gICAgY29uc3QgZGF0YSA9IGVuc3VyZU9rPHsgX2lkPzogc3RyaW5nOyBpZD86IHN0cmluZyB9PihcclxuICAgICAgcGFyc2VkLFxyXG4gICAgICBcIkNyZWF0ZSBjb252ZXJzYXRpb25cIlxyXG4gICAgKTtcclxuICAgIHJldHVybiBkYXRhLl9pZCA/PyBkYXRhLmlkID8/IG51bGw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBuZXcgY29udmVyc2F0aW9uOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbnZlcnNhdGlvblRpdGxlKFxyXG4gIGNvbnZlcnNhdGlvbklkOiBzdHJpbmcsXHJcbiAgZmlyc3RVc2VyTWVzc2FnZTogc3RyaW5nXHJcbikge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFxyXG4gICAgYCR7QkFTRV9VUkx9L2FwaS9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9L2dlbmVyYXRlLXRpdGxlYCxcclxuICAgIHtcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGZpcnN0VXNlck1lc3NhZ2UgfSksXHJcbiAgICAgIGNhY2hlOiBcIm5vLXN0b3JlXCIsXHJcbiAgICB9XHJcbiAgKTtcclxuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIGNvbnN0IGRhdGEgPSBlbnN1cmVPazx7IHRpdGxlOiBzdHJpbmcgfCBudWxsIH0+KHBhcnNlZCwgXCJHZW5lcmF0ZSB0aXRsZVwiKTtcclxuICByZXR1cm4gZGF0YS50aXRsZSB8fCBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb252ZXJzYXRpb25zKCk6IFByb21pc2U8Q29udmVyc2F0aW9uU3VtbWFyeVtdPiB7XG4gIGNvbnN0IHVybCA9IGAke0JBU0VfVVJMfS9hcGkvY29udmVyc2F0aW9ucz90cz0ke0RhdGUubm93KCl9YDtcbiAgY29uc3QgciA9IGF3YWl0IGZldGNoSnNvbih1cmwsIHsgbWV0aG9kOiBcIkdFVFwiLCBjYWNoZTogXCJuby1zdG9yZVwiIH0pO1xuICBpZiAoIXIub2spIHRocm93IG5ldyBFcnJvcihcIkZldGNoIGNvbnZlcnNhdGlvbnMgZmFpbGVkXCIpO1xuICByZXR1cm4gci5kYXRhIGFzIGFueTtcbn1cblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qKiBGZWVkYmFjayAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZEZlZWRiYWNrKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuIH0+IHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS9mZWVkYmFja2AsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlIH0pLFxuICB9KTtcblxyXG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgaWYgKCFwYXJzZWQub2spIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgdHlwZW9mIHBhcnNlZC5kYXRhID09PSBcInN0cmluZ1wiXHJcbiAgICAgICAgPyBwYXJzZWQuZGF0YVxyXG4gICAgICAgIDogcGFyc2VkLmRhdGE/LmVycm9yIHx8IGBGYWlsZWQgdG8gc2VuZCBmZWVkYmFjayAoJHtwYXJzZWQuc3RhdHVzfSlgXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gcGFyc2VkLmRhdGEgYXMgeyBzdWNjZXNzOiBib29sZWFuIH07XHJcbn1cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLyoqIEFuYWx5emUgKHVwbG9hZCArIGdldC91cGRhdGUpICovXHJcbmV4cG9ydCB0eXBlIEFuYWx5emVSZXNwb25zZSA9IHtcbiAgbWVzc2FnZT86IHN0cmluZztcclxuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XHJcbiAgaW5zaWdodHM6IFJlc3VsdERvYztcclxuICBkdXJhdGlvbnM/OiB7XHJcbiAgICB0b3RhbF9tczogbnVtYmVyO1xyXG4gICAgdmlzaW9uX21zOiBudW1iZXI7XHJcbiAgICBjYXB0aW9uc19tczogbnVtYmVyO1xyXG4gIH07XHJcbiAgZHVwbGljYXRlPzogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplSW1hZ2VNdWx0aXBhcnQob3B0czoge1xuICBmaWxlOiBGaWxlO1xuICBnb2FsPzogXCJzdWJzXCIgfCBcInBwdlwiIHwgXCJjdXN0b21zXCI7XG4gIGxpbmtCYXNlPzogc3RyaW5nO1xuICBjYXB0aW9ucz86IGJvb2xlYW47IC8vIGRlZmF1bHQgdHJ1ZVxuICBvblByb2dyZXNzPzogKHBjdDogbnVtYmVyKSA9PiB2b2lkO1xufSk6IFByb21pc2U8QW5hbHl6ZVJlc3BvbnNlPiB7XG4gIGNvbnN0IHsgZmlsZSwgZ29hbCwgbGlua0Jhc2UsIG9uUHJvZ3Jlc3MsIGNhcHRpb25zID0gdHJ1ZSB9ID0gb3B0cztcblxyXG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcclxuICBmb3JtLmFwcGVuZChcImltYWdlXCIsIGZpbGUpO1xyXG4gIGlmIChnb2FsKSBmb3JtLmFwcGVuZChcImdvYWxcIiwgZ29hbCk7XG4gIGlmIChsaW5rQmFzZSkgZm9ybS5hcHBlbmQoXCJsaW5rQmFzZVwiLCBsaW5rQmFzZSk7XG5cclxuICAvLyBJbmNsdWRlIGJyb3dzZXIgdGltZXpvbmUgc28gYmFja2VuZCByZXR1cm5zIGxvY2FsIHdpbmRvd3NcclxuICB0cnkge1xyXG4gICAgY29uc3QgdGltZXpvbmUgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XHJcbiAgICBpZiAodGltZXpvbmUpIGZvcm0uYXBwZW5kKFwidGltZXpvbmVcIiwgdGltZXpvbmUpO1xyXG4gIH0gY2F0Y2gge31cclxuXHJcbiAgY29uc3QgdXJsID1cclxuICAgIGAke0JBU0VfVVJMfS9hcGkvYW5hbHl6ZWAgKyAoY2FwdGlvbnMgPT09IGZhbHNlID8gYD9jYXB0aW9ucz1mYWxzZWAgOiBcIlwiKTtcclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbihcIlBPU1RcIiwgdXJsLCB0cnVlKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxyXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XHJcbiAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpIGFzIEFuYWx5emVSZXNwb25zZTtcclxuICAgICAgICByZXNvbHZlKGpzb24pO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgSlNPTiBmcm9tIHNlcnZlci5cIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZXJyID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyPy5lcnJvciB8fCBgVXBsb2FkIGZhaWxlZCAoJHt4aHIuc3RhdHVzfSlgKSk7XHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVcGxvYWQgZmFpbGVkICgke3hoci5zdGF0dXN9KWApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHhoci51cGxvYWQgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgaWYgKCFldnQubGVuZ3RoQ29tcHV0YWJsZSkgcmV0dXJuO1xyXG4gICAgICAgIG9uUHJvZ3Jlc3MoTWF0aC5yb3VuZCgoZXZ0LmxvYWRlZCAvIGV2dC50b3RhbCkgKiAxMDApKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB4aHIub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoXCJOZXR3b3JrIGVycm9yXCIpKTtcclxuICAgIHhoci5zZW5kKGZvcm0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QW5hbHlzaXNCeUlkKGlkOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9VUkx9L2FwaS9hbmFseXplLyR7aWR9YCwge1xuICAgIGNhY2hlOiBcIm5vLXN0b3JlXCIsXG4gIH0pO1xuICBjb25zdCBwYXJzZWQgPSBhd2FpdCByZWFkSnNvbk9yVGV4dChyZXMpO1xyXG4gIHJldHVybiBlbnN1cmVPazxSZXN1bHREb2M+KHBhcnNlZCwgXCJGZXRjaCByZXN1bHQgYnkgaWRcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVBbmFseXNpc0J5SWQoXG4gIGlkOiBzdHJpbmcsXG4gIHBhdGNoOiBQYXJ0aWFsPFJlc3VsdERvYz5cbik6IFByb21pc2U8UmVzdWx0RG9jPiB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0JBU0VfVVJMfS9hcGkvYW5hbHl6ZS8ke2lkfWAsIHtcbiAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXG4gICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhdGNoKSxcbiAgfSk7XG4gIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHJlYWRKc29uT3JUZXh0KHJlcyk7XHJcbiAgcmV0dXJuIGVuc3VyZU9rPFJlc3VsdERvYz4ocGFyc2VkLCBcIlVwZGF0ZSBhbmFseXNpc1wiKTtcclxufVxyXG4vLyAtLS0gUXVpY2sgUHJvbXB0cyB0eXBlcyAtLS1cclxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0UHJvbXB0c1Jlc3BvbnNlIHtcclxuICBwcm9tcHRzOiBzdHJpbmdbXTtcclxuICBtZXRhOiB7IHBsYW46IHN0cmluZzsgbmljaGU6IHN0cmluZzsgdHo6IHN0cmluZyB9O1xyXG59XHJcblxyXG4vLyAtLS0gUXVpY2sgUHJvbXB0cyBBUEkgLS0tXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaENvYWNoQ2hhdFByb21wdHMoKTogUHJvbWlzZTxTdWdnZXN0UHJvbXB0c1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHVybCA9IGAke0JBU0VfVVJMfS9hcGkvY29hY2gtY2hhdC9wcm9tcHRzP3RzPSR7RGF0ZS5ub3coKX1gO1xuICBjb25zdCByID0gYXdhaXQgZmV0Y2hKc29uKHVybCwgeyBtZXRob2Q6IFwiR0VUXCIsIGNhY2hlOiBcIm5vLXN0b3JlXCIgfSk7XG4gIGlmICghci5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmV0Y2ggY29hY2ggcHJvbXB0cyBmYWlsZWRcIik7XG4gIHJldHVybiByLmRhdGEgYXMgYW55O1xufVxuIl0sIm5hbWVzIjpbIkJBU0VfVVJMIiwiZmV0Y2hKc29uIiwicmVhZEpzb25PclRleHQiLCJyZXMiLCJ0ZXh0Iiwib2siLCJzdGF0dXMiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZW5zdXJlT2siLCJyIiwid2hhdCIsIm1zZyIsInN0cmluZ2lmeSIsIkVycm9yIiwiZmV0Y2hBbmFseXNpc0hpc3RvcnkiLCJwYWdlIiwibGltaXQiLCJ1cmwiLCJEYXRlIiwibm93IiwibWV0aG9kIiwiY2FjaGUiLCJkZWxldGVBbmFseXNpc1Jlc3VsdCIsImlkIiwiZmV0Y2giLCJoZWFkZXJzIiwicGFyc2VkIiwic3RhcnRDaGVja291dCIsInBhY2thZ2VJZCIsImNyZWRlbnRpYWxzIiwiYm9keSIsImVycm9yIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwidmVyaWZ5U2Vzc2lvbiIsInNlc3Npb25JZCIsImVuY29kZVVSSUNvbXBvbmVudCIsInB1cmNoYXNlUGFja2FnZSIsImNoZWNrVXNlclBhY2thZ2UiLCJjb2FjaENoYXQiLCJxdWVzdGlvbiIsImxhdGVzdENvbnRlbnRJbmZvIiwiY29udmVyc2F0aW9uSWQiLCJ0aXRsZSIsImZldGNoQ29udmVyc2F0aW9uIiwiZGVsZXRlQ29udmVyc2F0aW9uIiwiY3JlYXRlRW1wdHlDb252ZXJzYXRpb24iLCJfaWQiLCJjb25zb2xlIiwiZ2VuZXJhdGVDb252ZXJzYXRpb25UaXRsZSIsImZpcnN0VXNlck1lc3NhZ2UiLCJmZXRjaENvbnZlcnNhdGlvbnMiLCJzZW5kRmVlZGJhY2siLCJtZXNzYWdlIiwiYW5hbHl6ZUltYWdlTXVsdGlwYXJ0Iiwib3B0cyIsImZpbGUiLCJnb2FsIiwibGlua0Jhc2UiLCJvblByb2dyZXNzIiwiY2FwdGlvbnMiLCJmb3JtIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJ0aW1lem9uZSIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsInJlc29sdmVkT3B0aW9ucyIsInRpbWVab25lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJ3aXRoQ3JlZGVudGlhbHMiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwianNvbiIsInJlc3BvbnNlVGV4dCIsImVyciIsInVwbG9hZCIsIm9ucHJvZ3Jlc3MiLCJldnQiLCJsZW5ndGhDb21wdXRhYmxlIiwiTWF0aCIsInJvdW5kIiwibG9hZGVkIiwidG90YWwiLCJvbmVycm9yIiwic2VuZCIsImdldEFuYWx5c2lzQnlJZCIsInVwZGF0ZUFuYWx5c2lzQnlJZCIsInBhdGNoIiwiZmV0Y2hDb2FjaENoYXRQcm9tcHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/utils/api.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/utils/fetcher.ts":
/*!**********************************!*\
  !*** ./src/app/utils/fetcher.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_URL: function() { return /* binding */ BASE_URL; },\n/* harmony export */   fetchJson: function() { return /* binding */ fetchJson; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// src/app/utils/fetcher.ts\nconst BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:5001\";\nasync function fetchJson(input) {\n    let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const res = await fetch(input, {\n        ...init,\n        credentials: \"include\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...init.headers || {}\n        }\n    });\n    const text = await res.text();\n    let data = null;\n    try {\n        data = text ? JSON.parse(text) : null;\n    } catch (e) {\n        data = text;\n    }\n    if (res.status === 401) {\n        // optional: client-side redirect can be handled by caller\n        const err = new Error(\"Unauthorized\");\n        err.status = 401;\n        err.data = data;\n        throw err;\n    }\n    return {\n        ok: res.ok,\n        status: res.status,\n        data\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbHMvZmV0Y2hlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwyQkFBMkI7QUFDcEIsTUFBTUEsV0FBV0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSSx3QkFBd0I7QUFFNUUsZUFBZUMsVUFBVUMsS0FBYTtRQUFFQyxPQUFBQSxpRUFBb0IsQ0FBQztJQUNsRSxNQUFNQyxNQUFNLE1BQU1DLE1BQU1ILE9BQU87UUFDN0IsR0FBR0MsSUFBSTtRQUNQRyxhQUFhO1FBQ2JDLFNBQVM7WUFDUCxnQkFBZ0I7WUFDaEIsR0FBSUosS0FBS0ksT0FBTyxJQUFJLENBQUMsQ0FBQztRQUN4QjtJQUNGO0lBQ0EsTUFBTUMsT0FBTyxNQUFNSixJQUFJSSxJQUFJO0lBQzNCLElBQUlDLE9BQVk7SUFDaEIsSUFBSTtRQUFFQSxPQUFPRCxPQUFPRSxLQUFLQyxLQUFLLENBQUNILFFBQVE7SUFBTSxFQUFFLFVBQU07UUFBRUMsT0FBT0Q7SUFBTTtJQUNwRSxJQUFJSixJQUFJUSxNQUFNLEtBQUssS0FBSztRQUN0QiwwREFBMEQ7UUFDMUQsTUFBTUMsTUFBVyxJQUFJQyxNQUFNO1FBQzNCRCxJQUFJRCxNQUFNLEdBQUc7UUFDYkMsSUFBSUosSUFBSSxHQUFHQTtRQUNYLE1BQU1JO0lBQ1I7SUFDQSxPQUFPO1FBQUVFLElBQUlYLElBQUlXLEVBQUU7UUFBRUgsUUFBUVIsSUFBSVEsTUFBTTtRQUFFSDtJQUFLO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvdXRpbHMvZmV0Y2hlci50cz9lOTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9hcHAvdXRpbHMvZmV0Y2hlci50c1xuZXhwb3J0IGNvbnN0IEJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uKGlucHV0OiBzdHJpbmcsIGluaXQ6IFJlcXVlc3RJbml0ID0ge30pIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goaW5wdXQsIHtcbiAgICAuLi5pbml0LFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLihpbml0LmhlYWRlcnMgfHwge30pLFxuICAgIH0sXG4gIH0pO1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgbGV0IGRhdGE6IGFueSA9IG51bGw7XG4gIHRyeSB7IGRhdGEgPSB0ZXh0ID8gSlNPTi5wYXJzZSh0ZXh0KSA6IG51bGw7IH0gY2F0Y2ggeyBkYXRhID0gdGV4dDsgfVxuICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgLy8gb3B0aW9uYWw6IGNsaWVudC1zaWRlIHJlZGlyZWN0IGNhbiBiZSBoYW5kbGVkIGJ5IGNhbGxlclxuICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKFwiVW5hdXRob3JpemVkXCIpO1xuICAgIGVyci5zdGF0dXMgPSA0MDE7XG4gICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4geyBvazogcmVzLm9rLCBzdGF0dXM6IHJlcy5zdGF0dXMsIGRhdGEgfTtcbn1cblxuIl0sIm5hbWVzIjpbIkJBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJmZXRjaEpzb24iLCJpbnB1dCIsImluaXQiLCJyZXMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsInRleHQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwic3RhdHVzIiwiZXJyIiwiRXJyb3IiLCJvayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/utils/fetcher.ts\n"));

/***/ })

});