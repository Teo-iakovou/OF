<<<<<<< HEAD
import type { TSESTree } from '@typescript-eslint/types';
import type { DefinitionType } from './DefinitionType';
declare abstract class DefinitionBase<Type extends DefinitionType, Node extends TSESTree.Node, Parent extends TSESTree.Node | null, Name extends TSESTree.Node> {
=======
import { TSESTree } from '@typescript-eslint/types';
import { DefinitionType } from './DefinitionType';
declare abstract class DefinitionBase<TType extends DefinitionType, TNode extends TSESTree.Node, TParent extends TSESTree.Node | null, TName extends TSESTree.Node = TSESTree.BindingName> {
>>>>>>> packages
    /**
     * A unique ID for this instance - primarily used to help debugging and testing
     */
    readonly $id: number;
<<<<<<< HEAD
    readonly type: Type;
=======
    /**
     * The type of the definition
     * @public
     */
    readonly type: TType;
>>>>>>> packages
    /**
     * The `Identifier` node of this definition
     * @public
     */
<<<<<<< HEAD
    readonly name: Name;
=======
    readonly name: TName;
>>>>>>> packages
    /**
     * The enclosing node of the name.
     * @public
     */
<<<<<<< HEAD
    readonly node: Node;
=======
    readonly node: TNode;
>>>>>>> packages
    /**
     * the enclosing statement node of the identifier.
     * @public
     */
<<<<<<< HEAD
    readonly parent: Parent;
    constructor(type: Type, name: Name, node: Node, parent: Parent);
=======
    readonly parent: TParent;
    constructor(type: TType, name: TName, node: TNode, parent: TParent);
>>>>>>> packages
    /**
     * `true` if the variable is valid in a type context, false otherwise
     */
    abstract readonly isTypeDefinition: boolean;
    /**
     * `true` if the variable is valid in a value context, false otherwise
     */
    abstract readonly isVariableDefinition: boolean;
}
export { DefinitionBase };
//# sourceMappingURL=DefinitionBase.d.ts.map