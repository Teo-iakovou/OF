"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
<<<<<<< HEAD
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
=======
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
>>>>>>> packages
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
<<<<<<< HEAD
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
const assertionFunctionUtils_1 = require("../util/assertionFunctionUtils");
// Truthiness utilities
// #region
const valueIsPseudoBigInt = (value) => {
    return typeof value === 'object';
};
const getValueOfLiteralType = (type) => {
    if (valueIsPseudoBigInt(type.value)) {
        return pseudoBigIntToBigInt(type.value);
    }
    return type.value;
};
const isTruthyLiteral = (type) => tsutils.isTrueLiteralType(type) ||
    (type.isLiteral() && !!getValueOfLiteralType(type));
const isPossiblyFalsy = (type) => tsutils
    .unionTypeParts(type)
    // Intersections like `string & {}` can also be possibly falsy,
    // requiring us to look into the intersection.
    .flatMap(type => tsutils.intersectionTypeParts(type))
=======
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const ts = __importStar(require("typescript"));
const tsutils_1 = require("tsutils");
const util_1 = require("../util");
// Truthiness utilities
// #region
const isTruthyLiteral = (type) => (0, tsutils_1.isBooleanLiteralType)(type, true) || ((0, tsutils_1.isLiteralType)(type) && !!type.value);
const isPossiblyFalsy = (type) => (0, tsutils_1.unionTypeParts)(type)
>>>>>>> packages
    // PossiblyFalsy flag includes literal values, so exclude ones that
    // are definitely truthy
    .filter(t => !isTruthyLiteral(t))
    .some(type => (0, util_1.isTypeFlagSet)(type, ts.TypeFlags.PossiblyFalsy));
<<<<<<< HEAD
const isPossiblyTruthy = (type) => tsutils
    .unionTypeParts(type)
    .map(type => tsutils.intersectionTypeParts(type))
    .some(intersectionParts => 
// It is possible to define intersections that are always falsy,
// like `"" & { __brand: string }`.
intersectionParts.every(type => !tsutils.isFalsyType(type)));
// Nullish utilities
const nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;
const isNullishType = (type) => (0, util_1.isTypeFlagSet)(type, nullishFlag);
const isPossiblyNullish = (type) => tsutils.unionTypeParts(type).some(isNullishType);
const isAlwaysNullish = (type) => tsutils.unionTypeParts(type).every(isNullishType);
function toStaticValue(type) {
    // type.isLiteral() only covers numbers/bigints and strings, hence the rest of the branches.
    if (tsutils.isBooleanLiteralType(type)) {
        return { value: tsutils.isTrueLiteralType(type) };
    }
    if (type.flags === ts.TypeFlags.Undefined) {
        return { value: undefined };
    }
    if (type.flags === ts.TypeFlags.Null) {
        return { value: null };
    }
    if (type.isLiteral()) {
        return { value: getValueOfLiteralType(type) };
    }
    return undefined;
}
function pseudoBigIntToBigInt(value) {
    return BigInt((value.negative ? '-' : '') + value.base10Value);
}
const BOOL_OPERATORS = new Set([
    '<',
    '>',
    '<=',
    '>=',
    '==',
    '===',
    '!=',
    '!==',
]);
function isBoolOperator(operator) {
    return BOOL_OPERATORS.has(operator);
}
function booleanComparison(left, operator, right) {
    switch (operator) {
        case '!=':
            // eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality
            return left != right;
        case '!==':
            return left !== right;
        case '<':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left < right;
        case '<=':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left <= right;
        case '==':
            // eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality
            return left == right;
        case '===':
            return left === right;
        case '>':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left > right;
        case '>=':
            // @ts-expect-error: we don't care if the comparison seems unintentional.
            return left >= right;
    }
}
=======
const isPossiblyTruthy = (type) => (0, tsutils_1.unionTypeParts)(type).some(type => !(0, tsutils_1.isFalsyType)(type));
// Nullish utilities
const nullishFlag = ts.TypeFlags.Undefined | ts.TypeFlags.Null;
const isNullishType = (type) => (0, util_1.isTypeFlagSet)(type, nullishFlag);
const isPossiblyNullish = (type) => (0, tsutils_1.unionTypeParts)(type).some(isNullishType);
const isAlwaysNullish = (type) => (0, tsutils_1.unionTypeParts)(type).every(isNullishType);
// isLiteralType only covers numbers and strings, this is a more exhaustive check.
const isLiteral = (type) => (0, tsutils_1.isBooleanLiteralType)(type, true) ||
    (0, tsutils_1.isBooleanLiteralType)(type, false) ||
    type.flags === ts.TypeFlags.Undefined ||
    type.flags === ts.TypeFlags.Null ||
    type.flags === ts.TypeFlags.Void ||
    (0, tsutils_1.isLiteralType)(type);
>>>>>>> packages
exports.default = (0, util_1.createRule)({
    name: 'no-unnecessary-condition',
    meta: {
        type: 'suggestion',
        docs: {
<<<<<<< HEAD
            description: 'Disallow conditionals where the type is always truthy or always falsy',
            recommended: 'strict',
            requiresTypeChecking: true,
        },
        fixable: 'code',
        messages: {
            alwaysFalsy: 'Unnecessary conditional, value is always falsy.',
            alwaysFalsyFunc: 'This callback should return a conditional, but return is always falsy.',
            alwaysNullish: 'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.',
            alwaysTruthy: 'Unnecessary conditional, value is always truthy.',
            alwaysTruthyFunc: 'This callback should return a conditional, but return is always truthy.',
            comparisonBetweenLiteralTypes: 'Unnecessary conditional, comparison is always {{trueOrFalse}}, since `{{left}} {{operator}} {{right}}` is {{trueOrFalse}}.',
            never: 'Unnecessary conditional, value is `never`.',
            neverNullish: 'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.',
            neverOptionalChain: 'Unnecessary optional chain on a non-nullish value.',
            noOverlapBooleanExpression: 'Unnecessary conditional, the types have no overlap.',
            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',
            typeGuardAlreadyIsType: 'Unnecessary conditional, expression already has the type being checked by the {{typeGuardOrAssertionFunction}}.',
        },
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                properties: {
                    allowConstantLoopConditions: {
                        type: 'boolean',
                        description: 'Whether to ignore constant loop conditions, such as `while (true)`.',
                    },
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        type: 'boolean',
                        description: 'Whether to not error when running with a tsconfig that has strictNullChecks turned.',
                    },
                    checkTypePredicates: {
                        type: 'boolean',
                        description: 'Whether to check the asserted argument of a type predicate function for unnecessary conditions',
                    },
                },
            },
        ],
=======
            description: 'Prevents conditionals where the type is always truthy or always falsy',
            category: 'Best Practices',
            recommended: false,
            requiresTypeChecking: true,
        },
        schema: [
            {
                type: 'object',
                properties: {
                    allowConstantLoopConditions: {
                        type: 'boolean',
                    },
                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {
                        type: 'boolean',
                    },
                },
                additionalProperties: false,
            },
        ],
        fixable: 'code',
        messages: {
            alwaysTruthy: 'Unnecessary conditional, value is always truthy.',
            alwaysFalsy: 'Unnecessary conditional, value is always falsy.',
            alwaysTruthyFunc: 'This callback should return a conditional, but return is always truthy.',
            alwaysFalsyFunc: 'This callback should return a conditional, but return is always falsy.',
            neverNullish: 'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.',
            alwaysNullish: 'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.',
            literalBooleanExpression: 'Unnecessary conditional, both sides of the expression are literal values.',
            noOverlapBooleanExpression: 'Unnecessary conditional, the types have no overlap.',
            never: 'Unnecessary conditional, value is `never`.',
            neverOptionalChain: 'Unnecessary optional chain on a non-nullish value.',
            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',
        },
>>>>>>> packages
    },
    defaultOptions: [
        {
            allowConstantLoopConditions: false,
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,
<<<<<<< HEAD
            checkTypePredicates: false,
        },
    ],
    create(context, [{ allowConstantLoopConditions, allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, checkTypePredicates, },]) {
        const services = (0, util_1.getParserServices)(context);
        const checker = services.program.getTypeChecker();
        const compilerOptions = services.program.getCompilerOptions();
        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');
        const isNoUncheckedIndexedAccess = tsutils.isCompilerOptionEnabled(compilerOptions, 'noUncheckedIndexedAccess');
=======
        },
    ],
    create(context, [{ allowConstantLoopConditions, allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, },]) {
        const service = (0, util_1.getParserServices)(context);
        const checker = service.program.getTypeChecker();
        const sourceCode = context.getSourceCode();
        const compilerOptions = service.program.getCompilerOptions();
        const isStrictNullChecks = (0, tsutils_1.isStrictCompilerOptionEnabled)(compilerOptions, 'strictNullChecks');
>>>>>>> packages
        if (!isStrictNullChecks &&
            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {
            context.report({
                loc: {
<<<<<<< HEAD
                    start: { column: 0, line: 0 },
                    end: { column: 0, line: 0 },
=======
                    start: { line: 0, column: 0 },
                    end: { line: 0, column: 0 },
>>>>>>> packages
                },
                messageId: 'noStrictNullCheck',
            });
        }
<<<<<<< HEAD
        function nodeIsArrayType(node) {
            const nodeType = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            return tsutils
                .unionTypeParts(nodeType)
                .some(part => checker.isArrayType(part));
        }
        function nodeIsTupleType(node) {
            const nodeType = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            return tsutils
                .unionTypeParts(nodeType)
                .some(part => checker.isTupleType(part));
=======
        function getNodeType(node) {
            const tsNode = service.esTreeNodeToTSNodeMap.get(node);
            return (0, util_1.getConstrainedTypeAtLocation)(checker, tsNode);
        }
        function nodeIsArrayType(node) {
            const nodeType = getNodeType(node);
            return checker.isArrayType(nodeType);
        }
        function nodeIsTupleType(node) {
            const nodeType = getNodeType(node);
            return checker.isTupleType(nodeType);
>>>>>>> packages
        }
        function isArrayIndexExpression(node) {
            return (
            // Is an index signature
<<<<<<< HEAD
            node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
=======
            node.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression &&
>>>>>>> packages
                node.computed &&
                // ...into an array type
                (nodeIsArrayType(node.object) ||
                    // ... or a tuple type
                    (nodeIsTupleType(node.object) &&
                        // Exception: literal index into a tuple - will have a sound type
<<<<<<< HEAD
                        node.property.type !== utils_1.AST_NODE_TYPES.Literal)));
        }
        // Conditional is always necessary if it involves:
        //    `any` or `unknown` or a naked type variable
        function isConditionalAlwaysNecessary(type) {
            return tsutils
                .unionTypeParts(type)
                .some(part => (0, util_1.isTypeAnyType)(part) ||
                (0, util_1.isTypeUnknownType)(part) ||
                (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeVariable));
        }
        function isNullableMemberExpression(node) {
            const objectType = services.getTypeAtLocation(node.object);
            if (node.computed) {
                const propertyType = services.getTypeAtLocation(node.property);
                return isNullablePropertyType(objectType, propertyType);
            }
            const property = node.property;
            // Get the actual property name, to account for private properties (this.#prop).
            const propertyName = context.sourceCode.getText(property);
            const propertyType = objectType
                .getProperties()
                .find(prop => prop.name === propertyName);
            if (propertyType &&
                tsutils.isSymbolFlagSet(propertyType, ts.SymbolFlags.Optional)) {
                return true;
            }
            return false;
=======
                        node.property.type !== experimental_utils_1.AST_NODE_TYPES.Literal)));
>>>>>>> packages
        }
        /**
         * Checks if a conditional node is necessary:
         * if the type of the node is always true or always false, it's not necessary.
         */
<<<<<<< HEAD
        function checkNode(expression, isUnaryNotArgument = false, node = expression) {
            // Check if the node is Unary Negation expression and handle it
            if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression &&
                expression.operator === '!') {
                return checkNode(expression.argument, !isUnaryNotArgument, node);
=======
        function checkNode(node, isUnaryNotArgument = false) {
            // Check if the node is Unary Negation expression and handle it
            if (node.type === experimental_utils_1.AST_NODE_TYPES.UnaryExpression &&
                node.operator === '!') {
                return checkNode(node.argument, true);
>>>>>>> packages
            }
            // Since typescript array index signature types don't represent the
            //  possibility of out-of-bounds access, if we're indexing into an array
            //  just skip the check, to avoid false positives
<<<<<<< HEAD
            if (isArrayIndexExpression(expression)) {
=======
            if (isArrayIndexExpression(node)) {
>>>>>>> packages
                return;
            }
            // When checking logical expressions, only check the right side
            //  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals
            //
            // Unless the node is nullish coalescing, as it's common to use patterns like `nullBool ?? true` to to strict
            //  boolean checks if we inspect the right here, it'll usually be a constant condition on purpose.
            // In this case it's better to inspect the type of the expression as a whole.
<<<<<<< HEAD
            if (expression.type === utils_1.AST_NODE_TYPES.LogicalExpression &&
                expression.operator !== '??') {
                return checkNode(expression.right);
            }
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, expression);
            if (isConditionalAlwaysNecessary(type)) {
=======
            if (node.type === experimental_utils_1.AST_NODE_TYPES.LogicalExpression &&
                node.operator !== '??') {
                return checkNode(node.right);
            }
            const type = getNodeType(node);
            // Conditional is always necessary if it involves:
            //    `any` or `unknown` or a naked type parameter
            if ((0, tsutils_1.unionTypeParts)(type).some(part => (0, util_1.isTypeAnyType)(part) ||
                (0, util_1.isTypeUnknownType)(part) ||
                (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeParameter))) {
>>>>>>> packages
                return;
            }
            let messageId = null;
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {
                messageId = 'never';
            }
            else if (!isPossiblyTruthy(type)) {
                messageId = !isUnaryNotArgument ? 'alwaysFalsy' : 'alwaysTruthy';
            }
            else if (!isPossiblyFalsy(type)) {
                messageId = !isUnaryNotArgument ? 'alwaysTruthy' : 'alwaysFalsy';
            }
            if (messageId) {
                context.report({ node, messageId });
            }
        }
        function checkNodeForNullish(node) {
<<<<<<< HEAD
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            // Conditional is always necessary if it involves `any`, `unknown` or a naked type parameter
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any |
                ts.TypeFlags.Unknown |
                ts.TypeFlags.TypeParameter |
                ts.TypeFlags.TypeVariable)) {
=======
            const type = getNodeType(node);
            // Conditional is always necessary if it involves `any` or `unknown`
            if ((0, util_1.isTypeAnyType)(type) || (0, util_1.isTypeUnknownType)(type)) {
>>>>>>> packages
                return;
            }
            let messageId = null;
            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {
                messageId = 'never';
            }
<<<<<<< HEAD
            else if (!isPossiblyNullish(type) &&
                !(node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                    isNullableMemberExpression(node))) {
=======
            else if (!isPossiblyNullish(type)) {
>>>>>>> packages
                // Since typescript array index signature types don't represent the
                //  possibility of out-of-bounds access, if we're indexing into an array
                //  just skip the check, to avoid false positives
                if (!isArrayIndexExpression(node) &&
<<<<<<< HEAD
                    !(node.type === utils_1.AST_NODE_TYPES.ChainExpression &&
                        node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression &&
=======
                    !(node.type === experimental_utils_1.AST_NODE_TYPES.ChainExpression &&
                        node.expression.type !== experimental_utils_1.AST_NODE_TYPES.TSNonNullExpression &&
>>>>>>> packages
                        optionChainContainsOptionArrayIndex(node.expression))) {
                    messageId = 'neverNullish';
                }
            }
            else if (isAlwaysNullish(type)) {
                messageId = 'alwaysNullish';
            }
            if (messageId) {
                context.report({ node, messageId });
            }
        }
        /**
         * Checks that a binary expression is necessarily conditional, reports otherwise.
         * If both sides of the binary expression are literal values, it's not a necessary condition.
         *
         * NOTE: It's also unnecessary if the types that don't overlap at all
         *    but that case is handled by the Typescript compiler itself.
         *    Known exceptions:
<<<<<<< HEAD
         *      - https://github.com/microsoft/TypeScript/issues/32627
         *      - https://github.com/microsoft/TypeScript/issues/37160 (handled)
         */
        function checkIfBoolExpressionIsNecessaryConditional(node, left, right, operator) {
            const leftType = (0, util_1.getConstrainedTypeAtLocation)(services, left);
            const rightType = (0, util_1.getConstrainedTypeAtLocation)(services, right);
            const leftStaticValue = toStaticValue(leftType);
            const rightStaticValue = toStaticValue(rightType);
            if (leftStaticValue != null && rightStaticValue != null) {
                const conditionIsTrue = booleanComparison(leftStaticValue.value, operator, rightStaticValue.value);
                context.report({
                    node,
                    messageId: 'comparisonBetweenLiteralTypes',
                    data: {
                        left: checker.typeToString(leftType),
                        operator,
                        right: checker.typeToString(rightType),
                        trueOrFalse: conditionIsTrue ? 'true' : 'false',
                    },
                });
=======
         *      * https://github.com/microsoft/TypeScript/issues/32627
         *      * https://github.com/microsoft/TypeScript/issues/37160 (handled)
         */
        const BOOL_OPERATORS = new Set([
            '<',
            '>',
            '<=',
            '>=',
            '==',
            '===',
            '!=',
            '!==',
        ]);
        function checkIfBinaryExpressionIsNecessaryConditional(node) {
            if (!BOOL_OPERATORS.has(node.operator)) {
                return;
            }
            const leftType = getNodeType(node.left);
            const rightType = getNodeType(node.right);
            if (isLiteral(leftType) && isLiteral(rightType)) {
                context.report({ node, messageId: 'literalBooleanExpression' });
>>>>>>> packages
                return;
            }
            // Workaround for https://github.com/microsoft/TypeScript/issues/37160
            if (isStrictNullChecks) {
                const UNDEFINED = ts.TypeFlags.Undefined;
                const NULL = ts.TypeFlags.Null;
<<<<<<< HEAD
                const VOID = ts.TypeFlags.Void;
=======
>>>>>>> packages
                const isComparable = (type, flag) => {
                    // Allow comparison to `any`, `unknown` or a naked type parameter.
                    flag |=
                        ts.TypeFlags.Any |
                            ts.TypeFlags.Unknown |
<<<<<<< HEAD
                            ts.TypeFlags.TypeParameter |
                            ts.TypeFlags.TypeVariable;
                    // Allow loose comparison to nullish values.
                    if (operator === '==' || operator === '!=') {
                        flag |= NULL | UNDEFINED | VOID;
=======
                            ts.TypeFlags.TypeParameter;
                    // Allow loose comparison to nullish values.
                    if (node.operator === '==' || node.operator === '!=') {
                        flag |= NULL | UNDEFINED;
>>>>>>> packages
                    }
                    return (0, util_1.isTypeFlagSet)(type, flag);
                };
                if ((leftType.flags === UNDEFINED &&
<<<<<<< HEAD
                    !isComparable(rightType, UNDEFINED | VOID)) ||
                    (rightType.flags === UNDEFINED &&
                        !isComparable(leftType, UNDEFINED | VOID)) ||
=======
                    !isComparable(rightType, UNDEFINED)) ||
                    (rightType.flags === UNDEFINED &&
                        !isComparable(leftType, UNDEFINED)) ||
>>>>>>> packages
                    (leftType.flags === NULL && !isComparable(rightType, NULL)) ||
                    (rightType.flags === NULL && !isComparable(leftType, NULL))) {
                    context.report({ node, messageId: 'noOverlapBooleanExpression' });
                    return;
                }
            }
        }
        /**
         * Checks that a logical expression contains a boolean, reports otherwise.
         */
        function checkLogicalExpressionForUnnecessaryConditionals(node) {
            if (node.operator === '??') {
                checkNodeForNullish(node.left);
                return;
            }
            // Only checks the left side, since the right side might not be "conditional" at all.
            // The right side will be checked if the LogicalExpression is used in a conditional context
            checkNode(node.left);
        }
        /**
         * Checks that a testable expression of a loop is necessarily conditional, reports otherwise.
         */
        function checkIfLoopIsNecessaryConditional(node) {
<<<<<<< HEAD
            if (node.test == null) {
=======
            if (node.test === null) {
>>>>>>> packages
                // e.g. `for(;;)`
                return;
            }
            /**
             * Allow:
             *   while (true) {}
             *   for (;true;) {}
             *   do {} while (true)
             */
            if (allowConstantLoopConditions &&
<<<<<<< HEAD
                tsutils.isTrueLiteralType((0, util_1.getConstrainedTypeAtLocation)(services, node.test))) {
=======
                (0, tsutils_1.isBooleanLiteralType)(getNodeType(node.test), true)) {
>>>>>>> packages
                return;
            }
            checkNode(node.test);
        }
<<<<<<< HEAD
        function checkCallExpression(node) {
            if (checkTypePredicates) {
                const truthinessAssertedArgument = (0, assertionFunctionUtils_1.findTruthinessAssertedArgument)(services, node);
                if (truthinessAssertedArgument != null) {
                    checkNode(truthinessAssertedArgument);
                }
                const typeGuardAssertedArgument = (0, assertionFunctionUtils_1.findTypeGuardAssertedArgument)(services, node);
                if (typeGuardAssertedArgument != null) {
                    const typeOfArgument = (0, util_1.getConstrainedTypeAtLocation)(services, typeGuardAssertedArgument.argument);
                    if (typeOfArgument === typeGuardAssertedArgument.type) {
                        context.report({
                            node: typeGuardAssertedArgument.argument,
                            messageId: 'typeGuardAlreadyIsType',
                            data: {
                                typeGuardOrAssertionFunction: typeGuardAssertedArgument.asserts
                                    ? 'assertion function'
                                    : 'type guard',
                            },
                        });
                    }
                }
            }
            // If this is something like arr.filter(x => /*condition*/), check `condition`
            if ((0, util_1.isArrayMethodCallWithPredicate)(context, services, node) &&
                node.arguments.length) {
                const callback = node.arguments[0];
                // Inline defined functions
                if (callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                    callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) {
                    // Two special cases, where we can directly check the node that's returned:
                    // () => something
                    if (callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {
=======
        const ARRAY_PREDICATE_FUNCTIONS = new Set([
            'filter',
            'find',
            'some',
            'every',
        ]);
        function isArrayPredicateFunction(node) {
            const { callee } = node;
            return (
            // looks like `something.filter` or `something.find`
            callee.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression &&
                callee.property.type === experimental_utils_1.AST_NODE_TYPES.Identifier &&
                ARRAY_PREDICATE_FUNCTIONS.has(callee.property.name) &&
                // and the left-hand side is an array, according to the types
                (nodeIsArrayType(callee.object) || nodeIsTupleType(callee.object)));
        }
        function checkCallExpression(node) {
            // If this is something like arr.filter(x => /*condition*/), check `condition`
            if (isArrayPredicateFunction(node) && node.arguments.length) {
                const callback = node.arguments[0];
                // Inline defined functions
                if ((callback.type === experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||
                    callback.type === experimental_utils_1.AST_NODE_TYPES.FunctionExpression) &&
                    callback.body) {
                    // Two special cases, where we can directly check the node that's returned:
                    // () => something
                    if (callback.body.type !== experimental_utils_1.AST_NODE_TYPES.BlockStatement) {
>>>>>>> packages
                        return checkNode(callback.body);
                    }
                    // () => { return something; }
                    const callbackBody = callback.body.body;
                    if (callbackBody.length === 1 &&
<<<<<<< HEAD
                        callbackBody[0].type === utils_1.AST_NODE_TYPES.ReturnStatement &&
=======
                        callbackBody[0].type === experimental_utils_1.AST_NODE_TYPES.ReturnStatement &&
>>>>>>> packages
                        callbackBody[0].argument) {
                        return checkNode(callbackBody[0].argument);
                    }
                    // Potential enhancement: could use code-path analysis to check
                    //   any function with a single return statement
                    // (Value to complexity ratio is dubious however)
                }
                // Otherwise just do type analysis on the function as a whole.
<<<<<<< HEAD
                const returnTypes = tsutils
                    .getCallSignaturesOfType((0, util_1.getConstrainedTypeAtLocation)(services, callback))
                    .map(sig => sig.getReturnType());
                if (returnTypes.length === 0) {
                    // Not a callable function, e.g. `any`
                    return;
                }
                let hasFalsyReturnTypes = false;
                let hasTruthyReturnTypes = false;
                for (const type of returnTypes) {
                    const { constraintType } = (0, util_1.getConstraintInfo)(checker, type);
                    // Predicate is always necessary if it involves `any` or `unknown`
                    if (!constraintType ||
                        (0, util_1.isTypeAnyType)(constraintType) ||
                        (0, util_1.isTypeUnknownType)(constraintType)) {
                        return;
                    }
                    if (isPossiblyFalsy(constraintType)) {
                        hasFalsyReturnTypes = true;
                    }
                    if (isPossiblyTruthy(constraintType)) {
                        hasTruthyReturnTypes = true;
                    }
                    // bail early if both a possibly-truthy and a possibly-falsy have been detected
                    if (hasFalsyReturnTypes && hasTruthyReturnTypes) {
                        return;
                    }
                }
                if (!hasFalsyReturnTypes) {
=======
                const returnTypes = (0, tsutils_1.getCallSignaturesOfType)(getNodeType(callback)).map(sig => sig.getReturnType());
                /* istanbul ignore if */ if (returnTypes.length === 0) {
                    // Not a callable function
                    return;
                }
                // Predicate is always necessary if it involves `any` or `unknown`
                if (returnTypes.some(t => (0, util_1.isTypeAnyType)(t) || (0, util_1.isTypeUnknownType)(t))) {
                    return;
                }
                if (!returnTypes.some(isPossiblyFalsy)) {
>>>>>>> packages
                    return context.report({
                        node: callback,
                        messageId: 'alwaysTruthyFunc',
                    });
                }
<<<<<<< HEAD
                if (!hasTruthyReturnTypes) {
=======
                if (!returnTypes.some(isPossiblyTruthy)) {
>>>>>>> packages
                    return context.report({
                        node: callback,
                        messageId: 'alwaysFalsyFunc',
                    });
                }
            }
        }
        // Recursively searches an optional chain for an array index expression
        //  Has to search the entire chain, because an array index will "infect" the rest of the types
        //  Example:
        //  ```
        //  [{x: {y: "z"} }][n] // type is {x: {y: "z"}}
        //    ?.x // type is {y: "z"}
        //    ?.y // This access is considered "unnecessary" according to the types
        //  ```
        function optionChainContainsOptionArrayIndex(node) {
<<<<<<< HEAD
            const lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (node.optional && isArrayIndexExpression(lhsNode)) {
                return true;
            }
            if (lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression ||
                lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {
=======
            const lhsNode = node.type === experimental_utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (node.optional && isArrayIndexExpression(lhsNode)) {
                return true;
            }
            if (lhsNode.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression ||
                lhsNode.type === experimental_utils_1.AST_NODE_TYPES.CallExpression) {
>>>>>>> packages
                return optionChainContainsOptionArrayIndex(lhsNode);
            }
            return false;
        }
        function isNullablePropertyType(objType, propertyType) {
            if (propertyType.isUnion()) {
                return propertyType.types.some(type => isNullablePropertyType(objType, type));
            }
            if (propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {
                const propType = (0, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());
                if (propType) {
<<<<<<< HEAD
                    return (0, util_1.isNullableType)(propType);
                }
            }
            const typeName = (0, util_1.getTypeName)(checker, propertyType);
            return checker
                .getIndexInfosOfType(objType)
                .some(info => (0, util_1.getTypeName)(checker, info.keyType) === typeName);
=======
                    return (0, util_1.isNullableType)(propType, { allowUndefined: true });
                }
            }
            const typeName = (0, util_1.getTypeName)(checker, propertyType);
            return !!((typeName === 'string' &&
                checker.getIndexInfoOfType(objType, ts.IndexKind.String)) ||
                (typeName === 'number' &&
                    checker.getIndexInfoOfType(objType, ts.IndexKind.Number)));
>>>>>>> packages
        }
        // Checks whether a member expression is nullable or not regardless of it's previous node.
        //  Example:
        //  ```
        //  // 'bar' is nullable if 'foo' is null.
        //  // but this function checks regardless of 'foo' type, so returns 'true'.
        //  declare const foo: { bar : { baz: string } } | null
        //  foo?.bar;
        //  ```
<<<<<<< HEAD
        function isMemberExpressionNullableOriginFromObject(node) {
            const prevType = (0, util_1.getConstrainedTypeAtLocation)(services, node.object);
=======
        function isNullableOriginFromPrev(node) {
            const prevType = getNodeType(node.object);
>>>>>>> packages
            const property = node.property;
            if (prevType.isUnion() && (0, util_1.isIdentifier)(property)) {
                const isOwnNullable = prevType.types.some(type => {
                    if (node.computed) {
<<<<<<< HEAD
                        const propertyType = (0, util_1.getConstrainedTypeAtLocation)(services, node.property);
                        return isNullablePropertyType(type, propertyType);
                    }
                    const propType = (0, util_1.getTypeOfPropertyOfName)(checker, type, property.name);
                    if (propType) {
                        return (0, util_1.isNullableType)(propType);
                    }
                    const indexInfo = checker.getIndexInfosOfType(type);
                    return indexInfo.some(info => {
                        const isStringTypeName = (0, util_1.getTypeName)(checker, info.keyType) === 'string';
                        return (isStringTypeName &&
                            (isNoUncheckedIndexedAccess || (0, util_1.isNullableType)(info.type)));
                    });
                });
                return !isOwnNullable && (0, util_1.isNullableType)(prevType);
            }
            return false;
        }
        function isCallExpressionNullableOriginFromCallee(node) {
            const prevType = (0, util_1.getConstrainedTypeAtLocation)(services, node.callee);
            if (prevType.isUnion()) {
                const isOwnNullable = prevType.types.some(type => {
                    const signatures = type.getCallSignatures();
                    return signatures.some(sig => (0, util_1.isNullableType)(sig.getReturnType()));
                });
                return !isOwnNullable && (0, util_1.isNullableType)(prevType);
=======
                        const propertyType = getNodeType(node.property);
                        return isNullablePropertyType(type, propertyType);
                    }
                    const propType = (0, util_1.getTypeOfPropertyOfName)(checker, type, property.name);
                    return propType && (0, util_1.isNullableType)(propType, { allowUndefined: true });
                });
                return (!isOwnNullable && (0, util_1.isNullableType)(prevType, { allowUndefined: true }));
>>>>>>> packages
            }
            return false;
        }
        function isOptionableExpression(node) {
<<<<<<< HEAD
            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);
            const isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression
                ? !isMemberExpressionNullableOriginFromObject(node)
                : node.type === utils_1.AST_NODE_TYPES.CallExpression
                    ? !isCallExpressionNullableOriginFromCallee(node)
                    : true;
            return (isConditionalAlwaysNecessary(type) ||
                (isOwnNullable && (0, util_1.isNullableType)(type)));
=======
            const type = getNodeType(node);
            const isOwnNullable = node.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression
                ? !isNullableOriginFromPrev(node)
                : true;
            return ((0, util_1.isTypeAnyType)(type) ||
                (0, util_1.isTypeUnknownType)(type) ||
                ((0, util_1.isNullableType)(type, { allowUndefined: true }) && isOwnNullable));
>>>>>>> packages
        }
        function checkOptionalChain(node, beforeOperator, fix) {
            // We only care if this step in the chain is optional. If just descend
            // from an optional chain, then that's fine.
            if (!node.optional) {
                return;
            }
            // Since typescript array index signature types don't represent the
            //  possibility of out-of-bounds access, if we're indexing into an array
            //  just skip the check, to avoid false positives
            if (optionChainContainsOptionArrayIndex(node)) {
                return;
            }
<<<<<<< HEAD
            const nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (isOptionableExpression(nodeToCheck)) {
                return;
            }
            const questionDotOperator = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(beforeOperator, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '?.'), util_1.NullThrowsReasons.MissingToken('operator', node.type));
            context.report({
                loc: questionDotOperator.loc,
                node,
=======
            const nodeToCheck = node.type === experimental_utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;
            if (isOptionableExpression(nodeToCheck)) {
                return;
            }
            const questionDotOperator = (0, util_1.nullThrows)(sourceCode.getTokenAfter(beforeOperator, token => token.type === experimental_utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '?.'), util_1.NullThrowsReasons.MissingToken('operator', node.type));
            context.report({
                node,
                loc: questionDotOperator.loc,
>>>>>>> packages
                messageId: 'neverOptionalChain',
                fix(fixer) {
                    return fixer.replaceText(questionDotOperator, fix);
                },
            });
        }
        function checkOptionalMemberExpression(node) {
            checkOptionalChain(node, node.object, node.computed ? '' : '.');
        }
        function checkOptionalCallExpression(node) {
            checkOptionalChain(node, node.callee, '');
        }
<<<<<<< HEAD
        function checkAssignmentExpression(node) {
            // Similar to checkLogicalExpressionForUnnecessaryConditionals, since
            // a ||= b is equivalent to a || (a = b)
            if (['&&=', '||='].includes(node.operator)) {
                checkNode(node.left);
            }
            else if (node.operator === '??=') {
                checkNodeForNullish(node.left);
            }
        }
        return {
            AssignmentExpression: checkAssignmentExpression,
            BinaryExpression(node) {
                const { operator } = node;
                if (isBoolOperator(operator)) {
                    checkIfBoolExpressionIsNecessaryConditional(node, node.left, node.right, operator);
                }
            },
            CallExpression: checkCallExpression,
            'CallExpression[optional = true]': checkOptionalCallExpression,
=======
        return {
            BinaryExpression: checkIfBinaryExpressionIsNecessaryConditional,
            CallExpression: checkCallExpression,
>>>>>>> packages
            ConditionalExpression: (node) => checkNode(node.test),
            DoWhileStatement: checkIfLoopIsNecessaryConditional,
            ForStatement: checkIfLoopIsNecessaryConditional,
            IfStatement: (node) => checkNode(node.test),
            LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,
<<<<<<< HEAD
            'MemberExpression[optional = true]': checkOptionalMemberExpression,
            SwitchCase({ parent, test }) {
                // only check `case ...:`, not `default:`
                if (test) {
                    checkIfBoolExpressionIsNecessaryConditional(test, parent.discriminant, test, '===');
                }
            },
            WhileStatement: checkIfLoopIsNecessaryConditional,
=======
            WhileStatement: checkIfLoopIsNecessaryConditional,
            'MemberExpression[optional = true]': checkOptionalMemberExpression,
            'CallExpression[optional = true]': checkOptionalCallExpression,
>>>>>>> packages
        };
    },
});
//# sourceMappingURL=no-unnecessary-condition.js.map