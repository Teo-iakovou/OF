"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
<<<<<<< HEAD
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
=======
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
>>>>>>> packages
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
<<<<<<< HEAD
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const tsutils = __importStar(require("ts-api-utils"));
const ts = __importStar(require("typescript"));
const util_1 = require("../util");
/**
 * Static methods on these globals are either not `this`-aware or supported being
 * called without `this`.
 *
 * - `Promise` is not in the list because it supports subclassing by using `this`
 * - `Array` is in the list because although it supports subclassing, the `this`
 *   value defaults to `Array` when unbound
 *
 * This is now a language-design invariant: static methods are never `this`-aware
 * because TC39 wants to make `array.map(Class.method)` work!
 */
const SUPPORTED_GLOBALS = [
    'Number',
    'Object',
    'String', // eslint-disable-line @typescript-eslint/internal/prefer-ast-types-enum
=======
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const tsutils = __importStar(require("tsutils"));
const ts = __importStar(require("typescript"));
const util = __importStar(require("../util"));
/**
 * The following is a list of exceptions to the rule
 * Generated via the following script.
 * This is statically defined to save making purposely invalid calls every lint run
 * ```
SUPPORTED_GLOBALS.flatMap(namespace => {
  const object = window[namespace];
    return Object.getOwnPropertyNames(object)
      .filter(
        name =>
          !name.startsWith('_') &&
          typeof object[name] === 'function',
      )
      .map(name => {
        try {
          const x = object[name];
          x();
        } catch (e) {
          if (e.message.includes("called on non-object")) {
            return `${namespace}.${name}`;
          }
        }
      });
}).filter(Boolean);
   * ```
 */
const nativelyNotBoundMembers = new Set([
    'Promise.all',
    'Promise.race',
    'Promise.resolve',
    'Promise.reject',
    'Promise.allSettled',
    'Object.defineProperties',
    'Object.defineProperty',
    'Reflect.defineProperty',
    'Reflect.deleteProperty',
    'Reflect.get',
    'Reflect.getOwnPropertyDescriptor',
    'Reflect.getPrototypeOf',
    'Reflect.has',
    'Reflect.isExtensible',
    'Reflect.ownKeys',
    'Reflect.preventExtensions',
    'Reflect.set',
    'Reflect.setPrototypeOf',
]);
const SUPPORTED_GLOBALS = [
    'Number',
    'Object',
    'String',
>>>>>>> packages
    'RegExp',
    'Symbol',
    'Array',
    'Proxy',
    'Date',
<<<<<<< HEAD
=======
    'Infinity',
>>>>>>> packages
    'Atomics',
    'Reflect',
    'console',
    'Math',
    'JSON',
    'Intl',
];
<<<<<<< HEAD
const nativelyBoundMembers = new Set(SUPPORTED_GLOBALS.flatMap(namespace => {
=======
const nativelyBoundMembers = SUPPORTED_GLOBALS.map(namespace => {
>>>>>>> packages
    if (!(namespace in global)) {
        // node.js might not have namespaces like Intl depending on compilation options
        // https://nodejs.org/api/intl.html#intl_options_for_building_node_js
        return [];
    }
    const object = global[namespace];
    return Object.getOwnPropertyNames(object)
        .filter(name => !name.startsWith('_') &&
        typeof object[name] === 'function')
        .map(name => `${namespace}.${name}`);
<<<<<<< HEAD
}));
const SUPPORTED_GLOBAL_TYPES = [
    'NumberConstructor',
    'ObjectConstructor',
    'StringConstructor',
    'SymbolConstructor',
    'ArrayConstructor',
    'Array',
    'ProxyConstructor',
    'Console',
    'DateConstructor',
    'Atomics',
    'Math',
    'JSON',
];
=======
})
    .reduce((arr, names) => arr.concat(names), [])
    .filter(name => !nativelyNotBoundMembers.has(name));
>>>>>>> packages
const isNotImported = (symbol, currentSourceFile) => {
    const { valueDeclaration } = symbol;
    if (!valueDeclaration) {
        // working around https://github.com/microsoft/TypeScript/issues/31294
        return false;
    }
    return (!!currentSourceFile &&
        currentSourceFile !== valueDeclaration.getSourceFile());
};
<<<<<<< HEAD
const BASE_MESSAGE = 'Avoid referencing unbound methods which may cause unintentional scoping of `this`.';
exports.default = (0, util_1.createRule)({
    name: 'unbound-method',
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce unbound methods are called with their expected scope',
            recommended: 'recommended',
=======
const getNodeName = (node) => node.type === experimental_utils_1.AST_NODE_TYPES.Identifier ? node.name : null;
const getMemberFullName = (node) => `${getNodeName(node.object)}.${getNodeName(node.property)}`;
const BASE_MESSAGE = 'Avoid referencing unbound methods which may cause unintentional scoping of `this`.';
exports.default = util.createRule({
    name: 'unbound-method',
    meta: {
        docs: {
            category: 'Best Practices',
            description: 'Enforces unbound methods are called with their expected scope',
            recommended: 'error',
>>>>>>> packages
            requiresTypeChecking: true,
        },
        messages: {
            unbound: BASE_MESSAGE,
<<<<<<< HEAD
            unboundWithoutThisAnnotation: `${BASE_MESSAGE}\nIf your function does not access \`this\`, you can annotate it with \`this: void\`, or consider using an arrow function instead.`,
=======
            unboundWithoutThisAnnotation: BASE_MESSAGE +
                '\n' +
                'If your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.',
>>>>>>> packages
        },
        schema: [
            {
                type: 'object',
<<<<<<< HEAD
                additionalProperties: false,
                properties: {
                    ignoreStatic: {
                        type: 'boolean',
                        description: 'Whether to skip checking whether `static` methods are correctly bound.',
                    },
                },
            },
        ],
=======
                properties: {
                    ignoreStatic: {
                        type: 'boolean',
                    },
                },
                additionalProperties: false,
            },
        ],
        type: 'problem',
>>>>>>> packages
    },
    defaultOptions: [
        {
            ignoreStatic: false,
        },
    ],
    create(context, [{ ignoreStatic }]) {
<<<<<<< HEAD
        const services = (0, util_1.getParserServices)(context);
        const currentSourceFile = services.program.getSourceFile(context.filename);
        function checkIfMethodAndReport(node, symbol) {
            if (!symbol) {
                return false;
            }
            const { dangerous, firstParamIsThis } = checkIfMethod(symbol, ignoreStatic);
            if (dangerous) {
                context.report({
                    node,
                    messageId: firstParamIsThis === false
                        ? 'unboundWithoutThisAnnotation'
                        : 'unbound',
                });
                return true;
            }
            return false;
        }
        function isNativelyBound(object, property) {
            // We can't rely entirely on the type-level checks made at the end of this
            // function, because sometimes type declarations don't come from the
            // default library, but come from, for example, "@types/node". And we can't
            // tell if a method is unbound just by looking at its signature declared in
            // the interface.
            //
            // See related discussion https://github.com/typescript-eslint/typescript-eslint/pull/8952#discussion_r1576543310
            if (object.type === utils_1.AST_NODE_TYPES.Identifier &&
                property.type === utils_1.AST_NODE_TYPES.Identifier) {
                const objectSymbol = services.getSymbolAtLocation(object);
                const notImported = objectSymbol != null &&
                    isNotImported(objectSymbol, currentSourceFile);
                if (notImported &&
                    nativelyBoundMembers.has(`${object.name}.${property.name}`)) {
                    return true;
                }
            }
            // if `${object.name}.${property.name}` doesn't match any of
            // the nativelyBoundMembers, then we fallback to type-level checks
            return ((0, util_1.isBuiltinSymbolLike)(services.program, services.getTypeAtLocation(object), SUPPORTED_GLOBAL_TYPES) &&
                (0, util_1.isSymbolFromDefaultLibrary)(services.program, services.getTypeAtLocation(property).getSymbol()));
        }
        return {
            MemberExpression(node) {
                if (isSafeUse(node) || isNativelyBound(node.object, node.property)) {
                    return;
                }
                checkIfMethodAndReport(node, services.getSymbolAtLocation(node));
            },
            ObjectPattern(node) {
                if (isNodeInsideTypeDeclaration(node)) {
                    return;
                }
                let initNode = null;
                if (node.parent.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {
                    initNode = node.parent.init;
                }
                else if (node.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||
                    node.parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {
                    initNode = node.parent.right;
                }
                for (const property of node.properties) {
                    if (property.type !== utils_1.AST_NODE_TYPES.Property ||
                        property.key.type !== utils_1.AST_NODE_TYPES.Identifier) {
                        continue;
                    }
                    if (initNode) {
                        if (!isNativelyBound(initNode, property.key)) {
                            const reported = checkIfMethodAndReport(property.key, services
                                .getTypeAtLocation(initNode)
                                .getProperty(property.key.name));
                            if (reported) {
                                continue;
                            }
                            // In assignment patterns, we should also check the type of
                            // Foo's nativelyBound method because initNode might be used as
                            // default value:
                            //   function ({ nativelyBound }: Foo = NativeObject) {}
                        }
                        else if (node.parent.type !== utils_1.AST_NODE_TYPES.AssignmentPattern) {
                            continue;
                        }
                    }
                    for (const intersectionPart of tsutils
                        .unionTypeParts(services.getTypeAtLocation(node))
                        .flatMap(unionPart => tsutils.intersectionTypeParts(unionPart))) {
                        const reported = checkIfMethodAndReport(property.key, intersectionPart.getProperty(property.key.name));
                        if (reported) {
                            break;
                        }
                    }
=======
        const parserServices = util.getParserServices(context);
        const checker = parserServices.program.getTypeChecker();
        const currentSourceFile = parserServices.program.getSourceFile(context.getFilename());
        function checkMethodAndReport(node, symbol) {
            if (!symbol) {
                return;
            }
            const { dangerous, firstParamIsThis } = checkMethod(symbol, ignoreStatic);
            if (dangerous) {
                context.report({
                    messageId: firstParamIsThis === false
                        ? 'unboundWithoutThisAnnotation'
                        : 'unbound',
                    node,
                });
            }
        }
        return {
            MemberExpression(node) {
                if (isSafeUse(node)) {
                    return;
                }
                const objectSymbol = checker.getSymbolAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.object));
                if (objectSymbol &&
                    nativelyBoundMembers.includes(getMemberFullName(node)) &&
                    isNotImported(objectSymbol, currentSourceFile)) {
                    return;
                }
                const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);
                checkMethodAndReport(node, checker.getSymbolAtLocation(originalNode));
            },
            'VariableDeclarator, AssignmentExpression'(node) {
                const [idNode, initNode] = node.type === experimental_utils_1.AST_NODE_TYPES.VariableDeclarator
                    ? [node.id, node.init]
                    : [node.left, node.right];
                if (initNode && idNode.type === experimental_utils_1.AST_NODE_TYPES.ObjectPattern) {
                    const tsNode = parserServices.esTreeNodeToTSNodeMap.get(initNode);
                    const rightSymbol = checker.getSymbolAtLocation(tsNode);
                    const initTypes = checker.getTypeAtLocation(tsNode);
                    const notImported = rightSymbol && isNotImported(rightSymbol, currentSourceFile);
                    idNode.properties.forEach(property => {
                        if (property.type === experimental_utils_1.AST_NODE_TYPES.Property &&
                            property.key.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
                            if (notImported &&
                                util.isIdentifier(initNode) &&
                                nativelyBoundMembers.includes(`${initNode.name}.${property.key.name}`)) {
                                return;
                            }
                            checkMethodAndReport(node, initTypes.getProperty(property.key.name));
                        }
                    });
>>>>>>> packages
                }
            },
        };
    },
});
<<<<<<< HEAD
function isNodeInsideTypeDeclaration(node) {
    let parent = node;
    while ((parent = parent.parent)) {
        if ((parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration && parent.declare) ||
            parent.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
            parent.type === utils_1.AST_NODE_TYPES.TSDeclareFunction ||
            parent.type === utils_1.AST_NODE_TYPES.TSFunctionType ||
            parent.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration ||
            parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration ||
            (parent.type === utils_1.AST_NODE_TYPES.VariableDeclaration && parent.declare)) {
            return true;
        }
    }
    return false;
}
function checkIfMethod(symbol, ignoreStatic) {
=======
function checkMethod(symbol, ignoreStatic) {
    var _a, _b;
>>>>>>> packages
    const { valueDeclaration } = symbol;
    if (!valueDeclaration) {
        // working around https://github.com/microsoft/TypeScript/issues/31294
        return { dangerous: false };
    }
    switch (valueDeclaration.kind) {
        case ts.SyntaxKind.PropertyDeclaration:
            return {
<<<<<<< HEAD
                dangerous: valueDeclaration.initializer?.kind ===
                    ts.SyntaxKind.FunctionExpression,
            };
        case ts.SyntaxKind.PropertyAssignment: {
            const assignee = valueDeclaration.initializer;
            if (assignee.kind !== ts.SyntaxKind.FunctionExpression) {
                return {
                    dangerous: false,
                };
            }
            return checkMethod(assignee, ignoreStatic);
        }
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.MethodSignature: {
            return checkMethod(valueDeclaration, ignoreStatic);
=======
                dangerous: ((_a = valueDeclaration.initializer) === null || _a === void 0 ? void 0 : _a.kind) ===
                    ts.SyntaxKind.FunctionExpression,
            };
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.MethodSignature: {
            const decl = valueDeclaration;
            const firstParam = decl.parameters[0];
            const firstParamIsThis = (firstParam === null || firstParam === void 0 ? void 0 : firstParam.name.kind) === ts.SyntaxKind.Identifier &&
                (firstParam === null || firstParam === void 0 ? void 0 : firstParam.name.escapedText) === 'this';
            const thisArgIsVoid = firstParamIsThis &&
                ((_b = firstParam === null || firstParam === void 0 ? void 0 : firstParam.type) === null || _b === void 0 ? void 0 : _b.kind) === ts.SyntaxKind.VoidKeyword;
            return {
                dangerous: !thisArgIsVoid &&
                    !(ignoreStatic &&
                        tsutils.hasModifier(valueDeclaration.modifiers, ts.SyntaxKind.StaticKeyword)),
                firstParamIsThis,
            };
>>>>>>> packages
        }
    }
    return { dangerous: false };
}
<<<<<<< HEAD
function checkMethod(valueDeclaration, ignoreStatic) {
    const firstParam = valueDeclaration.parameters.at(0);
    const firstParamIsThis = firstParam?.name.kind === ts.SyntaxKind.Identifier &&
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        firstParam.name.escapedText === 'this';
    const thisArgIsVoid = firstParamIsThis && firstParam.type?.kind === ts.SyntaxKind.VoidKeyword;
    return {
        dangerous: !thisArgIsVoid &&
            !(ignoreStatic &&
                tsutils.includesModifier((0, util_1.getModifiers)(valueDeclaration), ts.SyntaxKind.StaticKeyword)),
        firstParamIsThis,
    };
}
function isSafeUse(node) {
    const parent = node.parent;
    switch (parent?.type) {
        case utils_1.AST_NODE_TYPES.IfStatement:
        case utils_1.AST_NODE_TYPES.ForStatement:
        case utils_1.AST_NODE_TYPES.MemberExpression:
        case utils_1.AST_NODE_TYPES.SwitchStatement:
        case utils_1.AST_NODE_TYPES.UpdateExpression:
        case utils_1.AST_NODE_TYPES.WhileStatement:
            return true;
        case utils_1.AST_NODE_TYPES.CallExpression:
            return parent.callee === node;
        case utils_1.AST_NODE_TYPES.ConditionalExpression:
            return parent.test === node;
        case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:
            return parent.tag === node;
        case utils_1.AST_NODE_TYPES.UnaryExpression:
            // the first case is safe for obvious
            // reasons. The second one is also fine
            // since we're returning something falsy
            return ['!', 'delete', 'typeof', 'void'].includes(parent.operator);
        case utils_1.AST_NODE_TYPES.BinaryExpression:
            return ['!=', '!==', '==', '===', 'instanceof'].includes(parent.operator);
        case utils_1.AST_NODE_TYPES.AssignmentExpression:
            return (parent.operator === '=' &&
                (node === parent.left ||
                    (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                        node.object.type === utils_1.AST_NODE_TYPES.Super &&
                        parent.left.type === utils_1.AST_NODE_TYPES.MemberExpression &&
                        parent.left.object.type === utils_1.AST_NODE_TYPES.ThisExpression)));
        case utils_1.AST_NODE_TYPES.ChainExpression:
        case utils_1.AST_NODE_TYPES.TSNonNullExpression:
        case utils_1.AST_NODE_TYPES.TSAsExpression:
        case utils_1.AST_NODE_TYPES.TSTypeAssertion:
            return isSafeUse(parent);
        case utils_1.AST_NODE_TYPES.LogicalExpression:
=======
function isSafeUse(node) {
    const parent = node.parent;
    switch (parent === null || parent === void 0 ? void 0 : parent.type) {
        case experimental_utils_1.AST_NODE_TYPES.IfStatement:
        case experimental_utils_1.AST_NODE_TYPES.ForStatement:
        case experimental_utils_1.AST_NODE_TYPES.MemberExpression:
        case experimental_utils_1.AST_NODE_TYPES.SwitchStatement:
        case experimental_utils_1.AST_NODE_TYPES.UpdateExpression:
        case experimental_utils_1.AST_NODE_TYPES.WhileStatement:
            return true;
        case experimental_utils_1.AST_NODE_TYPES.CallExpression:
            return parent.callee === node;
        case experimental_utils_1.AST_NODE_TYPES.ConditionalExpression:
            return parent.test === node;
        case experimental_utils_1.AST_NODE_TYPES.TaggedTemplateExpression:
            return parent.tag === node;
        case experimental_utils_1.AST_NODE_TYPES.UnaryExpression:
            // the first case is safe for obvious
            // reasons. The second one is also fine
            // since we're returning something falsy
            return ['typeof', '!', 'void', 'delete'].includes(parent.operator);
        case experimental_utils_1.AST_NODE_TYPES.BinaryExpression:
            return ['instanceof', '==', '!=', '===', '!=='].includes(parent.operator);
        case experimental_utils_1.AST_NODE_TYPES.AssignmentExpression:
            return (parent.operator === '=' &&
                (node === parent.left ||
                    (node.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression &&
                        node.object.type === experimental_utils_1.AST_NODE_TYPES.Super &&
                        parent.left.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression &&
                        parent.left.object.type === experimental_utils_1.AST_NODE_TYPES.ThisExpression)));
        case experimental_utils_1.AST_NODE_TYPES.ChainExpression:
        case experimental_utils_1.AST_NODE_TYPES.TSNonNullExpression:
        case experimental_utils_1.AST_NODE_TYPES.TSAsExpression:
        case experimental_utils_1.AST_NODE_TYPES.TSTypeAssertion:
            return isSafeUse(parent);
        case experimental_utils_1.AST_NODE_TYPES.LogicalExpression:
>>>>>>> packages
            if (parent.operator === '&&' && parent.left === node) {
                // this is safe, as && will return the left if and only if it's falsy
                return true;
            }
            // in all other cases, it's likely the logical expression will return the method ref
            // so make sure the parent is a safe usage
            return isSafeUse(parent);
    }
    return false;
}
//# sourceMappingURL=unbound-method.js.map