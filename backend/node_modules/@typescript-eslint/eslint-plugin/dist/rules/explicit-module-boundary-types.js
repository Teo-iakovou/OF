"use strict";
<<<<<<< HEAD
Object.defineProperty(exports, "__esModule", { value: true });
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const utils_1 = require("@typescript-eslint/utils");
const util_1 = require("../util");
const explicitReturnTypeUtils_1 = require("../util/explicitReturnTypeUtils");
exports.default = (0, util_1.createRule)({
=======
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const util = __importStar(require("../util"));
const explicitReturnTypeUtils_1 = require("../util/explicitReturnTypeUtils");
exports.default = util.createRule({
>>>>>>> packages
    name: 'explicit-module-boundary-types',
    meta: {
        type: 'problem',
        docs: {
            description: "Require explicit return and argument types on exported functions' and classes' public class methods",
<<<<<<< HEAD
        },
        messages: {
            anyTypedArg: "Argument '{{name}}' should be typed with a non-any type.",
            anyTypedArgUnnamed: '{{type}} argument should be typed with a non-any type.',
            missingArgType: "Argument '{{name}}' should be typed.",
            missingArgTypeUnnamed: '{{type}} argument should be typed.',
            missingReturnType: 'Missing return type on function.',
=======
            category: 'Stylistic Issues',
            recommended: 'warn',
        },
        messages: {
            missingReturnType: 'Missing return type on function.',
            missingArgType: "Argument '{{name}}' should be typed.",
            missingArgTypeUnnamed: '{{type}} argument should be typed.',
            anyTypedArg: "Argument '{{name}}' should be typed with a non-any type.",
            anyTypedArgUnnamed: '{{type}} argument should be typed with a non-any type.',
>>>>>>> packages
        },
        schema: [
            {
                type: 'object',
<<<<<<< HEAD
                additionalProperties: false,
                properties: {
                    allowArgumentsExplicitlyTypedAsAny: {
                        type: 'boolean',
                        description: 'Whether to ignore arguments that are explicitly typed as `any`.',
                    },
                    allowDirectConstAssertionInArrowFunctions: {
                        type: 'boolean',
                        description: [
                            'Whether to ignore return type annotations on body-less arrow functions that return an `as const` type assertion.',
                            'You must still type the parameters of the function.',
                        ].join('\n'),
                    },
                    allowedNames: {
                        type: 'array',
                        description: 'An array of function/method names that will not have their arguments or return values checked.',
=======
                properties: {
                    allowArgumentsExplicitlyTypedAsAny: {
                        type: 'boolean',
                    },
                    allowDirectConstAssertionInArrowFunctions: {
                        type: 'boolean',
                    },
                    allowedNames: {
                        type: 'array',
>>>>>>> packages
                        items: {
                            type: 'string',
                        },
                    },
                    allowHigherOrderFunctions: {
                        type: 'boolean',
<<<<<<< HEAD
                        description: [
                            'Whether to ignore return type annotations on functions immediately returning another function expression.',
                            'You must still type the parameters of the function.',
                        ].join('\n'),
                    },
                    allowTypedFunctionExpressions: {
                        type: 'boolean',
                        description: 'Whether to ignore type annotations on the variable of a function expression.',
                    },
                },
=======
                    },
                    allowTypedFunctionExpressions: {
                        type: 'boolean',
                    },
                    // DEPRECATED - To be removed in next major
                    shouldTrackReferences: {
                        type: 'boolean',
                    },
                },
                additionalProperties: false,
>>>>>>> packages
            },
        ],
    },
    defaultOptions: [
        {
            allowArgumentsExplicitlyTypedAsAny: false,
            allowDirectConstAssertionInArrowFunctions: true,
            allowedNames: [],
            allowHigherOrderFunctions: true,
            allowTypedFunctionExpressions: true,
        },
    ],
    create(context, [options]) {
<<<<<<< HEAD
        // tracks all of the functions we've already checked
        const checkedFunctions = new Set();
        const functionStack = [];
        const functionReturnsMap = new Map();
        // all nodes visited, avoids infinite recursion for cyclic references
        // (such as class member referring to itself)
        const alreadyVisited = new Set();
        function getReturnsInFunction(node) {
            return functionReturnsMap.get(node) ?? [];
        }
        function enterFunction(node) {
            functionStack.push(node);
            functionReturnsMap.set(node, []);
        }
        function exitFunction() {
            functionStack.pop();
        }
=======
        const sourceCode = context.getSourceCode();
        // tracks all of the functions we've already checked
        const checkedFunctions = new Set();
        // tracks functions that were found whilst traversing
        const foundFunctions = [];
        // all nodes visited, avoids infinite recursion for cyclic references
        // (such as class member referring to itself)
        const alreadyVisited = new Set();
>>>>>>> packages
        /*
        # How the rule works:
    
        As the rule traverses the AST, it immediately checks every single function that it finds is exported.
        "exported" means that it is either directly exported, or that its name is exported.
    
        It also collects a list of every single function it finds on the way, but does not check them.
        After it's finished traversing the AST, it then iterates through the list of found functions, and checks to see if
        any of them are part of a higher-order function
        */
        return {
<<<<<<< HEAD
            'ArrowFunctionExpression, FunctionDeclaration, FunctionExpression': enterFunction,
            'ArrowFunctionExpression:exit': exitFunction,
            'ExportDefaultDeclaration:exit'(node) {
                checkNode(node.declaration);
            },
            'ExportNamedDeclaration:not([source]):exit'(node) {
=======
            ExportDefaultDeclaration(node) {
                checkNode(node.declaration);
            },
            'ExportNamedDeclaration:not([source])'(node) {
>>>>>>> packages
                if (node.declaration) {
                    checkNode(node.declaration);
                }
                else {
                    for (const specifier of node.specifiers) {
                        followReference(specifier.local);
                    }
                }
            },
<<<<<<< HEAD
            'FunctionDeclaration:exit': exitFunction,
            'FunctionExpression:exit': exitFunction,
            'Program:exit'() {
                for (const [node, returns] of functionReturnsMap) {
                    if (isExportedHigherOrderFunction({ node, returns })) {
                        checkNode(node);
                    }
                }
            },
            ReturnStatement(node) {
                const current = functionStack[functionStack.length - 1];
                functionReturnsMap.get(current)?.push(node);
            },
            'TSExportAssignment:exit'(node) {
                checkNode(node.expression);
            },
=======
            TSExportAssignment(node) {
                checkNode(node.expression);
            },
            'ArrowFunctionExpression, FunctionDeclaration, FunctionExpression'(node) {
                foundFunctions.push(node);
            },
            'Program:exit'() {
                for (const func of foundFunctions) {
                    if (isExportedHigherOrderFunction(func)) {
                        checkNode(func);
                    }
                }
            },
>>>>>>> packages
        };
        function checkParameters(node) {
            function checkParameter(param) {
                function report(namedMessageId, unnamedMessageId) {
<<<<<<< HEAD
                    if (param.type === utils_1.AST_NODE_TYPES.Identifier) {
=======
                    if (param.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
>>>>>>> packages
                        context.report({
                            node: param,
                            messageId: namedMessageId,
                            data: { name: param.name },
                        });
                    }
<<<<<<< HEAD
                    else if (param.type === utils_1.AST_NODE_TYPES.ArrayPattern) {
=======
                    else if (param.type === experimental_utils_1.AST_NODE_TYPES.ArrayPattern) {
>>>>>>> packages
                        context.report({
                            node: param,
                            messageId: unnamedMessageId,
                            data: { type: 'Array pattern' },
                        });
                    }
<<<<<<< HEAD
                    else if (param.type === utils_1.AST_NODE_TYPES.ObjectPattern) {
=======
                    else if (param.type === experimental_utils_1.AST_NODE_TYPES.ObjectPattern) {
>>>>>>> packages
                        context.report({
                            node: param,
                            messageId: unnamedMessageId,
                            data: { type: 'Object pattern' },
                        });
                    }
<<<<<<< HEAD
                    else if (param.type === utils_1.AST_NODE_TYPES.RestElement) {
                        if (param.argument.type === utils_1.AST_NODE_TYPES.Identifier) {
=======
                    else if (param.type === experimental_utils_1.AST_NODE_TYPES.RestElement) {
                        if (param.argument.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
>>>>>>> packages
                            context.report({
                                node: param,
                                messageId: namedMessageId,
                                data: { name: param.argument.name },
                            });
                        }
                        else {
                            context.report({
                                node: param,
                                messageId: unnamedMessageId,
                                data: { type: 'Rest' },
                            });
                        }
                    }
                }
                switch (param.type) {
<<<<<<< HEAD
                    case utils_1.AST_NODE_TYPES.ArrayPattern:
                    case utils_1.AST_NODE_TYPES.Identifier:
                    case utils_1.AST_NODE_TYPES.ObjectPattern:
                    case utils_1.AST_NODE_TYPES.RestElement:
=======
                    case experimental_utils_1.AST_NODE_TYPES.ArrayPattern:
                    case experimental_utils_1.AST_NODE_TYPES.Identifier:
                    case experimental_utils_1.AST_NODE_TYPES.ObjectPattern:
                    case experimental_utils_1.AST_NODE_TYPES.RestElement:
>>>>>>> packages
                        if (!param.typeAnnotation) {
                            report('missingArgType', 'missingArgTypeUnnamed');
                        }
                        else if (options.allowArgumentsExplicitlyTypedAsAny !== true &&
                            param.typeAnnotation.typeAnnotation.type ===
<<<<<<< HEAD
                                utils_1.AST_NODE_TYPES.TSAnyKeyword) {
                            report('anyTypedArg', 'anyTypedArgUnnamed');
                        }
                        return;
                    case utils_1.AST_NODE_TYPES.TSParameterProperty:
                        return checkParameter(param.parameter);
                    case utils_1.AST_NODE_TYPES.AssignmentPattern: // ignored as it has a type via its assignment
=======
                                experimental_utils_1.AST_NODE_TYPES.TSAnyKeyword) {
                            report('anyTypedArg', 'anyTypedArgUnnamed');
                        }
                        return;
                    case experimental_utils_1.AST_NODE_TYPES.TSParameterProperty:
                        return checkParameter(param.parameter);
                    case experimental_utils_1.AST_NODE_TYPES.AssignmentPattern: // ignored as it has a type via its assignment
>>>>>>> packages
                        return;
                }
            }
            for (const arg of node.params) {
                checkParameter(arg);
            }
        }
        /**
         * Checks if a function name is allowed and should not be checked.
         */
        function isAllowedName(node) {
<<<<<<< HEAD
            if (!node || !options.allowedNames || options.allowedNames.length === 0) {
                return false;
            }
            if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator ||
                node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration) {
                return (node.id?.type === utils_1.AST_NODE_TYPES.Identifier &&
                    options.allowedNames.includes(node.id.name));
            }
            if (node.type === utils_1.AST_NODE_TYPES.MethodDefinition ||
                node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
                (node.type === utils_1.AST_NODE_TYPES.Property && node.method) ||
                node.type === utils_1.AST_NODE_TYPES.PropertyDefinition) {
                return (0, util_1.isStaticMemberAccessOfValue)(node, context, ...options.allowedNames);
            }
            return false;
        }
        function isExportedHigherOrderFunction({ node, }) {
            let current = node.parent;
            while (current) {
                if (current.type === utils_1.AST_NODE_TYPES.ReturnStatement) {
                    // the parent of a return will always be a block statement, so we can skip over it
                    current = current.parent.parent;
                    continue;
                }
                if (!(0, util_1.isFunction)(current)) {
                    return false;
                }
                const returns = getReturnsInFunction(current);
                if (!(0, explicitReturnTypeUtils_1.doesImmediatelyReturnFunctionExpression)({ node: current, returns })) {
=======
            var _a;
            if (!node || !options.allowedNames || !options.allowedNames.length) {
                return false;
            }
            if (node.type === experimental_utils_1.AST_NODE_TYPES.VariableDeclarator ||
                node.type === experimental_utils_1.AST_NODE_TYPES.FunctionDeclaration) {
                return (((_a = node.id) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.Identifier &&
                    options.allowedNames.includes(node.id.name));
            }
            else if (node.type === experimental_utils_1.AST_NODE_TYPES.MethodDefinition ||
                node.type === experimental_utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
                (node.type === experimental_utils_1.AST_NODE_TYPES.Property && node.method)) {
                if (node.key.type === experimental_utils_1.AST_NODE_TYPES.Literal &&
                    typeof node.key.value === 'string') {
                    return options.allowedNames.includes(node.key.value);
                }
                if (node.key.type === experimental_utils_1.AST_NODE_TYPES.TemplateLiteral &&
                    node.key.expressions.length === 0) {
                    return options.allowedNames.includes(node.key.quasis[0].value.raw);
                }
                if (!node.computed && node.key.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
                    return options.allowedNames.includes(node.key.name);
                }
            }
            return false;
        }
        function isExportedHigherOrderFunction(node) {
            var _a;
            let current = node.parent;
            while (current) {
                if (current.type === experimental_utils_1.AST_NODE_TYPES.ReturnStatement) {
                    // the parent of a return will always be a block statement, so we can skip over it
                    current = (_a = current.parent) === null || _a === void 0 ? void 0 : _a.parent;
                    continue;
                }
                if (!util.isFunction(current) ||
                    !(0, explicitReturnTypeUtils_1.doesImmediatelyReturnFunctionExpression)(current)) {
>>>>>>> packages
                    return false;
                }
                if (checkedFunctions.has(current)) {
                    return true;
                }
                current = current.parent;
            }
            return false;
        }
        function followReference(node) {
<<<<<<< HEAD
            const scope = context.sourceCode.getScope(node);
=======
            const scope = context.getScope();
>>>>>>> packages
            const variable = scope.set.get(node.name);
            /* istanbul ignore if */ if (!variable) {
                return;
            }
            // check all of the definitions
            for (const definition of variable.defs) {
                // cases we don't care about in this rule
                if ([
<<<<<<< HEAD
                    scope_manager_1.DefinitionType.CatchClause,
                    scope_manager_1.DefinitionType.ImplicitGlobalVariable,
                    scope_manager_1.DefinitionType.ImportBinding,
=======
                    scope_manager_1.DefinitionType.ImplicitGlobalVariable,
                    scope_manager_1.DefinitionType.ImportBinding,
                    scope_manager_1.DefinitionType.CatchClause,
>>>>>>> packages
                    scope_manager_1.DefinitionType.Parameter,
                ].includes(definition.type)) {
                    continue;
                }
                checkNode(definition.node);
            }
            // follow references to find writes to the variable
            for (const reference of variable.references) {
                if (
                // we don't want to check the initialization ref, as this is handled by the declaration check
                !reference.init &&
                    reference.writeExpr) {
                    checkNode(reference.writeExpr);
                }
            }
        }
        function checkNode(node) {
            if (node == null || alreadyVisited.has(node)) {
                return;
            }
            alreadyVisited.add(node);
            switch (node.type) {
<<<<<<< HEAD
                case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                case utils_1.AST_NODE_TYPES.FunctionExpression: {
                    const returns = getReturnsInFunction(node);
                    return checkFunctionExpression({ node, returns });
                }
                case utils_1.AST_NODE_TYPES.ArrayExpression:
=======
                case experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                case experimental_utils_1.AST_NODE_TYPES.FunctionExpression:
                    return checkFunctionExpression(node);
                case experimental_utils_1.AST_NODE_TYPES.ArrayExpression:
>>>>>>> packages
                    for (const element of node.elements) {
                        checkNode(element);
                    }
                    return;
<<<<<<< HEAD
                case utils_1.AST_NODE_TYPES.PropertyDefinition:
                case utils_1.AST_NODE_TYPES.MethodDefinition:
                case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
                    if (node.accessibility === 'private' ||
                        node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {
                        return;
                    }
                    return checkNode(node.value);
                case utils_1.AST_NODE_TYPES.ClassDeclaration:
                case utils_1.AST_NODE_TYPES.ClassExpression:
=======
                case experimental_utils_1.AST_NODE_TYPES.ClassProperty:
                case experimental_utils_1.AST_NODE_TYPES.TSAbstractClassProperty:
                    if (node.accessibility === 'private') {
                        return;
                    }
                    return checkNode(node.value);
                case experimental_utils_1.AST_NODE_TYPES.ClassDeclaration:
                case experimental_utils_1.AST_NODE_TYPES.ClassExpression:
>>>>>>> packages
                    for (const element of node.body.body) {
                        checkNode(element);
                    }
                    return;
<<<<<<< HEAD
                case utils_1.AST_NODE_TYPES.FunctionDeclaration: {
                    const returns = getReturnsInFunction(node);
                    return checkFunction({ node, returns });
                }
                case utils_1.AST_NODE_TYPES.Identifier:
                    return followReference(node);
                case utils_1.AST_NODE_TYPES.ObjectExpression:
=======
                case experimental_utils_1.AST_NODE_TYPES.FunctionDeclaration:
                    return checkFunction(node);
                case experimental_utils_1.AST_NODE_TYPES.MethodDefinition:
                case experimental_utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:
                    if (node.accessibility === 'private') {
                        return;
                    }
                    return checkNode(node.value);
                case experimental_utils_1.AST_NODE_TYPES.Identifier:
                    return followReference(node);
                case experimental_utils_1.AST_NODE_TYPES.ObjectExpression:
>>>>>>> packages
                    for (const property of node.properties) {
                        checkNode(property);
                    }
                    return;
<<<<<<< HEAD
                case utils_1.AST_NODE_TYPES.Property:
                    return checkNode(node.value);
                case utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:
                    return checkEmptyBodyFunctionExpression(node);
                case utils_1.AST_NODE_TYPES.VariableDeclaration:
=======
                case experimental_utils_1.AST_NODE_TYPES.Property:
                    return checkNode(node.value);
                case experimental_utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:
                    return checkEmptyBodyFunctionExpression(node);
                case experimental_utils_1.AST_NODE_TYPES.VariableDeclaration:
>>>>>>> packages
                    for (const declaration of node.declarations) {
                        checkNode(declaration);
                    }
                    return;
<<<<<<< HEAD
                case utils_1.AST_NODE_TYPES.VariableDeclarator:
                    return checkNode(node.init);
            }
        }
        function checkEmptyBodyFunctionExpression(node) {
            const isConstructor = node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
                node.parent.kind === 'constructor';
            const isSetAccessor = (node.parent.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
                node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition) &&
=======
                case experimental_utils_1.AST_NODE_TYPES.VariableDeclarator:
                    return checkNode(node.init);
            }
        }
        /**
         * Check whether any ancestor of the provided function has a valid return type.
         * This function assumes that the function either:
         * - belongs to an exported function chain validated by isExportedHigherOrderFunction
         * - is directly exported itself
         */
        function ancestorHasReturnType(node) {
            let ancestor = node.parent;
            if ((ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === experimental_utils_1.AST_NODE_TYPES.Property) {
                ancestor = ancestor.value;
            }
            // if the ancestor is not a return, then this function was not returned at all, so we can exit early
            const isReturnStatement = (ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === experimental_utils_1.AST_NODE_TYPES.ReturnStatement;
            const isBodylessArrow = (ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&
                ancestor.body.type !== experimental_utils_1.AST_NODE_TYPES.BlockStatement;
            if (!isReturnStatement && !isBodylessArrow) {
                return false;
            }
            while (ancestor) {
                switch (ancestor.type) {
                    case experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression:
                    case experimental_utils_1.AST_NODE_TYPES.FunctionExpression:
                    case experimental_utils_1.AST_NODE_TYPES.FunctionDeclaration:
                        if (ancestor.returnType) {
                            return true;
                        }
                        // assume
                        break;
                    // const x: Foo = () => {};
                    // Assume that a typed variable types the function expression
                    case experimental_utils_1.AST_NODE_TYPES.VariableDeclarator:
                        if (ancestor.id.typeAnnotation) {
                            return true;
                        }
                        break;
                }
                ancestor = ancestor.parent;
            }
            return false;
        }
        function checkEmptyBodyFunctionExpression(node) {
            var _a, _b, _c;
            const isConstructor = ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.MethodDefinition &&
                node.parent.kind === 'constructor';
            const isSetAccessor = (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === experimental_utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||
                ((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type) === experimental_utils_1.AST_NODE_TYPES.MethodDefinition) &&
>>>>>>> packages
                node.parent.kind === 'set';
            if (!isConstructor && !isSetAccessor && !node.returnType) {
                context.report({
                    node,
                    messageId: 'missingReturnType',
                });
            }
            checkParameters(node);
        }
<<<<<<< HEAD
        function checkFunctionExpression({ node, returns, }) {
=======
        function checkFunctionExpression(node) {
>>>>>>> packages
            if (checkedFunctions.has(node)) {
                return;
            }
            checkedFunctions.add(node);
            if (isAllowedName(node.parent) ||
                (0, explicitReturnTypeUtils_1.isTypedFunctionExpression)(node, options) ||
<<<<<<< HEAD
                (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {
                return;
            }
            (0, explicitReturnTypeUtils_1.checkFunctionExpressionReturnType)({ node, returns }, options, context.sourceCode, loc => {
                context.report({
                    loc,
                    node,
=======
                ancestorHasReturnType(node)) {
                return;
            }
            (0, explicitReturnTypeUtils_1.checkFunctionExpressionReturnType)(node, options, sourceCode, loc => {
                context.report({
                    node,
                    loc,
>>>>>>> packages
                    messageId: 'missingReturnType',
                });
            });
            checkParameters(node);
        }
<<<<<<< HEAD
        function checkFunction({ node, returns, }) {
=======
        function checkFunction(node) {
>>>>>>> packages
            if (checkedFunctions.has(node)) {
                return;
            }
            checkedFunctions.add(node);
<<<<<<< HEAD
            if (isAllowedName(node) || (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node)) {
                return;
            }
            (0, explicitReturnTypeUtils_1.checkFunctionReturnType)({ node, returns }, options, context.sourceCode, loc => {
                context.report({
                    loc,
                    node,
=======
            if (isAllowedName(node) || ancestorHasReturnType(node)) {
                return;
            }
            (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(node, options, sourceCode, loc => {
                context.report({
                    node,
                    loc,
>>>>>>> packages
                    messageId: 'missingReturnType',
                });
            });
            checkParameters(node);
        }
    },
});
//# sourceMappingURL=explicit-module-boundary-types.js.map