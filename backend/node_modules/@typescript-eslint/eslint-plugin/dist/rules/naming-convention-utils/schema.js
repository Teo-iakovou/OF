"use strict";
<<<<<<< HEAD
Object.defineProperty(exports, "__esModule", { value: true });
exports.SCHEMA = void 0;
const util_1 = require("../../util");
const enums_1 = require("./enums");
const $DEFS = {
    // enums
    predefinedFormats: {
        enum: (0, util_1.getEnumNames)(enums_1.PredefinedFormats),
        type: 'string',
    },
    typeModifiers: {
        enum: (0, util_1.getEnumNames)(enums_1.TypeModifiers),
        type: 'string',
    },
    underscoreOptions: {
        enum: (0, util_1.getEnumNames)(enums_1.UnderscoreOptions),
        type: 'string',
    },
    // repeated types
    formatOptionsConfig: {
        oneOf: [
            {
                additionalItems: false,
                items: {
                    $ref: '#/$defs/predefinedFormats',
                },
                type: 'array',
=======
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SCHEMA = void 0;
const enums_1 = require("./enums");
const util = __importStar(require("../../util"));
const UNDERSCORE_SCHEMA = {
    type: 'string',
    enum: util.getEnumNames(enums_1.UnderscoreOptions),
};
const PREFIX_SUFFIX_SCHEMA = {
    type: 'array',
    items: {
        type: 'string',
        minLength: 1,
    },
    additionalItems: false,
};
const MATCH_REGEX_SCHEMA = {
    type: 'object',
    properties: {
        match: { type: 'boolean' },
        regex: { type: 'string' },
    },
    required: ['match', 'regex'],
};
const FORMAT_OPTIONS_PROPERTIES = {
    format: {
        oneOf: [
            {
                type: 'array',
                items: {
                    type: 'string',
                    enum: util.getEnumNames(enums_1.PredefinedFormats),
                },
                additionalItems: false,
>>>>>>> packages
            },
            {
                type: 'null',
            },
        ],
    },
<<<<<<< HEAD
    matchRegexConfig: {
        additionalProperties: false,
        properties: {
            match: { type: 'boolean' },
            regex: { type: 'string' },
        },
        required: ['match', 'regex'],
        type: 'object',
    },
    prefixSuffixConfig: {
        additionalItems: false,
        items: {
            minLength: 1,
            type: 'string',
        },
        type: 'array',
    },
};
const UNDERSCORE_SCHEMA = {
    $ref: '#/$defs/underscoreOptions',
};
const PREFIX_SUFFIX_SCHEMA = {
    $ref: '#/$defs/prefixSuffixConfig',
};
const MATCH_REGEX_SCHEMA = {
    $ref: '#/$defs/matchRegexConfig',
};
const FORMAT_OPTIONS_PROPERTIES = {
    custom: MATCH_REGEX_SCHEMA,
    failureMessage: {
        type: 'string',
    },
    format: {
        $ref: '#/$defs/formatOptionsConfig',
    },
    leadingUnderscore: UNDERSCORE_SCHEMA,
    prefix: PREFIX_SUFFIX_SCHEMA,
    suffix: PREFIX_SUFFIX_SCHEMA,
    trailingUnderscore: UNDERSCORE_SCHEMA,
=======
    custom: MATCH_REGEX_SCHEMA,
    leadingUnderscore: UNDERSCORE_SCHEMA,
    trailingUnderscore: UNDERSCORE_SCHEMA,
    prefix: PREFIX_SUFFIX_SCHEMA,
    suffix: PREFIX_SUFFIX_SCHEMA,
    failureMessage: {
        type: 'string',
    },
>>>>>>> packages
};
function selectorSchema(selectorString, allowType, modifiers) {
    const selector = {
        filter: {
            oneOf: [
                {
<<<<<<< HEAD
                    minLength: 1,
                    type: 'string',
=======
                    type: 'string',
                    minLength: 1,
>>>>>>> packages
                },
                MATCH_REGEX_SCHEMA,
            ],
        },
        selector: {
<<<<<<< HEAD
            enum: [selectorString],
            type: 'string',
=======
            type: 'string',
            enum: [selectorString],
>>>>>>> packages
        },
    };
    if (modifiers && modifiers.length > 0) {
        selector.modifiers = {
<<<<<<< HEAD
            additionalItems: false,
            items: {
                enum: modifiers,
                type: 'string',
            },
            type: 'array',
=======
            type: 'array',
            items: {
                type: 'string',
                enum: modifiers,
            },
            additionalItems: false,
>>>>>>> packages
        };
    }
    if (allowType) {
        selector.types = {
<<<<<<< HEAD
            additionalItems: false,
            items: {
                $ref: '#/$defs/typeModifiers',
            },
            type: 'array',
=======
            type: 'array',
            items: {
                type: 'string',
                enum: util.getEnumNames(enums_1.TypeModifiers),
            },
            additionalItems: false,
>>>>>>> packages
        };
    }
    return [
        {
<<<<<<< HEAD
            additionalProperties: false,
            description: `Selector '${selectorString}'`,
            properties: {
                ...FORMAT_OPTIONS_PROPERTIES,
                ...selector,
            },
            required: ['selector', 'format'],
            type: 'object',
=======
            type: 'object',
            properties: Object.assign(Object.assign({}, FORMAT_OPTIONS_PROPERTIES), selector),
            required: ['selector', 'format'],
            additionalProperties: false,
>>>>>>> packages
        },
    ];
}
function selectorsSchema() {
    return {
<<<<<<< HEAD
        additionalProperties: false,
        description: 'Multiple selectors in one config',
        properties: {
            ...FORMAT_OPTIONS_PROPERTIES,
            filter: {
                oneOf: [
                    {
                        minLength: 1,
                        type: 'string',
=======
        type: 'object',
        properties: Object.assign(Object.assign({}, FORMAT_OPTIONS_PROPERTIES), {
            filter: {
                oneOf: [
                    {
                        type: 'string',
                        minLength: 1,
>>>>>>> packages
                    },
                    MATCH_REGEX_SCHEMA,
                ],
            },
<<<<<<< HEAD
            modifiers: {
                additionalItems: false,
                items: {
                    enum: (0, util_1.getEnumNames)(enums_1.Modifiers),
                    type: 'string',
                },
                type: 'array',
            },
            selector: {
                additionalItems: false,
                items: {
                    enum: [...(0, util_1.getEnumNames)(enums_1.MetaSelectors), ...(0, util_1.getEnumNames)(enums_1.Selectors)],
                    type: 'string',
                },
                type: 'array',
            },
            types: {
                additionalItems: false,
                items: {
                    $ref: '#/$defs/typeModifiers',
                },
                type: 'array',
            },
        },
        required: ['selector', 'format'],
        type: 'object',
    };
}
const SCHEMA = {
    $defs: $DEFS,
    additionalItems: false,
    items: {
        oneOf: [
            selectorsSchema(),
            ...selectorSchema('default', false, (0, util_1.getEnumNames)(enums_1.Modifiers)),
            ...selectorSchema('variableLike', false, ['unused', 'async']),
=======
            selector: {
                type: 'array',
                items: {
                    type: 'string',
                    enum: [
                        ...util.getEnumNames(enums_1.MetaSelectors),
                        ...util.getEnumNames(enums_1.Selectors),
                    ],
                },
                additionalItems: false,
            },
            modifiers: {
                type: 'array',
                items: {
                    type: 'string',
                    enum: util.getEnumNames(enums_1.Modifiers),
                },
                additionalItems: false,
            },
            types: {
                type: 'array',
                items: {
                    type: 'string',
                    enum: util.getEnumNames(enums_1.TypeModifiers),
                },
                additionalItems: false,
            },
        }),
        required: ['selector', 'format'],
        additionalProperties: false,
    };
}
const SCHEMA = {
    type: 'array',
    items: {
        oneOf: [
            selectorsSchema(),
            ...selectorSchema('default', false, util.getEnumNames(enums_1.Modifiers)),
            ...selectorSchema('variableLike', false, ['unused']),
>>>>>>> packages
            ...selectorSchema('variable', true, [
                'const',
                'destructured',
                'exported',
                'global',
                'unused',
<<<<<<< HEAD
                'async',
            ]),
            ...selectorSchema('function', false, [
                'exported',
                'global',
                'unused',
                'async',
            ]),
=======
            ]),
            ...selectorSchema('function', false, ['exported', 'global', 'unused']),
>>>>>>> packages
            ...selectorSchema('parameter', true, ['destructured', 'unused']),
            ...selectorSchema('memberLike', false, [
                'abstract',
                'private',
<<<<<<< HEAD
                '#private',
=======
>>>>>>> packages
                'protected',
                'public',
                'readonly',
                'requiresQuotes',
                'static',
<<<<<<< HEAD
                'override',
                'async',
=======
>>>>>>> packages
            ]),
            ...selectorSchema('classProperty', true, [
                'abstract',
                'private',
<<<<<<< HEAD
                '#private',
=======
>>>>>>> packages
                'protected',
                'public',
                'readonly',
                'requiresQuotes',
                'static',
<<<<<<< HEAD
                'override',
=======
>>>>>>> packages
            ]),
            ...selectorSchema('objectLiteralProperty', true, [
                'public',
                'requiresQuotes',
            ]),
            ...selectorSchema('typeProperty', true, [
                'public',
                'readonly',
                'requiresQuotes',
            ]),
            ...selectorSchema('parameterProperty', true, [
                'private',
                'protected',
                'public',
                'readonly',
            ]),
            ...selectorSchema('property', true, [
                'abstract',
                'private',
<<<<<<< HEAD
                '#private',
=======
>>>>>>> packages
                'protected',
                'public',
                'readonly',
                'requiresQuotes',
                'static',
<<<<<<< HEAD
                'override',
                'async',
=======
>>>>>>> packages
            ]),
            ...selectorSchema('classMethod', false, [
                'abstract',
                'private',
<<<<<<< HEAD
                '#private',
=======
>>>>>>> packages
                'protected',
                'public',
                'requiresQuotes',
                'static',
<<<<<<< HEAD
                'override',
                'async',
=======
>>>>>>> packages
            ]),
            ...selectorSchema('objectLiteralMethod', false, [
                'public',
                'requiresQuotes',
<<<<<<< HEAD
                'async',
=======
>>>>>>> packages
            ]),
            ...selectorSchema('typeMethod', false, ['public', 'requiresQuotes']),
            ...selectorSchema('method', false, [
                'abstract',
                'private',
<<<<<<< HEAD
                '#private',
=======
>>>>>>> packages
                'protected',
                'public',
                'requiresQuotes',
                'static',
<<<<<<< HEAD
                'override',
                'async',
            ]),
            ...selectorSchema('classicAccessor', true, [
                'abstract',
                'private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
                'override',
            ]),
            ...selectorSchema('autoAccessor', true, [
                'abstract',
                'private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
                'override',
=======
>>>>>>> packages
            ]),
            ...selectorSchema('accessor', true, [
                'abstract',
                'private',
                'protected',
                'public',
                'requiresQuotes',
                'static',
<<<<<<< HEAD
                'override',
=======
>>>>>>> packages
            ]),
            ...selectorSchema('enumMember', false, ['requiresQuotes']),
            ...selectorSchema('typeLike', false, ['abstract', 'exported', 'unused']),
            ...selectorSchema('class', false, ['abstract', 'exported', 'unused']),
            ...selectorSchema('interface', false, ['exported', 'unused']),
            ...selectorSchema('typeAlias', false, ['exported', 'unused']),
            ...selectorSchema('enum', false, ['exported', 'unused']),
            ...selectorSchema('typeParameter', false, ['unused']),
<<<<<<< HEAD
            ...selectorSchema('import', false, ['default', 'namespace']),
        ],
    },
    type: 'array',
=======
        ],
    },
    additionalItems: false,
>>>>>>> packages
};
exports.SCHEMA = SCHEMA;
//# sourceMappingURL=schema.js.map